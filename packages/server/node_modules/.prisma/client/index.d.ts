
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model app_versions
 * 
 */
export type app_versions = $Result.DefaultSelection<Prisma.$app_versionsPayload>
/**
 * Model products
 * 
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model push_notifications
 * 
 */
export type push_notifications = $Result.DefaultSelection<Prisma.$push_notificationsPayload>
/**
 * Model push_notification_history
 * 
 */
export type push_notification_history = $Result.DefaultSelection<Prisma.$push_notification_historyPayload>
/**
 * Model brands
 * 
 */
export type brands = $Result.DefaultSelection<Prisma.$brandsPayload>
/**
 * Model link_visits
 * 
 */
export type link_visits = $Result.DefaultSelection<Prisma.$link_visitsPayload>
/**
 * Model events
 * 
 */
export type events = $Result.DefaultSelection<Prisma.$eventsPayload>
/**
 * Model question_classes
 * 
 */
export type question_classes = $Result.DefaultSelection<Prisma.$question_classesPayload>
/**
 * Model answers
 * 
 */
export type answers = $Result.DefaultSelection<Prisma.$answersPayload>
/**
 * Model questionnaires
 * 
 */
export type questionnaires = $Result.DefaultSelection<Prisma.$questionnairesPayload>
/**
 * Model production_submissions
 * 
 */
export type production_submissions = $Result.DefaultSelection<Prisma.$production_submissionsPayload>
/**
 * Model questions
 * 
 */
export type questions = $Result.DefaultSelection<Prisma.$questionsPayload>
/**
 * Model ratings
 * 
 */
export type ratings = $Result.DefaultSelection<Prisma.$ratingsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationType: {
  GENERAL: 'GENERAL',
  PRODUCT: 'PRODUCT',
  EVENT: 'EVENT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more App_versions
 * const app_versions = await prisma.app_versions.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more App_versions
   * const app_versions = await prisma.app_versions.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.app_versions`: Exposes CRUD operations for the **app_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_versions
    * const app_versions = await prisma.app_versions.findMany()
    * ```
    */
  get app_versions(): Prisma.app_versionsDelegate<ExtArgs>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs>;

  /**
   * `prisma.push_notifications`: Exposes CRUD operations for the **push_notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Push_notifications
    * const push_notifications = await prisma.push_notifications.findMany()
    * ```
    */
  get push_notifications(): Prisma.push_notificationsDelegate<ExtArgs>;

  /**
   * `prisma.push_notification_history`: Exposes CRUD operations for the **push_notification_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Push_notification_histories
    * const push_notification_histories = await prisma.push_notification_history.findMany()
    * ```
    */
  get push_notification_history(): Prisma.push_notification_historyDelegate<ExtArgs>;

  /**
   * `prisma.brands`: Exposes CRUD operations for the **brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brands.findMany()
    * ```
    */
  get brands(): Prisma.brandsDelegate<ExtArgs>;

  /**
   * `prisma.link_visits`: Exposes CRUD operations for the **link_visits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Link_visits
    * const link_visits = await prisma.link_visits.findMany()
    * ```
    */
  get link_visits(): Prisma.link_visitsDelegate<ExtArgs>;

  /**
   * `prisma.events`: Exposes CRUD operations for the **events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.events.findMany()
    * ```
    */
  get events(): Prisma.eventsDelegate<ExtArgs>;

  /**
   * `prisma.question_classes`: Exposes CRUD operations for the **question_classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Question_classes
    * const question_classes = await prisma.question_classes.findMany()
    * ```
    */
  get question_classes(): Prisma.question_classesDelegate<ExtArgs>;

  /**
   * `prisma.answers`: Exposes CRUD operations for the **answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answers.findMany()
    * ```
    */
  get answers(): Prisma.answersDelegate<ExtArgs>;

  /**
   * `prisma.questionnaires`: Exposes CRUD operations for the **questionnaires** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questionnaires
    * const questionnaires = await prisma.questionnaires.findMany()
    * ```
    */
  get questionnaires(): Prisma.questionnairesDelegate<ExtArgs>;

  /**
   * `prisma.production_submissions`: Exposes CRUD operations for the **production_submissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Production_submissions
    * const production_submissions = await prisma.production_submissions.findMany()
    * ```
    */
  get production_submissions(): Prisma.production_submissionsDelegate<ExtArgs>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.questionsDelegate<ExtArgs>;

  /**
   * `prisma.ratings`: Exposes CRUD operations for the **ratings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.ratings.findMany()
    * ```
    */
  get ratings(): Prisma.ratingsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    app_versions: 'app_versions',
    products: 'products',
    push_notifications: 'push_notifications',
    push_notification_history: 'push_notification_history',
    brands: 'brands',
    link_visits: 'link_visits',
    events: 'events',
    question_classes: 'question_classes',
    answers: 'answers',
    questionnaires: 'questionnaires',
    production_submissions: 'production_submissions',
    questions: 'questions',
    ratings: 'ratings',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "app_versions" | "products" | "push_notifications" | "push_notification_history" | "brands" | "link_visits" | "events" | "question_classes" | "answers" | "questionnaires" | "production_submissions" | "questions" | "ratings" | "users"
      txIsolationLevel: never
    }
    model: {
      app_versions: {
        payload: Prisma.$app_versionsPayload<ExtArgs>
        fields: Prisma.app_versionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_versionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_versionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          findFirst: {
            args: Prisma.app_versionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_versionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          findMany: {
            args: Prisma.app_versionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>[]
          }
          create: {
            args: Prisma.app_versionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          createMany: {
            args: Prisma.app_versionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.app_versionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          update: {
            args: Prisma.app_versionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          deleteMany: {
            args: Prisma.app_versionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_versionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_versionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          aggregate: {
            args: Prisma.App_versionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_versions>
          }
          groupBy: {
            args: Prisma.app_versionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_versionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.app_versionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.app_versionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.app_versionsCountArgs<ExtArgs>
            result: $Utils.Optional<App_versionsCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.productsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.productsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      push_notifications: {
        payload: Prisma.$push_notificationsPayload<ExtArgs>
        fields: Prisma.push_notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.push_notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.push_notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          findFirst: {
            args: Prisma.push_notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.push_notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          findMany: {
            args: Prisma.push_notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>[]
          }
          create: {
            args: Prisma.push_notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          createMany: {
            args: Prisma.push_notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.push_notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          update: {
            args: Prisma.push_notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          deleteMany: {
            args: Prisma.push_notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.push_notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.push_notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          aggregate: {
            args: Prisma.Push_notificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePush_notifications>
          }
          groupBy: {
            args: Prisma.push_notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Push_notificationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.push_notificationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.push_notificationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.push_notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<Push_notificationsCountAggregateOutputType> | number
          }
        }
      }
      push_notification_history: {
        payload: Prisma.$push_notification_historyPayload<ExtArgs>
        fields: Prisma.push_notification_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.push_notification_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.push_notification_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          findFirst: {
            args: Prisma.push_notification_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.push_notification_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          findMany: {
            args: Prisma.push_notification_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>[]
          }
          create: {
            args: Prisma.push_notification_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          createMany: {
            args: Prisma.push_notification_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.push_notification_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          update: {
            args: Prisma.push_notification_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          deleteMany: {
            args: Prisma.push_notification_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.push_notification_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.push_notification_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          aggregate: {
            args: Prisma.Push_notification_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePush_notification_history>
          }
          groupBy: {
            args: Prisma.push_notification_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Push_notification_historyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.push_notification_historyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.push_notification_historyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.push_notification_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Push_notification_historyCountAggregateOutputType> | number
          }
        }
      }
      brands: {
        payload: Prisma.$brandsPayload<ExtArgs>
        fields: Prisma.brandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findFirst: {
            args: Prisma.brandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findMany: {
            args: Prisma.brandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          create: {
            args: Prisma.brandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          createMany: {
            args: Prisma.brandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.brandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          update: {
            args: Prisma.brandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          deleteMany: {
            args: Prisma.brandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.brandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.brandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          aggregate: {
            args: Prisma.BrandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrands>
          }
          groupBy: {
            args: Prisma.brandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.brandsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.brandsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.brandsCountArgs<ExtArgs>
            result: $Utils.Optional<BrandsCountAggregateOutputType> | number
          }
        }
      }
      link_visits: {
        payload: Prisma.$link_visitsPayload<ExtArgs>
        fields: Prisma.link_visitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.link_visitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.link_visitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          findFirst: {
            args: Prisma.link_visitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.link_visitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          findMany: {
            args: Prisma.link_visitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>[]
          }
          create: {
            args: Prisma.link_visitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          createMany: {
            args: Prisma.link_visitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.link_visitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          update: {
            args: Prisma.link_visitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          deleteMany: {
            args: Prisma.link_visitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.link_visitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.link_visitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          aggregate: {
            args: Prisma.Link_visitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLink_visits>
          }
          groupBy: {
            args: Prisma.link_visitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Link_visitsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.link_visitsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.link_visitsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.link_visitsCountArgs<ExtArgs>
            result: $Utils.Optional<Link_visitsCountAggregateOutputType> | number
          }
        }
      }
      events: {
        payload: Prisma.$eventsPayload<ExtArgs>
        fields: Prisma.eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          findFirst: {
            args: Prisma.eventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          findMany: {
            args: Prisma.eventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>[]
          }
          create: {
            args: Prisma.eventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          createMany: {
            args: Prisma.eventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.eventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          update: {
            args: Prisma.eventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          deleteMany: {
            args: Prisma.eventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.eventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventsPayload>
          }
          aggregate: {
            args: Prisma.EventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents>
          }
          groupBy: {
            args: Prisma.eventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.eventsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.eventsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.eventsCountArgs<ExtArgs>
            result: $Utils.Optional<EventsCountAggregateOutputType> | number
          }
        }
      }
      question_classes: {
        payload: Prisma.$question_classesPayload<ExtArgs>
        fields: Prisma.question_classesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.question_classesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.question_classesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          findFirst: {
            args: Prisma.question_classesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.question_classesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          findMany: {
            args: Prisma.question_classesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>[]
          }
          create: {
            args: Prisma.question_classesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          createMany: {
            args: Prisma.question_classesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.question_classesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          update: {
            args: Prisma.question_classesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          deleteMany: {
            args: Prisma.question_classesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.question_classesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.question_classesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          aggregate: {
            args: Prisma.Question_classesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion_classes>
          }
          groupBy: {
            args: Prisma.question_classesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Question_classesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.question_classesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.question_classesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.question_classesCountArgs<ExtArgs>
            result: $Utils.Optional<Question_classesCountAggregateOutputType> | number
          }
        }
      }
      answers: {
        payload: Prisma.$answersPayload<ExtArgs>
        fields: Prisma.answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          findFirst: {
            args: Prisma.answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          findMany: {
            args: Prisma.answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>[]
          }
          create: {
            args: Prisma.answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          createMany: {
            args: Prisma.answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          update: {
            args: Prisma.answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          deleteMany: {
            args: Prisma.answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          aggregate: {
            args: Prisma.AnswersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswers>
          }
          groupBy: {
            args: Prisma.answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.answersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.answersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.answersCountArgs<ExtArgs>
            result: $Utils.Optional<AnswersCountAggregateOutputType> | number
          }
        }
      }
      questionnaires: {
        payload: Prisma.$questionnairesPayload<ExtArgs>
        fields: Prisma.questionnairesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionnairesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionnairesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          findFirst: {
            args: Prisma.questionnairesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionnairesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          findMany: {
            args: Prisma.questionnairesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>[]
          }
          create: {
            args: Prisma.questionnairesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          createMany: {
            args: Prisma.questionnairesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questionnairesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          update: {
            args: Prisma.questionnairesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          deleteMany: {
            args: Prisma.questionnairesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionnairesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questionnairesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          aggregate: {
            args: Prisma.QuestionnairesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionnaires>
          }
          groupBy: {
            args: Prisma.questionnairesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionnairesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.questionnairesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.questionnairesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.questionnairesCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionnairesCountAggregateOutputType> | number
          }
        }
      }
      production_submissions: {
        payload: Prisma.$production_submissionsPayload<ExtArgs>
        fields: Prisma.production_submissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.production_submissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.production_submissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          findFirst: {
            args: Prisma.production_submissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.production_submissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          findMany: {
            args: Prisma.production_submissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>[]
          }
          create: {
            args: Prisma.production_submissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          createMany: {
            args: Prisma.production_submissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.production_submissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          update: {
            args: Prisma.production_submissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          deleteMany: {
            args: Prisma.production_submissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.production_submissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.production_submissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          aggregate: {
            args: Prisma.Production_submissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduction_submissions>
          }
          groupBy: {
            args: Prisma.production_submissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Production_submissionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.production_submissionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.production_submissionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.production_submissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Production_submissionsCountAggregateOutputType> | number
          }
        }
      }
      questions: {
        payload: Prisma.$questionsPayload<ExtArgs>
        fields: Prisma.questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findFirst: {
            args: Prisma.questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findMany: {
            args: Prisma.questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          create: {
            args: Prisma.questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          createMany: {
            args: Prisma.questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          update: {
            args: Prisma.questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          deleteMany: {
            args: Prisma.questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.questionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.questionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.questionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      ratings: {
        payload: Prisma.$ratingsPayload<ExtArgs>
        fields: Prisma.ratingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ratingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ratingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          findFirst: {
            args: Prisma.ratingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ratingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          findMany: {
            args: Prisma.ratingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>[]
          }
          create: {
            args: Prisma.ratingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          createMany: {
            args: Prisma.ratingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ratingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          update: {
            args: Prisma.ratingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          deleteMany: {
            args: Prisma.ratingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ratingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ratingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          aggregate: {
            args: Prisma.RatingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRatings>
          }
          groupBy: {
            args: Prisma.ratingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ratingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ratingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ratingsCountArgs<ExtArgs>
            result: $Utils.Optional<RatingsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.usersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.usersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    linkVisits: number
    ratings: number
    events: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linkVisits?: boolean | ProductsCountOutputTypeCountLinkVisitsArgs
    ratings?: boolean | ProductsCountOutputTypeCountRatingsArgs
    events?: boolean | ProductsCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountLinkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: link_visitsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventsWhereInput
  }


  /**
   * Count Type BrandsCountOutputType
   */

  export type BrandsCountOutputType = {
    products: number
    questions: number
  }

  export type BrandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | BrandsCountOutputTypeCountProductsArgs
    questions?: boolean | BrandsCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandsCountOutputType
     */
    select?: BrandsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type Question_classesCountOutputType
   */

  export type Question_classesCountOutputType = {
    questions: number
  }

  export type Question_classesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Question_classesCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * Question_classesCountOutputType without action
   */
  export type Question_classesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question_classesCountOutputType
     */
    select?: Question_classesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Question_classesCountOutputType without action
   */
  export type Question_classesCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type QuestionnairesCountOutputType
   */

  export type QuestionnairesCountOutputType = {
    questions: number
  }

  export type QuestionnairesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuestionnairesCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * QuestionnairesCountOutputType without action
   */
  export type QuestionnairesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnairesCountOutputType
     */
    select?: QuestionnairesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionnairesCountOutputType without action
   */
  export type QuestionnairesCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type QuestionsCountOutputType
   */

  export type QuestionsCountOutputType = {
    answers: number
  }

  export type QuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuestionsCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsCountOutputType
     */
    select?: QuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    productionSubmissions: number
    pushNotificationHistory: number
    ratings: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionSubmissions?: boolean | UsersCountOutputTypeCountProductionSubmissionsArgs
    pushNotificationHistory?: boolean | UsersCountOutputTypeCountPushNotificationHistoryArgs
    ratings?: boolean | UsersCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountProductionSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: production_submissionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPushNotificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: push_notification_historyWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model app_versions
   */

  export type AggregateApp_versions = {
    _count: App_versionsCountAggregateOutputType | null
    _min: App_versionsMinAggregateOutputType | null
    _max: App_versionsMaxAggregateOutputType | null
  }

  export type App_versionsMinAggregateOutputType = {
    id: string | null
    version: string | null
    critical: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type App_versionsMaxAggregateOutputType = {
    id: string | null
    version: string | null
    critical: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type App_versionsCountAggregateOutputType = {
    id: number
    version: number
    critical: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type App_versionsMinAggregateInputType = {
    id?: true
    version?: true
    critical?: true
    createdAt?: true
    updatedAt?: true
  }

  export type App_versionsMaxAggregateInputType = {
    id?: true
    version?: true
    critical?: true
    createdAt?: true
    updatedAt?: true
  }

  export type App_versionsCountAggregateInputType = {
    id?: true
    version?: true
    critical?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type App_versionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_versions to aggregate.
     */
    where?: app_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_versions to fetch.
     */
    orderBy?: app_versionsOrderByWithRelationInput | app_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_versions
    **/
    _count?: true | App_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_versionsMaxAggregateInputType
  }

  export type GetApp_versionsAggregateType<T extends App_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_versions[P]>
      : GetScalarType<T[P], AggregateApp_versions[P]>
  }




  export type app_versionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_versionsWhereInput
    orderBy?: app_versionsOrderByWithAggregationInput | app_versionsOrderByWithAggregationInput[]
    by: App_versionsScalarFieldEnum[] | App_versionsScalarFieldEnum
    having?: app_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_versionsCountAggregateInputType | true
    _min?: App_versionsMinAggregateInputType
    _max?: App_versionsMaxAggregateInputType
  }

  export type App_versionsGroupByOutputType = {
    id: string
    version: string
    critical: boolean
    createdAt: Date
    updatedAt: Date
    _count: App_versionsCountAggregateOutputType | null
    _min: App_versionsMinAggregateOutputType | null
    _max: App_versionsMaxAggregateOutputType | null
  }

  type GetApp_versionsGroupByPayload<T extends app_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], App_versionsGroupByOutputType[P]>
        }
      >
    >


  export type app_versionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    critical?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["app_versions"]>


  export type app_versionsSelectScalar = {
    id?: boolean
    version?: boolean
    critical?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $app_versionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_versions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      critical: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["app_versions"]>
    composites: {}
  }

  type app_versionsGetPayload<S extends boolean | null | undefined | app_versionsDefaultArgs> = $Result.GetResult<Prisma.$app_versionsPayload, S>

  type app_versionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_versionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_versionsCountAggregateInputType | true
    }

  export interface app_versionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_versions'], meta: { name: 'app_versions' } }
    /**
     * Find zero or one App_versions that matches the filter.
     * @param {app_versionsFindUniqueArgs} args - Arguments to find a App_versions
     * @example
     * // Get one App_versions
     * const app_versions = await prisma.app_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_versionsFindUniqueArgs>(args: SelectSubset<T, app_versionsFindUniqueArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_versions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_versionsFindUniqueOrThrowArgs} args - Arguments to find a App_versions
     * @example
     * // Get one App_versions
     * const app_versions = await prisma.app_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_versionsFindUniqueOrThrowArgs>(args: SelectSubset<T, app_versionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsFindFirstArgs} args - Arguments to find a App_versions
     * @example
     * // Get one App_versions
     * const app_versions = await prisma.app_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_versionsFindFirstArgs>(args?: SelectSubset<T, app_versionsFindFirstArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_versions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsFindFirstOrThrowArgs} args - Arguments to find a App_versions
     * @example
     * // Get one App_versions
     * const app_versions = await prisma.app_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_versionsFindFirstOrThrowArgs>(args?: SelectSubset<T, app_versionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_versions
     * const app_versions = await prisma.app_versions.findMany()
     * 
     * // Get first 10 App_versions
     * const app_versions = await prisma.app_versions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_versionsWithIdOnly = await prisma.app_versions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_versionsFindManyArgs>(args?: SelectSubset<T, app_versionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_versions.
     * @param {app_versionsCreateArgs} args - Arguments to create a App_versions.
     * @example
     * // Create one App_versions
     * const App_versions = await prisma.app_versions.create({
     *   data: {
     *     // ... data to create a App_versions
     *   }
     * })
     * 
     */
    create<T extends app_versionsCreateArgs>(args: SelectSubset<T, app_versionsCreateArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_versions.
     * @param {app_versionsCreateManyArgs} args - Arguments to create many App_versions.
     * @example
     * // Create many App_versions
     * const app_versions = await prisma.app_versions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_versionsCreateManyArgs>(args?: SelectSubset<T, app_versionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a App_versions.
     * @param {app_versionsDeleteArgs} args - Arguments to delete one App_versions.
     * @example
     * // Delete one App_versions
     * const App_versions = await prisma.app_versions.delete({
     *   where: {
     *     // ... filter to delete one App_versions
     *   }
     * })
     * 
     */
    delete<T extends app_versionsDeleteArgs>(args: SelectSubset<T, app_versionsDeleteArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_versions.
     * @param {app_versionsUpdateArgs} args - Arguments to update one App_versions.
     * @example
     * // Update one App_versions
     * const app_versions = await prisma.app_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_versionsUpdateArgs>(args: SelectSubset<T, app_versionsUpdateArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_versions.
     * @param {app_versionsDeleteManyArgs} args - Arguments to filter App_versions to delete.
     * @example
     * // Delete a few App_versions
     * const { count } = await prisma.app_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_versionsDeleteManyArgs>(args?: SelectSubset<T, app_versionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_versions
     * const app_versions = await prisma.app_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_versionsUpdateManyArgs>(args: SelectSubset<T, app_versionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_versions.
     * @param {app_versionsUpsertArgs} args - Arguments to update or create a App_versions.
     * @example
     * // Update or create a App_versions
     * const app_versions = await prisma.app_versions.upsert({
     *   create: {
     *     // ... data to create a App_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_versions we want to update
     *   }
     * })
     */
    upsert<T extends app_versionsUpsertArgs>(args: SelectSubset<T, app_versionsUpsertArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more App_versions that matches the filter.
     * @param {app_versionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const app_versions = await prisma.app_versions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: app_versionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a App_versions.
     * @param {app_versionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const app_versions = await prisma.app_versions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: app_versionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of App_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsCountArgs} args - Arguments to filter App_versions to count.
     * @example
     * // Count the number of App_versions
     * const count = await prisma.app_versions.count({
     *   where: {
     *     // ... the filter for the App_versions we want to count
     *   }
     * })
    **/
    count<T extends app_versionsCountArgs>(
      args?: Subset<T, app_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_versionsAggregateArgs>(args: Subset<T, App_versionsAggregateArgs>): Prisma.PrismaPromise<GetApp_versionsAggregateType<T>>

    /**
     * Group by App_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_versionsGroupByArgs['orderBy'] }
        : { orderBy?: app_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_versions model
   */
  readonly fields: app_versionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_versionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_versions model
   */ 
  interface app_versionsFieldRefs {
    readonly id: FieldRef<"app_versions", 'String'>
    readonly version: FieldRef<"app_versions", 'String'>
    readonly critical: FieldRef<"app_versions", 'Boolean'>
    readonly createdAt: FieldRef<"app_versions", 'DateTime'>
    readonly updatedAt: FieldRef<"app_versions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_versions findUnique
   */
  export type app_versionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where: app_versionsWhereUniqueInput
  }

  /**
   * app_versions findUniqueOrThrow
   */
  export type app_versionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where: app_versionsWhereUniqueInput
  }

  /**
   * app_versions findFirst
   */
  export type app_versionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where?: app_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_versions to fetch.
     */
    orderBy?: app_versionsOrderByWithRelationInput | app_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_versions.
     */
    cursor?: app_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_versions.
     */
    distinct?: App_versionsScalarFieldEnum | App_versionsScalarFieldEnum[]
  }

  /**
   * app_versions findFirstOrThrow
   */
  export type app_versionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where?: app_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_versions to fetch.
     */
    orderBy?: app_versionsOrderByWithRelationInput | app_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_versions.
     */
    cursor?: app_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_versions.
     */
    distinct?: App_versionsScalarFieldEnum | App_versionsScalarFieldEnum[]
  }

  /**
   * app_versions findMany
   */
  export type app_versionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where?: app_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_versions to fetch.
     */
    orderBy?: app_versionsOrderByWithRelationInput | app_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_versions.
     */
    cursor?: app_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_versions.
     */
    skip?: number
    distinct?: App_versionsScalarFieldEnum | App_versionsScalarFieldEnum[]
  }

  /**
   * app_versions create
   */
  export type app_versionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * The data needed to create a app_versions.
     */
    data: XOR<app_versionsCreateInput, app_versionsUncheckedCreateInput>
  }

  /**
   * app_versions createMany
   */
  export type app_versionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_versions.
     */
    data: app_versionsCreateManyInput | app_versionsCreateManyInput[]
  }

  /**
   * app_versions update
   */
  export type app_versionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * The data needed to update a app_versions.
     */
    data: XOR<app_versionsUpdateInput, app_versionsUncheckedUpdateInput>
    /**
     * Choose, which app_versions to update.
     */
    where: app_versionsWhereUniqueInput
  }

  /**
   * app_versions updateMany
   */
  export type app_versionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_versions.
     */
    data: XOR<app_versionsUpdateManyMutationInput, app_versionsUncheckedUpdateManyInput>
    /**
     * Filter which app_versions to update
     */
    where?: app_versionsWhereInput
  }

  /**
   * app_versions upsert
   */
  export type app_versionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * The filter to search for the app_versions to update in case it exists.
     */
    where: app_versionsWhereUniqueInput
    /**
     * In case the app_versions found by the `where` argument doesn't exist, create a new app_versions with this data.
     */
    create: XOR<app_versionsCreateInput, app_versionsUncheckedCreateInput>
    /**
     * In case the app_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_versionsUpdateInput, app_versionsUncheckedUpdateInput>
  }

  /**
   * app_versions delete
   */
  export type app_versionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter which app_versions to delete.
     */
    where: app_versionsWhereUniqueInput
  }

  /**
   * app_versions deleteMany
   */
  export type app_versionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_versions to delete
     */
    where?: app_versionsWhereInput
  }

  /**
   * app_versions findRaw
   */
  export type app_versionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * app_versions aggregateRaw
   */
  export type app_versionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * app_versions without action
   */
  export type app_versionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsMinAggregateOutputType = {
    id: string | null
    regularPrice: string | null
    deal: string | null
    dealPrice: string | null
    purchaseUrl: string | null
    brandId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uniqueDeal: boolean | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: string | null
    regularPrice: string | null
    deal: string | null
    dealPrice: string | null
    purchaseUrl: string | null
    brandId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uniqueDeal: boolean | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    description: number
    images: number
    regularPrice: number
    deal: number
    dealPrice: number
    purchaseUrl: number
    brandId: number
    name: number
    createdAt: number
    updatedAt: number
    uniqueDeal: number
    _all: number
  }


  export type ProductsMinAggregateInputType = {
    id?: true
    regularPrice?: true
    deal?: true
    dealPrice?: true
    purchaseUrl?: true
    brandId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    uniqueDeal?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    regularPrice?: true
    deal?: true
    dealPrice?: true
    purchaseUrl?: true
    brandId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    uniqueDeal?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    description?: true
    images?: true
    regularPrice?: true
    deal?: true
    dealPrice?: true
    purchaseUrl?: true
    brandId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    uniqueDeal?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: string
    description: JsonValue | null
    images: JsonValue[]
    regularPrice: string | null
    deal: string | null
    dealPrice: string | null
    purchaseUrl: string | null
    brandId: string
    name: string
    createdAt: Date
    updatedAt: Date
    uniqueDeal: boolean | null
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    images?: boolean
    regularPrice?: boolean
    deal?: boolean
    dealPrice?: boolean
    purchaseUrl?: boolean
    brandId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueDeal?: boolean
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    linkVisits?: boolean | products$linkVisitsArgs<ExtArgs>
    ratings?: boolean | products$ratingsArgs<ExtArgs>
    events?: boolean | products$eventsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>


  export type productsSelectScalar = {
    id?: boolean
    description?: boolean
    images?: boolean
    regularPrice?: boolean
    deal?: boolean
    dealPrice?: boolean
    purchaseUrl?: boolean
    brandId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueDeal?: boolean
  }

  export type productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    linkVisits?: boolean | products$linkVisitsArgs<ExtArgs>
    ratings?: boolean | products$ratingsArgs<ExtArgs>
    events?: boolean | products$eventsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {
      brand: Prisma.$brandsPayload<ExtArgs>
      linkVisits: Prisma.$link_visitsPayload<ExtArgs>[]
      ratings: Prisma.$ratingsPayload<ExtArgs>[]
      events: Prisma.$eventsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: Prisma.JsonValue | null
      images: Prisma.JsonValue[]
      regularPrice: string | null
      deal: string | null
      dealPrice: string | null
      purchaseUrl: string | null
      brandId: string
      name: string
      createdAt: Date
      updatedAt: Date
      uniqueDeal: boolean | null
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * @param {productsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const products = await prisma.products.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: productsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Products.
     * @param {productsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const products = await prisma.products.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: productsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    linkVisits<T extends products$linkVisitsArgs<ExtArgs> = {}>(args?: Subset<T, products$linkVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends products$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, products$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends products$eventsArgs<ExtArgs> = {}>(args?: Subset<T, products$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */ 
  interface productsFieldRefs {
    readonly id: FieldRef<"products", 'String'>
    readonly description: FieldRef<"products", 'Json'>
    readonly images: FieldRef<"products", 'Json[]'>
    readonly regularPrice: FieldRef<"products", 'String'>
    readonly deal: FieldRef<"products", 'String'>
    readonly dealPrice: FieldRef<"products", 'String'>
    readonly purchaseUrl: FieldRef<"products", 'String'>
    readonly brandId: FieldRef<"products", 'String'>
    readonly name: FieldRef<"products", 'String'>
    readonly createdAt: FieldRef<"products", 'DateTime'>
    readonly updatedAt: FieldRef<"products", 'DateTime'>
    readonly uniqueDeal: FieldRef<"products", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
  }

  /**
   * products findRaw
   */
  export type productsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * products aggregateRaw
   */
  export type productsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * products.linkVisits
   */
  export type products$linkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    where?: link_visitsWhereInput
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    cursor?: link_visitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * products.ratings
   */
  export type products$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    where?: ratingsWhereInput
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    cursor?: ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * products.events
   */
  export type products$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    where?: eventsWhereInput
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    cursor?: eventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
  }


  /**
   * Model push_notifications
   */

  export type AggregatePush_notifications = {
    _count: Push_notificationsCountAggregateOutputType | null
    _avg: Push_notificationsAvgAggregateOutputType | null
    _sum: Push_notificationsSumAggregateOutputType | null
    _min: Push_notificationsMinAggregateOutputType | null
    _max: Push_notificationsMaxAggregateOutputType | null
  }

  export type Push_notificationsAvgAggregateOutputType = {
    minDaysInactive: number | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
  }

  export type Push_notificationsSumAggregateOutputType = {
    minDaysInactive: number | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
  }

  export type Push_notificationsMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationType | null
    minDaysInactive: number | null
    oneTimeOnly: boolean | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
  }

  export type Push_notificationsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationType | null
    minDaysInactive: number | null
    oneTimeOnly: boolean | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
  }

  export type Push_notificationsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    minDaysInactive: number
    oneTimeOnly: number
    sendAfterInactiveDays: number
    repeatAfterDays: number
    daysAfterActivation: number
    daysBeforeExpiry: number
    _all: number
  }


  export type Push_notificationsAvgAggregateInputType = {
    minDaysInactive?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
  }

  export type Push_notificationsSumAggregateInputType = {
    minDaysInactive?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
  }

  export type Push_notificationsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    minDaysInactive?: true
    oneTimeOnly?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
  }

  export type Push_notificationsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    minDaysInactive?: true
    oneTimeOnly?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
  }

  export type Push_notificationsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    minDaysInactive?: true
    oneTimeOnly?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
    _all?: true
  }

  export type Push_notificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notifications to aggregate.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned push_notifications
    **/
    _count?: true | Push_notificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Push_notificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Push_notificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Push_notificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Push_notificationsMaxAggregateInputType
  }

  export type GetPush_notificationsAggregateType<T extends Push_notificationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePush_notifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePush_notifications[P]>
      : GetScalarType<T[P], AggregatePush_notifications[P]>
  }




  export type push_notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: push_notificationsWhereInput
    orderBy?: push_notificationsOrderByWithAggregationInput | push_notificationsOrderByWithAggregationInput[]
    by: Push_notificationsScalarFieldEnum[] | Push_notificationsScalarFieldEnum
    having?: push_notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Push_notificationsCountAggregateInputType | true
    _avg?: Push_notificationsAvgAggregateInputType
    _sum?: Push_notificationsSumAggregateInputType
    _min?: Push_notificationsMinAggregateInputType
    _max?: Push_notificationsMaxAggregateInputType
  }

  export type Push_notificationsGroupByOutputType = {
    id: string
    title: string | null
    content: string
    type: $Enums.NotificationType | null
    minDaysInactive: number | null
    oneTimeOnly: boolean | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
    _count: Push_notificationsCountAggregateOutputType | null
    _avg: Push_notificationsAvgAggregateOutputType | null
    _sum: Push_notificationsSumAggregateOutputType | null
    _min: Push_notificationsMinAggregateOutputType | null
    _max: Push_notificationsMaxAggregateOutputType | null
  }

  type GetPush_notificationsGroupByPayload<T extends push_notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Push_notificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Push_notificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Push_notificationsGroupByOutputType[P]>
            : GetScalarType<T[P], Push_notificationsGroupByOutputType[P]>
        }
      >
    >


  export type push_notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    minDaysInactive?: boolean
    oneTimeOnly?: boolean
    sendAfterInactiveDays?: boolean
    repeatAfterDays?: boolean
    daysAfterActivation?: boolean
    daysBeforeExpiry?: boolean
  }, ExtArgs["result"]["push_notifications"]>


  export type push_notificationsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    minDaysInactive?: boolean
    oneTimeOnly?: boolean
    sendAfterInactiveDays?: boolean
    repeatAfterDays?: boolean
    daysAfterActivation?: boolean
    daysBeforeExpiry?: boolean
  }


  export type $push_notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "push_notifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      content: string
      type: $Enums.NotificationType | null
      minDaysInactive: number | null
      oneTimeOnly: boolean | null
      sendAfterInactiveDays: number | null
      repeatAfterDays: number | null
      daysAfterActivation: number | null
      daysBeforeExpiry: number | null
    }, ExtArgs["result"]["push_notifications"]>
    composites: {}
  }

  type push_notificationsGetPayload<S extends boolean | null | undefined | push_notificationsDefaultArgs> = $Result.GetResult<Prisma.$push_notificationsPayload, S>

  type push_notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<push_notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Push_notificationsCountAggregateInputType | true
    }

  export interface push_notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['push_notifications'], meta: { name: 'push_notifications' } }
    /**
     * Find zero or one Push_notifications that matches the filter.
     * @param {push_notificationsFindUniqueArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends push_notificationsFindUniqueArgs>(args: SelectSubset<T, push_notificationsFindUniqueArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Push_notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {push_notificationsFindUniqueOrThrowArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends push_notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, push_notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Push_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindFirstArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends push_notificationsFindFirstArgs>(args?: SelectSubset<T, push_notificationsFindFirstArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Push_notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindFirstOrThrowArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends push_notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, push_notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Push_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Push_notifications
     * const push_notifications = await prisma.push_notifications.findMany()
     * 
     * // Get first 10 Push_notifications
     * const push_notifications = await prisma.push_notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const push_notificationsWithIdOnly = await prisma.push_notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends push_notificationsFindManyArgs>(args?: SelectSubset<T, push_notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Push_notifications.
     * @param {push_notificationsCreateArgs} args - Arguments to create a Push_notifications.
     * @example
     * // Create one Push_notifications
     * const Push_notifications = await prisma.push_notifications.create({
     *   data: {
     *     // ... data to create a Push_notifications
     *   }
     * })
     * 
     */
    create<T extends push_notificationsCreateArgs>(args: SelectSubset<T, push_notificationsCreateArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Push_notifications.
     * @param {push_notificationsCreateManyArgs} args - Arguments to create many Push_notifications.
     * @example
     * // Create many Push_notifications
     * const push_notifications = await prisma.push_notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends push_notificationsCreateManyArgs>(args?: SelectSubset<T, push_notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Push_notifications.
     * @param {push_notificationsDeleteArgs} args - Arguments to delete one Push_notifications.
     * @example
     * // Delete one Push_notifications
     * const Push_notifications = await prisma.push_notifications.delete({
     *   where: {
     *     // ... filter to delete one Push_notifications
     *   }
     * })
     * 
     */
    delete<T extends push_notificationsDeleteArgs>(args: SelectSubset<T, push_notificationsDeleteArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Push_notifications.
     * @param {push_notificationsUpdateArgs} args - Arguments to update one Push_notifications.
     * @example
     * // Update one Push_notifications
     * const push_notifications = await prisma.push_notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends push_notificationsUpdateArgs>(args: SelectSubset<T, push_notificationsUpdateArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Push_notifications.
     * @param {push_notificationsDeleteManyArgs} args - Arguments to filter Push_notifications to delete.
     * @example
     * // Delete a few Push_notifications
     * const { count } = await prisma.push_notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends push_notificationsDeleteManyArgs>(args?: SelectSubset<T, push_notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Push_notifications
     * const push_notifications = await prisma.push_notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends push_notificationsUpdateManyArgs>(args: SelectSubset<T, push_notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Push_notifications.
     * @param {push_notificationsUpsertArgs} args - Arguments to update or create a Push_notifications.
     * @example
     * // Update or create a Push_notifications
     * const push_notifications = await prisma.push_notifications.upsert({
     *   create: {
     *     // ... data to create a Push_notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Push_notifications we want to update
     *   }
     * })
     */
    upsert<T extends push_notificationsUpsertArgs>(args: SelectSubset<T, push_notificationsUpsertArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Push_notifications that matches the filter.
     * @param {push_notificationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const push_notifications = await prisma.push_notifications.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: push_notificationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Push_notifications.
     * @param {push_notificationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const push_notifications = await prisma.push_notifications.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: push_notificationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsCountArgs} args - Arguments to filter Push_notifications to count.
     * @example
     * // Count the number of Push_notifications
     * const count = await prisma.push_notifications.count({
     *   where: {
     *     // ... the filter for the Push_notifications we want to count
     *   }
     * })
    **/
    count<T extends push_notificationsCountArgs>(
      args?: Subset<T, push_notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Push_notificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Push_notificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Push_notificationsAggregateArgs>(args: Subset<T, Push_notificationsAggregateArgs>): Prisma.PrismaPromise<GetPush_notificationsAggregateType<T>>

    /**
     * Group by Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends push_notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: push_notificationsGroupByArgs['orderBy'] }
        : { orderBy?: push_notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, push_notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPush_notificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the push_notifications model
   */
  readonly fields: push_notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for push_notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__push_notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the push_notifications model
   */ 
  interface push_notificationsFieldRefs {
    readonly id: FieldRef<"push_notifications", 'String'>
    readonly title: FieldRef<"push_notifications", 'String'>
    readonly content: FieldRef<"push_notifications", 'String'>
    readonly type: FieldRef<"push_notifications", 'NotificationType'>
    readonly minDaysInactive: FieldRef<"push_notifications", 'Int'>
    readonly oneTimeOnly: FieldRef<"push_notifications", 'Boolean'>
    readonly sendAfterInactiveDays: FieldRef<"push_notifications", 'Int'>
    readonly repeatAfterDays: FieldRef<"push_notifications", 'Int'>
    readonly daysAfterActivation: FieldRef<"push_notifications", 'Int'>
    readonly daysBeforeExpiry: FieldRef<"push_notifications", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * push_notifications findUnique
   */
  export type push_notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where: push_notificationsWhereUniqueInput
  }

  /**
   * push_notifications findUniqueOrThrow
   */
  export type push_notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where: push_notificationsWhereUniqueInput
  }

  /**
   * push_notifications findFirst
   */
  export type push_notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notifications.
     */
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }

  /**
   * push_notifications findFirstOrThrow
   */
  export type push_notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notifications.
     */
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }

  /**
   * push_notifications findMany
   */
  export type push_notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }

  /**
   * push_notifications create
   */
  export type push_notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * The data needed to create a push_notifications.
     */
    data: XOR<push_notificationsCreateInput, push_notificationsUncheckedCreateInput>
  }

  /**
   * push_notifications createMany
   */
  export type push_notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many push_notifications.
     */
    data: push_notificationsCreateManyInput | push_notificationsCreateManyInput[]
  }

  /**
   * push_notifications update
   */
  export type push_notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * The data needed to update a push_notifications.
     */
    data: XOR<push_notificationsUpdateInput, push_notificationsUncheckedUpdateInput>
    /**
     * Choose, which push_notifications to update.
     */
    where: push_notificationsWhereUniqueInput
  }

  /**
   * push_notifications updateMany
   */
  export type push_notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update push_notifications.
     */
    data: XOR<push_notificationsUpdateManyMutationInput, push_notificationsUncheckedUpdateManyInput>
    /**
     * Filter which push_notifications to update
     */
    where?: push_notificationsWhereInput
  }

  /**
   * push_notifications upsert
   */
  export type push_notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * The filter to search for the push_notifications to update in case it exists.
     */
    where: push_notificationsWhereUniqueInput
    /**
     * In case the push_notifications found by the `where` argument doesn't exist, create a new push_notifications with this data.
     */
    create: XOR<push_notificationsCreateInput, push_notificationsUncheckedCreateInput>
    /**
     * In case the push_notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<push_notificationsUpdateInput, push_notificationsUncheckedUpdateInput>
  }

  /**
   * push_notifications delete
   */
  export type push_notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter which push_notifications to delete.
     */
    where: push_notificationsWhereUniqueInput
  }

  /**
   * push_notifications deleteMany
   */
  export type push_notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notifications to delete
     */
    where?: push_notificationsWhereInput
  }

  /**
   * push_notifications findRaw
   */
  export type push_notificationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * push_notifications aggregateRaw
   */
  export type push_notificationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * push_notifications without action
   */
  export type push_notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
  }


  /**
   * Model push_notification_history
   */

  export type AggregatePush_notification_history = {
    _count: Push_notification_historyCountAggregateOutputType | null
    _min: Push_notification_historyMinAggregateOutputType | null
    _max: Push_notification_historyMaxAggregateOutputType | null
  }

  export type Push_notification_historyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    entityId: string | null
    content: string | null
    title: string | null
    sentAt: Date | null
  }

  export type Push_notification_historyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    entityId: string | null
    content: string | null
    title: string | null
    sentAt: Date | null
  }

  export type Push_notification_historyCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    entityId: number
    content: number
    title: number
    sentAt: number
    _all: number
  }


  export type Push_notification_historyMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityId?: true
    content?: true
    title?: true
    sentAt?: true
  }

  export type Push_notification_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityId?: true
    content?: true
    title?: true
    sentAt?: true
  }

  export type Push_notification_historyCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityId?: true
    content?: true
    title?: true
    sentAt?: true
    _all?: true
  }

  export type Push_notification_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notification_history to aggregate.
     */
    where?: push_notification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notification_histories to fetch.
     */
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: push_notification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned push_notification_histories
    **/
    _count?: true | Push_notification_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Push_notification_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Push_notification_historyMaxAggregateInputType
  }

  export type GetPush_notification_historyAggregateType<T extends Push_notification_historyAggregateArgs> = {
        [P in keyof T & keyof AggregatePush_notification_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePush_notification_history[P]>
      : GetScalarType<T[P], AggregatePush_notification_history[P]>
  }




  export type push_notification_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: push_notification_historyWhereInput
    orderBy?: push_notification_historyOrderByWithAggregationInput | push_notification_historyOrderByWithAggregationInput[]
    by: Push_notification_historyScalarFieldEnum[] | Push_notification_historyScalarFieldEnum
    having?: push_notification_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Push_notification_historyCountAggregateInputType | true
    _min?: Push_notification_historyMinAggregateInputType
    _max?: Push_notification_historyMaxAggregateInputType
  }

  export type Push_notification_historyGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType | null
    entityId: string | null
    content: string
    title: string
    sentAt: Date
    _count: Push_notification_historyCountAggregateOutputType | null
    _min: Push_notification_historyMinAggregateOutputType | null
    _max: Push_notification_historyMaxAggregateOutputType | null
  }

  type GetPush_notification_historyGroupByPayload<T extends push_notification_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Push_notification_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Push_notification_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Push_notification_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Push_notification_historyGroupByOutputType[P]>
        }
      >
    >


  export type push_notification_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    entityId?: boolean
    content?: boolean
    title?: boolean
    sentAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["push_notification_history"]>


  export type push_notification_historySelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    entityId?: boolean
    content?: boolean
    title?: boolean
    sentAt?: boolean
  }

  export type push_notification_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $push_notification_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "push_notification_history"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType | null
      entityId: string | null
      content: string
      title: string
      sentAt: Date
    }, ExtArgs["result"]["push_notification_history"]>
    composites: {}
  }

  type push_notification_historyGetPayload<S extends boolean | null | undefined | push_notification_historyDefaultArgs> = $Result.GetResult<Prisma.$push_notification_historyPayload, S>

  type push_notification_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<push_notification_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Push_notification_historyCountAggregateInputType | true
    }

  export interface push_notification_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['push_notification_history'], meta: { name: 'push_notification_history' } }
    /**
     * Find zero or one Push_notification_history that matches the filter.
     * @param {push_notification_historyFindUniqueArgs} args - Arguments to find a Push_notification_history
     * @example
     * // Get one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends push_notification_historyFindUniqueArgs>(args: SelectSubset<T, push_notification_historyFindUniqueArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Push_notification_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {push_notification_historyFindUniqueOrThrowArgs} args - Arguments to find a Push_notification_history
     * @example
     * // Get one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends push_notification_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, push_notification_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Push_notification_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyFindFirstArgs} args - Arguments to find a Push_notification_history
     * @example
     * // Get one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends push_notification_historyFindFirstArgs>(args?: SelectSubset<T, push_notification_historyFindFirstArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Push_notification_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyFindFirstOrThrowArgs} args - Arguments to find a Push_notification_history
     * @example
     * // Get one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends push_notification_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, push_notification_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Push_notification_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Push_notification_histories
     * const push_notification_histories = await prisma.push_notification_history.findMany()
     * 
     * // Get first 10 Push_notification_histories
     * const push_notification_histories = await prisma.push_notification_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const push_notification_historyWithIdOnly = await prisma.push_notification_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends push_notification_historyFindManyArgs>(args?: SelectSubset<T, push_notification_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Push_notification_history.
     * @param {push_notification_historyCreateArgs} args - Arguments to create a Push_notification_history.
     * @example
     * // Create one Push_notification_history
     * const Push_notification_history = await prisma.push_notification_history.create({
     *   data: {
     *     // ... data to create a Push_notification_history
     *   }
     * })
     * 
     */
    create<T extends push_notification_historyCreateArgs>(args: SelectSubset<T, push_notification_historyCreateArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Push_notification_histories.
     * @param {push_notification_historyCreateManyArgs} args - Arguments to create many Push_notification_histories.
     * @example
     * // Create many Push_notification_histories
     * const push_notification_history = await prisma.push_notification_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends push_notification_historyCreateManyArgs>(args?: SelectSubset<T, push_notification_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Push_notification_history.
     * @param {push_notification_historyDeleteArgs} args - Arguments to delete one Push_notification_history.
     * @example
     * // Delete one Push_notification_history
     * const Push_notification_history = await prisma.push_notification_history.delete({
     *   where: {
     *     // ... filter to delete one Push_notification_history
     *   }
     * })
     * 
     */
    delete<T extends push_notification_historyDeleteArgs>(args: SelectSubset<T, push_notification_historyDeleteArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Push_notification_history.
     * @param {push_notification_historyUpdateArgs} args - Arguments to update one Push_notification_history.
     * @example
     * // Update one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends push_notification_historyUpdateArgs>(args: SelectSubset<T, push_notification_historyUpdateArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Push_notification_histories.
     * @param {push_notification_historyDeleteManyArgs} args - Arguments to filter Push_notification_histories to delete.
     * @example
     * // Delete a few Push_notification_histories
     * const { count } = await prisma.push_notification_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends push_notification_historyDeleteManyArgs>(args?: SelectSubset<T, push_notification_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Push_notification_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Push_notification_histories
     * const push_notification_history = await prisma.push_notification_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends push_notification_historyUpdateManyArgs>(args: SelectSubset<T, push_notification_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Push_notification_history.
     * @param {push_notification_historyUpsertArgs} args - Arguments to update or create a Push_notification_history.
     * @example
     * // Update or create a Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.upsert({
     *   create: {
     *     // ... data to create a Push_notification_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Push_notification_history we want to update
     *   }
     * })
     */
    upsert<T extends push_notification_historyUpsertArgs>(args: SelectSubset<T, push_notification_historyUpsertArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Push_notification_histories that matches the filter.
     * @param {push_notification_historyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const push_notification_history = await prisma.push_notification_history.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: push_notification_historyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Push_notification_history.
     * @param {push_notification_historyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const push_notification_history = await prisma.push_notification_history.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: push_notification_historyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Push_notification_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyCountArgs} args - Arguments to filter Push_notification_histories to count.
     * @example
     * // Count the number of Push_notification_histories
     * const count = await prisma.push_notification_history.count({
     *   where: {
     *     // ... the filter for the Push_notification_histories we want to count
     *   }
     * })
    **/
    count<T extends push_notification_historyCountArgs>(
      args?: Subset<T, push_notification_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Push_notification_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Push_notification_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Push_notification_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Push_notification_historyAggregateArgs>(args: Subset<T, Push_notification_historyAggregateArgs>): Prisma.PrismaPromise<GetPush_notification_historyAggregateType<T>>

    /**
     * Group by Push_notification_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends push_notification_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: push_notification_historyGroupByArgs['orderBy'] }
        : { orderBy?: push_notification_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, push_notification_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPush_notification_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the push_notification_history model
   */
  readonly fields: push_notification_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for push_notification_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__push_notification_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the push_notification_history model
   */ 
  interface push_notification_historyFieldRefs {
    readonly id: FieldRef<"push_notification_history", 'String'>
    readonly userId: FieldRef<"push_notification_history", 'String'>
    readonly type: FieldRef<"push_notification_history", 'NotificationType'>
    readonly entityId: FieldRef<"push_notification_history", 'String'>
    readonly content: FieldRef<"push_notification_history", 'String'>
    readonly title: FieldRef<"push_notification_history", 'String'>
    readonly sentAt: FieldRef<"push_notification_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * push_notification_history findUnique
   */
  export type push_notification_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_history to fetch.
     */
    where: push_notification_historyWhereUniqueInput
  }

  /**
   * push_notification_history findUniqueOrThrow
   */
  export type push_notification_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_history to fetch.
     */
    where: push_notification_historyWhereUniqueInput
  }

  /**
   * push_notification_history findFirst
   */
  export type push_notification_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_history to fetch.
     */
    where?: push_notification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notification_histories to fetch.
     */
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notification_histories.
     */
    cursor?: push_notification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notification_histories.
     */
    distinct?: Push_notification_historyScalarFieldEnum | Push_notification_historyScalarFieldEnum[]
  }

  /**
   * push_notification_history findFirstOrThrow
   */
  export type push_notification_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_history to fetch.
     */
    where?: push_notification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notification_histories to fetch.
     */
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notification_histories.
     */
    cursor?: push_notification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notification_histories.
     */
    distinct?: Push_notification_historyScalarFieldEnum | Push_notification_historyScalarFieldEnum[]
  }

  /**
   * push_notification_history findMany
   */
  export type push_notification_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_histories to fetch.
     */
    where?: push_notification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notification_histories to fetch.
     */
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing push_notification_histories.
     */
    cursor?: push_notification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notification_histories.
     */
    skip?: number
    distinct?: Push_notification_historyScalarFieldEnum | Push_notification_historyScalarFieldEnum[]
  }

  /**
   * push_notification_history create
   */
  export type push_notification_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a push_notification_history.
     */
    data: XOR<push_notification_historyCreateInput, push_notification_historyUncheckedCreateInput>
  }

  /**
   * push_notification_history createMany
   */
  export type push_notification_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many push_notification_histories.
     */
    data: push_notification_historyCreateManyInput | push_notification_historyCreateManyInput[]
  }

  /**
   * push_notification_history update
   */
  export type push_notification_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a push_notification_history.
     */
    data: XOR<push_notification_historyUpdateInput, push_notification_historyUncheckedUpdateInput>
    /**
     * Choose, which push_notification_history to update.
     */
    where: push_notification_historyWhereUniqueInput
  }

  /**
   * push_notification_history updateMany
   */
  export type push_notification_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update push_notification_histories.
     */
    data: XOR<push_notification_historyUpdateManyMutationInput, push_notification_historyUncheckedUpdateManyInput>
    /**
     * Filter which push_notification_histories to update
     */
    where?: push_notification_historyWhereInput
  }

  /**
   * push_notification_history upsert
   */
  export type push_notification_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the push_notification_history to update in case it exists.
     */
    where: push_notification_historyWhereUniqueInput
    /**
     * In case the push_notification_history found by the `where` argument doesn't exist, create a new push_notification_history with this data.
     */
    create: XOR<push_notification_historyCreateInput, push_notification_historyUncheckedCreateInput>
    /**
     * In case the push_notification_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<push_notification_historyUpdateInput, push_notification_historyUncheckedUpdateInput>
  }

  /**
   * push_notification_history delete
   */
  export type push_notification_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter which push_notification_history to delete.
     */
    where: push_notification_historyWhereUniqueInput
  }

  /**
   * push_notification_history deleteMany
   */
  export type push_notification_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notification_histories to delete
     */
    where?: push_notification_historyWhereInput
  }

  /**
   * push_notification_history findRaw
   */
  export type push_notification_historyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * push_notification_history aggregateRaw
   */
  export type push_notification_historyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * push_notification_history without action
   */
  export type push_notification_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
  }


  /**
   * Model brands
   */

  export type AggregateBrands = {
    _count: BrandsCountAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  export type BrandsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to aggregate.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brands
    **/
    _count?: true | BrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandsMaxAggregateInputType
  }

  export type GetBrandsAggregateType<T extends BrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrands[P]>
      : GetScalarType<T[P], AggregateBrands[P]>
  }




  export type brandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithAggregationInput | brandsOrderByWithAggregationInput[]
    by: BrandsScalarFieldEnum[] | BrandsScalarFieldEnum
    having?: brandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandsCountAggregateInputType | true
    _min?: BrandsMinAggregateInputType
    _max?: BrandsMaxAggregateInputType
  }

  export type BrandsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BrandsCountAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  type GetBrandsGroupByPayload<T extends brandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandsGroupByOutputType[P]>
            : GetScalarType<T[P], BrandsGroupByOutputType[P]>
        }
      >
    >


  export type brandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | brands$productsArgs<ExtArgs>
    questions?: boolean | brands$questionsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>


  export type brandsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type brandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | brands$productsArgs<ExtArgs>
    questions?: boolean | brands$questionsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $brandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brands"
    objects: {
      products: Prisma.$productsPayload<ExtArgs>[]
      questions: Prisma.$questionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brands"]>
    composites: {}
  }

  type brandsGetPayload<S extends boolean | null | undefined | brandsDefaultArgs> = $Result.GetResult<Prisma.$brandsPayload, S>

  type brandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<brandsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandsCountAggregateInputType | true
    }

  export interface brandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brands'], meta: { name: 'brands' } }
    /**
     * Find zero or one Brands that matches the filter.
     * @param {brandsFindUniqueArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends brandsFindUniqueArgs>(args: SelectSubset<T, brandsFindUniqueArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Brands that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {brandsFindUniqueOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends brandsFindUniqueOrThrowArgs>(args: SelectSubset<T, brandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends brandsFindFirstArgs>(args?: SelectSubset<T, brandsFindFirstArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends brandsFindFirstOrThrowArgs>(args?: SelectSubset<T, brandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brands.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandsWithIdOnly = await prisma.brands.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends brandsFindManyArgs>(args?: SelectSubset<T, brandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Brands.
     * @param {brandsCreateArgs} args - Arguments to create a Brands.
     * @example
     * // Create one Brands
     * const Brands = await prisma.brands.create({
     *   data: {
     *     // ... data to create a Brands
     *   }
     * })
     * 
     */
    create<T extends brandsCreateArgs>(args: SelectSubset<T, brandsCreateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Brands.
     * @param {brandsCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends brandsCreateManyArgs>(args?: SelectSubset<T, brandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brands.
     * @param {brandsDeleteArgs} args - Arguments to delete one Brands.
     * @example
     * // Delete one Brands
     * const Brands = await prisma.brands.delete({
     *   where: {
     *     // ... filter to delete one Brands
     *   }
     * })
     * 
     */
    delete<T extends brandsDeleteArgs>(args: SelectSubset<T, brandsDeleteArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Brands.
     * @param {brandsUpdateArgs} args - Arguments to update one Brands.
     * @example
     * // Update one Brands
     * const brands = await prisma.brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends brandsUpdateArgs>(args: SelectSubset<T, brandsUpdateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {brandsDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends brandsDeleteManyArgs>(args?: SelectSubset<T, brandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends brandsUpdateManyArgs>(args: SelectSubset<T, brandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brands.
     * @param {brandsUpsertArgs} args - Arguments to update or create a Brands.
     * @example
     * // Update or create a Brands
     * const brands = await prisma.brands.upsert({
     *   create: {
     *     // ... data to create a Brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brands we want to update
     *   }
     * })
     */
    upsert<T extends brandsUpsertArgs>(args: SelectSubset<T, brandsUpsertArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * @param {brandsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const brands = await prisma.brands.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: brandsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Brands.
     * @param {brandsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const brands = await prisma.brands.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: brandsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brands.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends brandsCountArgs>(
      args?: Subset<T, brandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandsAggregateArgs>(args: Subset<T, BrandsAggregateArgs>): Prisma.PrismaPromise<GetBrandsAggregateType<T>>

    /**
     * Group by Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brandsGroupByArgs['orderBy'] }
        : { orderBy?: brandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brands model
   */
  readonly fields: brandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends brands$productsArgs<ExtArgs> = {}>(args?: Subset<T, brands$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany"> | Null>
    questions<T extends brands$questionsArgs<ExtArgs> = {}>(args?: Subset<T, brands$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the brands model
   */ 
  interface brandsFieldRefs {
    readonly id: FieldRef<"brands", 'String'>
    readonly name: FieldRef<"brands", 'String'>
    readonly createdAt: FieldRef<"brands", 'DateTime'>
    readonly updatedAt: FieldRef<"brands", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * brands findUnique
   */
  export type brandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findUniqueOrThrow
   */
  export type brandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findFirst
   */
  export type brandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findFirstOrThrow
   */
  export type brandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findMany
   */
  export type brandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands create
   */
  export type brandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to create a brands.
     */
    data: XOR<brandsCreateInput, brandsUncheckedCreateInput>
  }

  /**
   * brands createMany
   */
  export type brandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brands.
     */
    data: brandsCreateManyInput | brandsCreateManyInput[]
  }

  /**
   * brands update
   */
  export type brandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to update a brands.
     */
    data: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
    /**
     * Choose, which brands to update.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands updateMany
   */
  export type brandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brands.
     */
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandsWhereInput
  }

  /**
   * brands upsert
   */
  export type brandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The filter to search for the brands to update in case it exists.
     */
    where: brandsWhereUniqueInput
    /**
     * In case the brands found by the `where` argument doesn't exist, create a new brands with this data.
     */
    create: XOR<brandsCreateInput, brandsUncheckedCreateInput>
    /**
     * In case the brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
  }

  /**
   * brands delete
   */
  export type brandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter which brands to delete.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands deleteMany
   */
  export type brandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to delete
     */
    where?: brandsWhereInput
  }

  /**
   * brands findRaw
   */
  export type brandsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * brands aggregateRaw
   */
  export type brandsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * brands.products
   */
  export type brands$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * brands.questions
   */
  export type brands$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * brands without action
   */
  export type brandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
  }


  /**
   * Model link_visits
   */

  export type AggregateLink_visits = {
    _count: Link_visitsCountAggregateOutputType | null
    _min: Link_visitsMinAggregateOutputType | null
    _max: Link_visitsMaxAggregateOutputType | null
  }

  export type Link_visitsMinAggregateOutputType = {
    id: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type Link_visitsMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type Link_visitsCountAggregateOutputType = {
    id: number
    productId: number
    createdAt: number
    _all: number
  }


  export type Link_visitsMinAggregateInputType = {
    id?: true
    productId?: true
    createdAt?: true
  }

  export type Link_visitsMaxAggregateInputType = {
    id?: true
    productId?: true
    createdAt?: true
  }

  export type Link_visitsCountAggregateInputType = {
    id?: true
    productId?: true
    createdAt?: true
    _all?: true
  }

  export type Link_visitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which link_visits to aggregate.
     */
    where?: link_visitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of link_visits to fetch.
     */
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: link_visitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` link_visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` link_visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned link_visits
    **/
    _count?: true | Link_visitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Link_visitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Link_visitsMaxAggregateInputType
  }

  export type GetLink_visitsAggregateType<T extends Link_visitsAggregateArgs> = {
        [P in keyof T & keyof AggregateLink_visits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLink_visits[P]>
      : GetScalarType<T[P], AggregateLink_visits[P]>
  }




  export type link_visitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: link_visitsWhereInput
    orderBy?: link_visitsOrderByWithAggregationInput | link_visitsOrderByWithAggregationInput[]
    by: Link_visitsScalarFieldEnum[] | Link_visitsScalarFieldEnum
    having?: link_visitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Link_visitsCountAggregateInputType | true
    _min?: Link_visitsMinAggregateInputType
    _max?: Link_visitsMaxAggregateInputType
  }

  export type Link_visitsGroupByOutputType = {
    id: string
    productId: string
    createdAt: Date
    _count: Link_visitsCountAggregateOutputType | null
    _min: Link_visitsMinAggregateOutputType | null
    _max: Link_visitsMaxAggregateOutputType | null
  }

  type GetLink_visitsGroupByPayload<T extends link_visitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Link_visitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Link_visitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Link_visitsGroupByOutputType[P]>
            : GetScalarType<T[P], Link_visitsGroupByOutputType[P]>
        }
      >
    >


  export type link_visitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    createdAt?: boolean
    product?: boolean | productsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["link_visits"]>


  export type link_visitsSelectScalar = {
    id?: boolean
    productId?: boolean
    createdAt?: boolean
  }

  export type link_visitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productsDefaultArgs<ExtArgs>
  }

  export type $link_visitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "link_visits"
    objects: {
      product: Prisma.$productsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      createdAt: Date
    }, ExtArgs["result"]["link_visits"]>
    composites: {}
  }

  type link_visitsGetPayload<S extends boolean | null | undefined | link_visitsDefaultArgs> = $Result.GetResult<Prisma.$link_visitsPayload, S>

  type link_visitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<link_visitsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Link_visitsCountAggregateInputType | true
    }

  export interface link_visitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['link_visits'], meta: { name: 'link_visits' } }
    /**
     * Find zero or one Link_visits that matches the filter.
     * @param {link_visitsFindUniqueArgs} args - Arguments to find a Link_visits
     * @example
     * // Get one Link_visits
     * const link_visits = await prisma.link_visits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends link_visitsFindUniqueArgs>(args: SelectSubset<T, link_visitsFindUniqueArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Link_visits that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {link_visitsFindUniqueOrThrowArgs} args - Arguments to find a Link_visits
     * @example
     * // Get one Link_visits
     * const link_visits = await prisma.link_visits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends link_visitsFindUniqueOrThrowArgs>(args: SelectSubset<T, link_visitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Link_visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsFindFirstArgs} args - Arguments to find a Link_visits
     * @example
     * // Get one Link_visits
     * const link_visits = await prisma.link_visits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends link_visitsFindFirstArgs>(args?: SelectSubset<T, link_visitsFindFirstArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Link_visits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsFindFirstOrThrowArgs} args - Arguments to find a Link_visits
     * @example
     * // Get one Link_visits
     * const link_visits = await prisma.link_visits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends link_visitsFindFirstOrThrowArgs>(args?: SelectSubset<T, link_visitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Link_visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Link_visits
     * const link_visits = await prisma.link_visits.findMany()
     * 
     * // Get first 10 Link_visits
     * const link_visits = await prisma.link_visits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const link_visitsWithIdOnly = await prisma.link_visits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends link_visitsFindManyArgs>(args?: SelectSubset<T, link_visitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Link_visits.
     * @param {link_visitsCreateArgs} args - Arguments to create a Link_visits.
     * @example
     * // Create one Link_visits
     * const Link_visits = await prisma.link_visits.create({
     *   data: {
     *     // ... data to create a Link_visits
     *   }
     * })
     * 
     */
    create<T extends link_visitsCreateArgs>(args: SelectSubset<T, link_visitsCreateArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Link_visits.
     * @param {link_visitsCreateManyArgs} args - Arguments to create many Link_visits.
     * @example
     * // Create many Link_visits
     * const link_visits = await prisma.link_visits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends link_visitsCreateManyArgs>(args?: SelectSubset<T, link_visitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Link_visits.
     * @param {link_visitsDeleteArgs} args - Arguments to delete one Link_visits.
     * @example
     * // Delete one Link_visits
     * const Link_visits = await prisma.link_visits.delete({
     *   where: {
     *     // ... filter to delete one Link_visits
     *   }
     * })
     * 
     */
    delete<T extends link_visitsDeleteArgs>(args: SelectSubset<T, link_visitsDeleteArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Link_visits.
     * @param {link_visitsUpdateArgs} args - Arguments to update one Link_visits.
     * @example
     * // Update one Link_visits
     * const link_visits = await prisma.link_visits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends link_visitsUpdateArgs>(args: SelectSubset<T, link_visitsUpdateArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Link_visits.
     * @param {link_visitsDeleteManyArgs} args - Arguments to filter Link_visits to delete.
     * @example
     * // Delete a few Link_visits
     * const { count } = await prisma.link_visits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends link_visitsDeleteManyArgs>(args?: SelectSubset<T, link_visitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Link_visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Link_visits
     * const link_visits = await prisma.link_visits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends link_visitsUpdateManyArgs>(args: SelectSubset<T, link_visitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Link_visits.
     * @param {link_visitsUpsertArgs} args - Arguments to update or create a Link_visits.
     * @example
     * // Update or create a Link_visits
     * const link_visits = await prisma.link_visits.upsert({
     *   create: {
     *     // ... data to create a Link_visits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Link_visits we want to update
     *   }
     * })
     */
    upsert<T extends link_visitsUpsertArgs>(args: SelectSubset<T, link_visitsUpsertArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Link_visits that matches the filter.
     * @param {link_visitsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const link_visits = await prisma.link_visits.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: link_visitsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Link_visits.
     * @param {link_visitsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const link_visits = await prisma.link_visits.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: link_visitsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Link_visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsCountArgs} args - Arguments to filter Link_visits to count.
     * @example
     * // Count the number of Link_visits
     * const count = await prisma.link_visits.count({
     *   where: {
     *     // ... the filter for the Link_visits we want to count
     *   }
     * })
    **/
    count<T extends link_visitsCountArgs>(
      args?: Subset<T, link_visitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Link_visitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Link_visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Link_visitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Link_visitsAggregateArgs>(args: Subset<T, Link_visitsAggregateArgs>): Prisma.PrismaPromise<GetLink_visitsAggregateType<T>>

    /**
     * Group by Link_visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends link_visitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: link_visitsGroupByArgs['orderBy'] }
        : { orderBy?: link_visitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, link_visitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLink_visitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the link_visits model
   */
  readonly fields: link_visitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for link_visits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__link_visitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productsDefaultArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the link_visits model
   */ 
  interface link_visitsFieldRefs {
    readonly id: FieldRef<"link_visits", 'String'>
    readonly productId: FieldRef<"link_visits", 'String'>
    readonly createdAt: FieldRef<"link_visits", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * link_visits findUnique
   */
  export type link_visitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where: link_visitsWhereUniqueInput
  }

  /**
   * link_visits findUniqueOrThrow
   */
  export type link_visitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where: link_visitsWhereUniqueInput
  }

  /**
   * link_visits findFirst
   */
  export type link_visitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where?: link_visitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of link_visits to fetch.
     */
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for link_visits.
     */
    cursor?: link_visitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` link_visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` link_visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of link_visits.
     */
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * link_visits findFirstOrThrow
   */
  export type link_visitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where?: link_visitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of link_visits to fetch.
     */
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for link_visits.
     */
    cursor?: link_visitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` link_visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` link_visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of link_visits.
     */
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * link_visits findMany
   */
  export type link_visitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where?: link_visitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of link_visits to fetch.
     */
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing link_visits.
     */
    cursor?: link_visitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` link_visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` link_visits.
     */
    skip?: number
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * link_visits create
   */
  export type link_visitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * The data needed to create a link_visits.
     */
    data: XOR<link_visitsCreateInput, link_visitsUncheckedCreateInput>
  }

  /**
   * link_visits createMany
   */
  export type link_visitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many link_visits.
     */
    data: link_visitsCreateManyInput | link_visitsCreateManyInput[]
  }

  /**
   * link_visits update
   */
  export type link_visitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * The data needed to update a link_visits.
     */
    data: XOR<link_visitsUpdateInput, link_visitsUncheckedUpdateInput>
    /**
     * Choose, which link_visits to update.
     */
    where: link_visitsWhereUniqueInput
  }

  /**
   * link_visits updateMany
   */
  export type link_visitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update link_visits.
     */
    data: XOR<link_visitsUpdateManyMutationInput, link_visitsUncheckedUpdateManyInput>
    /**
     * Filter which link_visits to update
     */
    where?: link_visitsWhereInput
  }

  /**
   * link_visits upsert
   */
  export type link_visitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * The filter to search for the link_visits to update in case it exists.
     */
    where: link_visitsWhereUniqueInput
    /**
     * In case the link_visits found by the `where` argument doesn't exist, create a new link_visits with this data.
     */
    create: XOR<link_visitsCreateInput, link_visitsUncheckedCreateInput>
    /**
     * In case the link_visits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<link_visitsUpdateInput, link_visitsUncheckedUpdateInput>
  }

  /**
   * link_visits delete
   */
  export type link_visitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter which link_visits to delete.
     */
    where: link_visitsWhereUniqueInput
  }

  /**
   * link_visits deleteMany
   */
  export type link_visitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which link_visits to delete
     */
    where?: link_visitsWhereInput
  }

  /**
   * link_visits findRaw
   */
  export type link_visitsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * link_visits aggregateRaw
   */
  export type link_visitsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * link_visits without action
   */
  export type link_visitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
  }


  /**
   * Model events
   */

  export type AggregateEvents = {
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  export type EventsMinAggregateOutputType = {
    id: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventsMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventsCountAggregateOutputType = {
    id: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventsMinAggregateInputType = {
    id?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventsMaxAggregateInputType = {
    id?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventsCountAggregateInputType = {
    id?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to aggregate.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events
    **/
    _count?: true | EventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventsMaxAggregateInputType
  }

  export type GetEventsAggregateType<T extends EventsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents[P]>
      : GetScalarType<T[P], AggregateEvents[P]>
  }




  export type eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventsWhereInput
    orderBy?: eventsOrderByWithAggregationInput | eventsOrderByWithAggregationInput[]
    by: EventsScalarFieldEnum[] | EventsScalarFieldEnum
    having?: eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventsCountAggregateInputType | true
    _min?: EventsMinAggregateInputType
    _max?: EventsMaxAggregateInputType
  }

  export type EventsGroupByOutputType = {
    id: string
    productId: string
    createdAt: Date
    updatedAt: Date
    _count: EventsCountAggregateOutputType | null
    _min: EventsMinAggregateOutputType | null
    _max: EventsMaxAggregateOutputType | null
  }

  type GetEventsGroupByPayload<T extends eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventsGroupByOutputType[P]>
            : GetScalarType<T[P], EventsGroupByOutputType[P]>
        }
      >
    >


  export type eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | productsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events"]>


  export type eventsSelectScalar = {
    id?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type eventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productsDefaultArgs<ExtArgs>
  }

  export type $eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "events"
    objects: {
      product: Prisma.$productsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["events"]>
    composites: {}
  }

  type eventsGetPayload<S extends boolean | null | undefined | eventsDefaultArgs> = $Result.GetResult<Prisma.$eventsPayload, S>

  type eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventsCountAggregateInputType | true
    }

  export interface eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['events'], meta: { name: 'events' } }
    /**
     * Find zero or one Events that matches the filter.
     * @param {eventsFindUniqueArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventsFindUniqueArgs>(args: SelectSubset<T, eventsFindUniqueArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Events that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {eventsFindUniqueOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventsFindUniqueOrThrowArgs>(args: SelectSubset<T, eventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventsFindFirstArgs>(args?: SelectSubset<T, eventsFindFirstArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindFirstOrThrowArgs} args - Arguments to find a Events
     * @example
     * // Get one Events
     * const events = await prisma.events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventsFindFirstOrThrowArgs>(args?: SelectSubset<T, eventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.events.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventsWithIdOnly = await prisma.events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends eventsFindManyArgs>(args?: SelectSubset<T, eventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Events.
     * @param {eventsCreateArgs} args - Arguments to create a Events.
     * @example
     * // Create one Events
     * const Events = await prisma.events.create({
     *   data: {
     *     // ... data to create a Events
     *   }
     * })
     * 
     */
    create<T extends eventsCreateArgs>(args: SelectSubset<T, eventsCreateArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {eventsCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const events = await prisma.events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventsCreateManyArgs>(args?: SelectSubset<T, eventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Events.
     * @param {eventsDeleteArgs} args - Arguments to delete one Events.
     * @example
     * // Delete one Events
     * const Events = await prisma.events.delete({
     *   where: {
     *     // ... filter to delete one Events
     *   }
     * })
     * 
     */
    delete<T extends eventsDeleteArgs>(args: SelectSubset<T, eventsDeleteArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Events.
     * @param {eventsUpdateArgs} args - Arguments to update one Events.
     * @example
     * // Update one Events
     * const events = await prisma.events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventsUpdateArgs>(args: SelectSubset<T, eventsUpdateArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {eventsDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventsDeleteManyArgs>(args?: SelectSubset<T, eventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const events = await prisma.events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventsUpdateManyArgs>(args: SelectSubset<T, eventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events.
     * @param {eventsUpsertArgs} args - Arguments to update or create a Events.
     * @example
     * // Update or create a Events
     * const events = await prisma.events.upsert({
     *   create: {
     *     // ... data to create a Events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events we want to update
     *   }
     * })
     */
    upsert<T extends eventsUpsertArgs>(args: SelectSubset<T, eventsUpsertArgs<ExtArgs>>): Prisma__eventsClient<$Result.GetResult<Prisma.$eventsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * @param {eventsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const events = await prisma.events.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: eventsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Events.
     * @param {eventsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const events = await prisma.events.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: eventsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.events.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends eventsCountArgs>(
      args?: Subset<T, eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventsAggregateArgs>(args: Subset<T, EventsAggregateArgs>): Prisma.PrismaPromise<GetEventsAggregateType<T>>

    /**
     * Group by Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventsGroupByArgs['orderBy'] }
        : { orderBy?: eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the events model
   */
  readonly fields: eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productsDefaultArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the events model
   */ 
  interface eventsFieldRefs {
    readonly id: FieldRef<"events", 'String'>
    readonly productId: FieldRef<"events", 'String'>
    readonly createdAt: FieldRef<"events", 'DateTime'>
    readonly updatedAt: FieldRef<"events", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * events findUnique
   */
  export type eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events findUniqueOrThrow
   */
  export type eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events findFirst
   */
  export type eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * events findFirstOrThrow
   */
  export type eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events.
     */
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * events findMany
   */
  export type eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter, which events to fetch.
     */
    where?: eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events to fetch.
     */
    orderBy?: eventsOrderByWithRelationInput | eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events.
     */
    cursor?: eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events.
     */
    skip?: number
    distinct?: EventsScalarFieldEnum | EventsScalarFieldEnum[]
  }

  /**
   * events create
   */
  export type eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * The data needed to create a events.
     */
    data: XOR<eventsCreateInput, eventsUncheckedCreateInput>
  }

  /**
   * events createMany
   */
  export type eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events.
     */
    data: eventsCreateManyInput | eventsCreateManyInput[]
  }

  /**
   * events update
   */
  export type eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * The data needed to update a events.
     */
    data: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
    /**
     * Choose, which events to update.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events updateMany
   */
  export type eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events.
     */
    data: XOR<eventsUpdateManyMutationInput, eventsUncheckedUpdateManyInput>
    /**
     * Filter which events to update
     */
    where?: eventsWhereInput
  }

  /**
   * events upsert
   */
  export type eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * The filter to search for the events to update in case it exists.
     */
    where: eventsWhereUniqueInput
    /**
     * In case the events found by the `where` argument doesn't exist, create a new events with this data.
     */
    create: XOR<eventsCreateInput, eventsUncheckedCreateInput>
    /**
     * In case the events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventsUpdateInput, eventsUncheckedUpdateInput>
  }

  /**
   * events delete
   */
  export type eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
    /**
     * Filter which events to delete.
     */
    where: eventsWhereUniqueInput
  }

  /**
   * events deleteMany
   */
  export type eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events to delete
     */
    where?: eventsWhereInput
  }

  /**
   * events findRaw
   */
  export type eventsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * events aggregateRaw
   */
  export type eventsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * events without action
   */
  export type eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events
     */
    select?: eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventsInclude<ExtArgs> | null
  }


  /**
   * Model question_classes
   */

  export type AggregateQuestion_classes = {
    _count: Question_classesCountAggregateOutputType | null
    _min: Question_classesMinAggregateOutputType | null
    _max: Question_classesMaxAggregateOutputType | null
  }

  export type Question_classesMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Question_classesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Question_classesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Question_classesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Question_classesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Question_classesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Question_classesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_classes to aggregate.
     */
    where?: question_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_classes to fetch.
     */
    orderBy?: question_classesOrderByWithRelationInput | question_classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: question_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned question_classes
    **/
    _count?: true | Question_classesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Question_classesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Question_classesMaxAggregateInputType
  }

  export type GetQuestion_classesAggregateType<T extends Question_classesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion_classes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion_classes[P]>
      : GetScalarType<T[P], AggregateQuestion_classes[P]>
  }




  export type question_classesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_classesWhereInput
    orderBy?: question_classesOrderByWithAggregationInput | question_classesOrderByWithAggregationInput[]
    by: Question_classesScalarFieldEnum[] | Question_classesScalarFieldEnum
    having?: question_classesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Question_classesCountAggregateInputType | true
    _min?: Question_classesMinAggregateInputType
    _max?: Question_classesMaxAggregateInputType
  }

  export type Question_classesGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: Question_classesCountAggregateOutputType | null
    _min: Question_classesMinAggregateOutputType | null
    _max: Question_classesMaxAggregateOutputType | null
  }

  type GetQuestion_classesGroupByPayload<T extends question_classesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Question_classesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Question_classesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Question_classesGroupByOutputType[P]>
            : GetScalarType<T[P], Question_classesGroupByOutputType[P]>
        }
      >
    >


  export type question_classesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | question_classes$questionsArgs<ExtArgs>
    _count?: boolean | Question_classesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question_classes"]>


  export type question_classesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type question_classesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | question_classes$questionsArgs<ExtArgs>
    _count?: boolean | Question_classesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $question_classesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "question_classes"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["question_classes"]>
    composites: {}
  }

  type question_classesGetPayload<S extends boolean | null | undefined | question_classesDefaultArgs> = $Result.GetResult<Prisma.$question_classesPayload, S>

  type question_classesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<question_classesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Question_classesCountAggregateInputType | true
    }

  export interface question_classesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['question_classes'], meta: { name: 'question_classes' } }
    /**
     * Find zero or one Question_classes that matches the filter.
     * @param {question_classesFindUniqueArgs} args - Arguments to find a Question_classes
     * @example
     * // Get one Question_classes
     * const question_classes = await prisma.question_classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends question_classesFindUniqueArgs>(args: SelectSubset<T, question_classesFindUniqueArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question_classes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {question_classesFindUniqueOrThrowArgs} args - Arguments to find a Question_classes
     * @example
     * // Get one Question_classes
     * const question_classes = await prisma.question_classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends question_classesFindUniqueOrThrowArgs>(args: SelectSubset<T, question_classesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question_classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesFindFirstArgs} args - Arguments to find a Question_classes
     * @example
     * // Get one Question_classes
     * const question_classes = await prisma.question_classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends question_classesFindFirstArgs>(args?: SelectSubset<T, question_classesFindFirstArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question_classes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesFindFirstOrThrowArgs} args - Arguments to find a Question_classes
     * @example
     * // Get one Question_classes
     * const question_classes = await prisma.question_classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends question_classesFindFirstOrThrowArgs>(args?: SelectSubset<T, question_classesFindFirstOrThrowArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Question_classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Question_classes
     * const question_classes = await prisma.question_classes.findMany()
     * 
     * // Get first 10 Question_classes
     * const question_classes = await prisma.question_classes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const question_classesWithIdOnly = await prisma.question_classes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends question_classesFindManyArgs>(args?: SelectSubset<T, question_classesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question_classes.
     * @param {question_classesCreateArgs} args - Arguments to create a Question_classes.
     * @example
     * // Create one Question_classes
     * const Question_classes = await prisma.question_classes.create({
     *   data: {
     *     // ... data to create a Question_classes
     *   }
     * })
     * 
     */
    create<T extends question_classesCreateArgs>(args: SelectSubset<T, question_classesCreateArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Question_classes.
     * @param {question_classesCreateManyArgs} args - Arguments to create many Question_classes.
     * @example
     * // Create many Question_classes
     * const question_classes = await prisma.question_classes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends question_classesCreateManyArgs>(args?: SelectSubset<T, question_classesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question_classes.
     * @param {question_classesDeleteArgs} args - Arguments to delete one Question_classes.
     * @example
     * // Delete one Question_classes
     * const Question_classes = await prisma.question_classes.delete({
     *   where: {
     *     // ... filter to delete one Question_classes
     *   }
     * })
     * 
     */
    delete<T extends question_classesDeleteArgs>(args: SelectSubset<T, question_classesDeleteArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question_classes.
     * @param {question_classesUpdateArgs} args - Arguments to update one Question_classes.
     * @example
     * // Update one Question_classes
     * const question_classes = await prisma.question_classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends question_classesUpdateArgs>(args: SelectSubset<T, question_classesUpdateArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Question_classes.
     * @param {question_classesDeleteManyArgs} args - Arguments to filter Question_classes to delete.
     * @example
     * // Delete a few Question_classes
     * const { count } = await prisma.question_classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends question_classesDeleteManyArgs>(args?: SelectSubset<T, question_classesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Question_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Question_classes
     * const question_classes = await prisma.question_classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends question_classesUpdateManyArgs>(args: SelectSubset<T, question_classesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question_classes.
     * @param {question_classesUpsertArgs} args - Arguments to update or create a Question_classes.
     * @example
     * // Update or create a Question_classes
     * const question_classes = await prisma.question_classes.upsert({
     *   create: {
     *     // ... data to create a Question_classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question_classes we want to update
     *   }
     * })
     */
    upsert<T extends question_classesUpsertArgs>(args: SelectSubset<T, question_classesUpsertArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Question_classes that matches the filter.
     * @param {question_classesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const question_classes = await prisma.question_classes.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: question_classesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Question_classes.
     * @param {question_classesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const question_classes = await prisma.question_classes.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: question_classesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Question_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesCountArgs} args - Arguments to filter Question_classes to count.
     * @example
     * // Count the number of Question_classes
     * const count = await prisma.question_classes.count({
     *   where: {
     *     // ... the filter for the Question_classes we want to count
     *   }
     * })
    **/
    count<T extends question_classesCountArgs>(
      args?: Subset<T, question_classesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Question_classesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Question_classesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Question_classesAggregateArgs>(args: Subset<T, Question_classesAggregateArgs>): Prisma.PrismaPromise<GetQuestion_classesAggregateType<T>>

    /**
     * Group by Question_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends question_classesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: question_classesGroupByArgs['orderBy'] }
        : { orderBy?: question_classesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, question_classesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestion_classesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the question_classes model
   */
  readonly fields: question_classesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for question_classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__question_classesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends question_classes$questionsArgs<ExtArgs> = {}>(args?: Subset<T, question_classes$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the question_classes model
   */ 
  interface question_classesFieldRefs {
    readonly id: FieldRef<"question_classes", 'String'>
    readonly name: FieldRef<"question_classes", 'String'>
    readonly createdAt: FieldRef<"question_classes", 'DateTime'>
    readonly updatedAt: FieldRef<"question_classes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * question_classes findUnique
   */
  export type question_classesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where: question_classesWhereUniqueInput
  }

  /**
   * question_classes findUniqueOrThrow
   */
  export type question_classesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where: question_classesWhereUniqueInput
  }

  /**
   * question_classes findFirst
   */
  export type question_classesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where?: question_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_classes to fetch.
     */
    orderBy?: question_classesOrderByWithRelationInput | question_classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_classes.
     */
    cursor?: question_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_classes.
     */
    distinct?: Question_classesScalarFieldEnum | Question_classesScalarFieldEnum[]
  }

  /**
   * question_classes findFirstOrThrow
   */
  export type question_classesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where?: question_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_classes to fetch.
     */
    orderBy?: question_classesOrderByWithRelationInput | question_classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_classes.
     */
    cursor?: question_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_classes.
     */
    distinct?: Question_classesScalarFieldEnum | Question_classesScalarFieldEnum[]
  }

  /**
   * question_classes findMany
   */
  export type question_classesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where?: question_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_classes to fetch.
     */
    orderBy?: question_classesOrderByWithRelationInput | question_classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing question_classes.
     */
    cursor?: question_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_classes.
     */
    skip?: number
    distinct?: Question_classesScalarFieldEnum | Question_classesScalarFieldEnum[]
  }

  /**
   * question_classes create
   */
  export type question_classesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * The data needed to create a question_classes.
     */
    data: XOR<question_classesCreateInput, question_classesUncheckedCreateInput>
  }

  /**
   * question_classes createMany
   */
  export type question_classesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many question_classes.
     */
    data: question_classesCreateManyInput | question_classesCreateManyInput[]
  }

  /**
   * question_classes update
   */
  export type question_classesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * The data needed to update a question_classes.
     */
    data: XOR<question_classesUpdateInput, question_classesUncheckedUpdateInput>
    /**
     * Choose, which question_classes to update.
     */
    where: question_classesWhereUniqueInput
  }

  /**
   * question_classes updateMany
   */
  export type question_classesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update question_classes.
     */
    data: XOR<question_classesUpdateManyMutationInput, question_classesUncheckedUpdateManyInput>
    /**
     * Filter which question_classes to update
     */
    where?: question_classesWhereInput
  }

  /**
   * question_classes upsert
   */
  export type question_classesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * The filter to search for the question_classes to update in case it exists.
     */
    where: question_classesWhereUniqueInput
    /**
     * In case the question_classes found by the `where` argument doesn't exist, create a new question_classes with this data.
     */
    create: XOR<question_classesCreateInput, question_classesUncheckedCreateInput>
    /**
     * In case the question_classes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<question_classesUpdateInput, question_classesUncheckedUpdateInput>
  }

  /**
   * question_classes delete
   */
  export type question_classesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter which question_classes to delete.
     */
    where: question_classesWhereUniqueInput
  }

  /**
   * question_classes deleteMany
   */
  export type question_classesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_classes to delete
     */
    where?: question_classesWhereInput
  }

  /**
   * question_classes findRaw
   */
  export type question_classesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * question_classes aggregateRaw
   */
  export type question_classesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * question_classes.questions
   */
  export type question_classes$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * question_classes without action
   */
  export type question_classesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
  }


  /**
   * Model answers
   */

  export type AggregateAnswers = {
    _count: AnswersCountAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  export type AnswersMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnswersMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnswersCountAggregateOutputType = {
    id: number
    questionId: number
    answer: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnswersMinAggregateInputType = {
    id?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnswersMaxAggregateInputType = {
    id?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnswersCountAggregateInputType = {
    id?: true
    questionId?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnswersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which answers to aggregate.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned answers
    **/
    _count?: true | AnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswersMaxAggregateInputType
  }

  export type GetAnswersAggregateType<T extends AnswersAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswers[P]>
      : GetScalarType<T[P], AggregateAnswers[P]>
  }




  export type answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
    orderBy?: answersOrderByWithAggregationInput | answersOrderByWithAggregationInput[]
    by: AnswersScalarFieldEnum[] | AnswersScalarFieldEnum
    having?: answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswersCountAggregateInputType | true
    _min?: AnswersMinAggregateInputType
    _max?: AnswersMaxAggregateInputType
  }

  export type AnswersGroupByOutputType = {
    id: string
    questionId: string
    answer: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: AnswersCountAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  type GetAnswersGroupByPayload<T extends answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswersGroupByOutputType[P]>
            : GetScalarType<T[P], AnswersGroupByOutputType[P]>
        }
      >
    >


  export type answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | questionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>


  export type answersSelectScalar = {
    id?: boolean
    questionId?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | questionsDefaultArgs<ExtArgs>
  }

  export type $answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "answers"
    objects: {
      question: Prisma.$questionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      answer: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["answers"]>
    composites: {}
  }

  type answersGetPayload<S extends boolean | null | undefined | answersDefaultArgs> = $Result.GetResult<Prisma.$answersPayload, S>

  type answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<answersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnswersCountAggregateInputType | true
    }

  export interface answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['answers'], meta: { name: 'answers' } }
    /**
     * Find zero or one Answers that matches the filter.
     * @param {answersFindUniqueArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends answersFindUniqueArgs>(args: SelectSubset<T, answersFindUniqueArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Answers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {answersFindUniqueOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends answersFindUniqueOrThrowArgs>(args: SelectSubset<T, answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindFirstArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends answersFindFirstArgs>(args?: SelectSubset<T, answersFindFirstArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindFirstOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends answersFindFirstOrThrowArgs>(args?: SelectSubset<T, answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answers.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answersWithIdOnly = await prisma.answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends answersFindManyArgs>(args?: SelectSubset<T, answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Answers.
     * @param {answersCreateArgs} args - Arguments to create a Answers.
     * @example
     * // Create one Answers
     * const Answers = await prisma.answers.create({
     *   data: {
     *     // ... data to create a Answers
     *   }
     * })
     * 
     */
    create<T extends answersCreateArgs>(args: SelectSubset<T, answersCreateArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Answers.
     * @param {answersCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answers = await prisma.answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends answersCreateManyArgs>(args?: SelectSubset<T, answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Answers.
     * @param {answersDeleteArgs} args - Arguments to delete one Answers.
     * @example
     * // Delete one Answers
     * const Answers = await prisma.answers.delete({
     *   where: {
     *     // ... filter to delete one Answers
     *   }
     * })
     * 
     */
    delete<T extends answersDeleteArgs>(args: SelectSubset<T, answersDeleteArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Answers.
     * @param {answersUpdateArgs} args - Arguments to update one Answers.
     * @example
     * // Update one Answers
     * const answers = await prisma.answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends answersUpdateArgs>(args: SelectSubset<T, answersUpdateArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Answers.
     * @param {answersDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends answersDeleteManyArgs>(args?: SelectSubset<T, answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends answersUpdateManyArgs>(args: SelectSubset<T, answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Answers.
     * @param {answersUpsertArgs} args - Arguments to update or create a Answers.
     * @example
     * // Update or create a Answers
     * const answers = await prisma.answers.upsert({
     *   create: {
     *     // ... data to create a Answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answers we want to update
     *   }
     * })
     */
    upsert<T extends answersUpsertArgs>(args: SelectSubset<T, answersUpsertArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Answers that matches the filter.
     * @param {answersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const answers = await prisma.answers.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: answersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Answers.
     * @param {answersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const answers = await prisma.answers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: answersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answers.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends answersCountArgs>(
      args?: Subset<T, answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswersAggregateArgs>(args: Subset<T, AnswersAggregateArgs>): Prisma.PrismaPromise<GetAnswersAggregateType<T>>

    /**
     * Group by Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: answersGroupByArgs['orderBy'] }
        : { orderBy?: answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the answers model
   */
  readonly fields: answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionsDefaultArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the answers model
   */ 
  interface answersFieldRefs {
    readonly id: FieldRef<"answers", 'String'>
    readonly questionId: FieldRef<"answers", 'String'>
    readonly answer: FieldRef<"answers", 'Json'>
    readonly createdAt: FieldRef<"answers", 'DateTime'>
    readonly updatedAt: FieldRef<"answers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * answers findUnique
   */
  export type answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers findUniqueOrThrow
   */
  export type answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers findFirst
   */
  export type answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers findFirstOrThrow
   */
  export type answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers findMany
   */
  export type answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers create
   */
  export type answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The data needed to create a answers.
     */
    data: XOR<answersCreateInput, answersUncheckedCreateInput>
  }

  /**
   * answers createMany
   */
  export type answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many answers.
     */
    data: answersCreateManyInput | answersCreateManyInput[]
  }

  /**
   * answers update
   */
  export type answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The data needed to update a answers.
     */
    data: XOR<answersUpdateInput, answersUncheckedUpdateInput>
    /**
     * Choose, which answers to update.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers updateMany
   */
  export type answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update answers.
     */
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyInput>
    /**
     * Filter which answers to update
     */
    where?: answersWhereInput
  }

  /**
   * answers upsert
   */
  export type answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The filter to search for the answers to update in case it exists.
     */
    where: answersWhereUniqueInput
    /**
     * In case the answers found by the `where` argument doesn't exist, create a new answers with this data.
     */
    create: XOR<answersCreateInput, answersUncheckedCreateInput>
    /**
     * In case the answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<answersUpdateInput, answersUncheckedUpdateInput>
  }

  /**
   * answers delete
   */
  export type answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter which answers to delete.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers deleteMany
   */
  export type answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which answers to delete
     */
    where?: answersWhereInput
  }

  /**
   * answers findRaw
   */
  export type answersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * answers aggregateRaw
   */
  export type answersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * answers without action
   */
  export type answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
  }


  /**
   * Model questionnaires
   */

  export type AggregateQuestionnaires = {
    _count: QuestionnairesCountAggregateOutputType | null
    _min: QuestionnairesMinAggregateOutputType | null
    _max: QuestionnairesMaxAggregateOutputType | null
  }

  export type QuestionnairesMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnairesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnairesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionnairesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnairesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnairesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionnairesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionnaires to aggregate.
     */
    where?: questionnairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionnaires to fetch.
     */
    orderBy?: questionnairesOrderByWithRelationInput | questionnairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionnairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questionnaires
    **/
    _count?: true | QuestionnairesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionnairesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionnairesMaxAggregateInputType
  }

  export type GetQuestionnairesAggregateType<T extends QuestionnairesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionnaires]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionnaires[P]>
      : GetScalarType<T[P], AggregateQuestionnaires[P]>
  }




  export type questionnairesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionnairesWhereInput
    orderBy?: questionnairesOrderByWithAggregationInput | questionnairesOrderByWithAggregationInput[]
    by: QuestionnairesScalarFieldEnum[] | QuestionnairesScalarFieldEnum
    having?: questionnairesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionnairesCountAggregateInputType | true
    _min?: QuestionnairesMinAggregateInputType
    _max?: QuestionnairesMaxAggregateInputType
  }

  export type QuestionnairesGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionnairesCountAggregateOutputType | null
    _min: QuestionnairesMinAggregateOutputType | null
    _max: QuestionnairesMaxAggregateOutputType | null
  }

  type GetQuestionnairesGroupByPayload<T extends questionnairesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionnairesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionnairesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionnairesGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionnairesGroupByOutputType[P]>
        }
      >
    >


  export type questionnairesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | questionnaires$questionsArgs<ExtArgs>
    _count?: boolean | QuestionnairesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaires"]>


  export type questionnairesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type questionnairesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | questionnaires$questionsArgs<ExtArgs>
    _count?: boolean | QuestionnairesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $questionnairesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questionnaires"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionnaires"]>
    composites: {}
  }

  type questionnairesGetPayload<S extends boolean | null | undefined | questionnairesDefaultArgs> = $Result.GetResult<Prisma.$questionnairesPayload, S>

  type questionnairesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questionnairesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionnairesCountAggregateInputType | true
    }

  export interface questionnairesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questionnaires'], meta: { name: 'questionnaires' } }
    /**
     * Find zero or one Questionnaires that matches the filter.
     * @param {questionnairesFindUniqueArgs} args - Arguments to find a Questionnaires
     * @example
     * // Get one Questionnaires
     * const questionnaires = await prisma.questionnaires.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionnairesFindUniqueArgs>(args: SelectSubset<T, questionnairesFindUniqueArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questionnaires that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questionnairesFindUniqueOrThrowArgs} args - Arguments to find a Questionnaires
     * @example
     * // Get one Questionnaires
     * const questionnaires = await prisma.questionnaires.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionnairesFindUniqueOrThrowArgs>(args: SelectSubset<T, questionnairesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questionnaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesFindFirstArgs} args - Arguments to find a Questionnaires
     * @example
     * // Get one Questionnaires
     * const questionnaires = await prisma.questionnaires.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionnairesFindFirstArgs>(args?: SelectSubset<T, questionnairesFindFirstArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questionnaires that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesFindFirstOrThrowArgs} args - Arguments to find a Questionnaires
     * @example
     * // Get one Questionnaires
     * const questionnaires = await prisma.questionnaires.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionnairesFindFirstOrThrowArgs>(args?: SelectSubset<T, questionnairesFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questionnaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questionnaires
     * const questionnaires = await prisma.questionnaires.findMany()
     * 
     * // Get first 10 Questionnaires
     * const questionnaires = await prisma.questionnaires.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionnairesWithIdOnly = await prisma.questionnaires.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionnairesFindManyArgs>(args?: SelectSubset<T, questionnairesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questionnaires.
     * @param {questionnairesCreateArgs} args - Arguments to create a Questionnaires.
     * @example
     * // Create one Questionnaires
     * const Questionnaires = await prisma.questionnaires.create({
     *   data: {
     *     // ... data to create a Questionnaires
     *   }
     * })
     * 
     */
    create<T extends questionnairesCreateArgs>(args: SelectSubset<T, questionnairesCreateArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questionnaires.
     * @param {questionnairesCreateManyArgs} args - Arguments to create many Questionnaires.
     * @example
     * // Create many Questionnaires
     * const questionnaires = await prisma.questionnaires.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionnairesCreateManyArgs>(args?: SelectSubset<T, questionnairesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questionnaires.
     * @param {questionnairesDeleteArgs} args - Arguments to delete one Questionnaires.
     * @example
     * // Delete one Questionnaires
     * const Questionnaires = await prisma.questionnaires.delete({
     *   where: {
     *     // ... filter to delete one Questionnaires
     *   }
     * })
     * 
     */
    delete<T extends questionnairesDeleteArgs>(args: SelectSubset<T, questionnairesDeleteArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questionnaires.
     * @param {questionnairesUpdateArgs} args - Arguments to update one Questionnaires.
     * @example
     * // Update one Questionnaires
     * const questionnaires = await prisma.questionnaires.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionnairesUpdateArgs>(args: SelectSubset<T, questionnairesUpdateArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questionnaires.
     * @param {questionnairesDeleteManyArgs} args - Arguments to filter Questionnaires to delete.
     * @example
     * // Delete a few Questionnaires
     * const { count } = await prisma.questionnaires.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionnairesDeleteManyArgs>(args?: SelectSubset<T, questionnairesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questionnaires
     * const questionnaires = await prisma.questionnaires.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionnairesUpdateManyArgs>(args: SelectSubset<T, questionnairesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questionnaires.
     * @param {questionnairesUpsertArgs} args - Arguments to update or create a Questionnaires.
     * @example
     * // Update or create a Questionnaires
     * const questionnaires = await prisma.questionnaires.upsert({
     *   create: {
     *     // ... data to create a Questionnaires
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questionnaires we want to update
     *   }
     * })
     */
    upsert<T extends questionnairesUpsertArgs>(args: SelectSubset<T, questionnairesUpsertArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Questionnaires that matches the filter.
     * @param {questionnairesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const questionnaires = await prisma.questionnaires.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: questionnairesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Questionnaires.
     * @param {questionnairesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const questionnaires = await prisma.questionnaires.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: questionnairesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesCountArgs} args - Arguments to filter Questionnaires to count.
     * @example
     * // Count the number of Questionnaires
     * const count = await prisma.questionnaires.count({
     *   where: {
     *     // ... the filter for the Questionnaires we want to count
     *   }
     * })
    **/
    count<T extends questionnairesCountArgs>(
      args?: Subset<T, questionnairesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionnairesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnairesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionnairesAggregateArgs>(args: Subset<T, QuestionnairesAggregateArgs>): Prisma.PrismaPromise<GetQuestionnairesAggregateType<T>>

    /**
     * Group by Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionnairesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionnairesGroupByArgs['orderBy'] }
        : { orderBy?: questionnairesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionnairesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionnairesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questionnaires model
   */
  readonly fields: questionnairesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questionnaires.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionnairesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends questionnaires$questionsArgs<ExtArgs> = {}>(args?: Subset<T, questionnaires$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questionnaires model
   */ 
  interface questionnairesFieldRefs {
    readonly id: FieldRef<"questionnaires", 'String'>
    readonly name: FieldRef<"questionnaires", 'String'>
    readonly createdAt: FieldRef<"questionnaires", 'DateTime'>
    readonly updatedAt: FieldRef<"questionnaires", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * questionnaires findUnique
   */
  export type questionnairesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where: questionnairesWhereUniqueInput
  }

  /**
   * questionnaires findUniqueOrThrow
   */
  export type questionnairesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where: questionnairesWhereUniqueInput
  }

  /**
   * questionnaires findFirst
   */
  export type questionnairesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where?: questionnairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionnaires to fetch.
     */
    orderBy?: questionnairesOrderByWithRelationInput | questionnairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionnaires.
     */
    cursor?: questionnairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionnaires.
     */
    distinct?: QuestionnairesScalarFieldEnum | QuestionnairesScalarFieldEnum[]
  }

  /**
   * questionnaires findFirstOrThrow
   */
  export type questionnairesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where?: questionnairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionnaires to fetch.
     */
    orderBy?: questionnairesOrderByWithRelationInput | questionnairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionnaires.
     */
    cursor?: questionnairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionnaires.
     */
    distinct?: QuestionnairesScalarFieldEnum | QuestionnairesScalarFieldEnum[]
  }

  /**
   * questionnaires findMany
   */
  export type questionnairesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where?: questionnairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionnaires to fetch.
     */
    orderBy?: questionnairesOrderByWithRelationInput | questionnairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questionnaires.
     */
    cursor?: questionnairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionnaires.
     */
    skip?: number
    distinct?: QuestionnairesScalarFieldEnum | QuestionnairesScalarFieldEnum[]
  }

  /**
   * questionnaires create
   */
  export type questionnairesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * The data needed to create a questionnaires.
     */
    data: XOR<questionnairesCreateInput, questionnairesUncheckedCreateInput>
  }

  /**
   * questionnaires createMany
   */
  export type questionnairesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questionnaires.
     */
    data: questionnairesCreateManyInput | questionnairesCreateManyInput[]
  }

  /**
   * questionnaires update
   */
  export type questionnairesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * The data needed to update a questionnaires.
     */
    data: XOR<questionnairesUpdateInput, questionnairesUncheckedUpdateInput>
    /**
     * Choose, which questionnaires to update.
     */
    where: questionnairesWhereUniqueInput
  }

  /**
   * questionnaires updateMany
   */
  export type questionnairesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questionnaires.
     */
    data: XOR<questionnairesUpdateManyMutationInput, questionnairesUncheckedUpdateManyInput>
    /**
     * Filter which questionnaires to update
     */
    where?: questionnairesWhereInput
  }

  /**
   * questionnaires upsert
   */
  export type questionnairesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * The filter to search for the questionnaires to update in case it exists.
     */
    where: questionnairesWhereUniqueInput
    /**
     * In case the questionnaires found by the `where` argument doesn't exist, create a new questionnaires with this data.
     */
    create: XOR<questionnairesCreateInput, questionnairesUncheckedCreateInput>
    /**
     * In case the questionnaires was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionnairesUpdateInput, questionnairesUncheckedUpdateInput>
  }

  /**
   * questionnaires delete
   */
  export type questionnairesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter which questionnaires to delete.
     */
    where: questionnairesWhereUniqueInput
  }

  /**
   * questionnaires deleteMany
   */
  export type questionnairesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionnaires to delete
     */
    where?: questionnairesWhereInput
  }

  /**
   * questionnaires findRaw
   */
  export type questionnairesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * questionnaires aggregateRaw
   */
  export type questionnairesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * questionnaires.questions
   */
  export type questionnaires$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questionnaires without action
   */
  export type questionnairesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
  }


  /**
   * Model production_submissions
   */

  export type AggregateProduction_submissions = {
    _count: Production_submissionsCountAggregateOutputType | null
    _min: Production_submissionsMinAggregateOutputType | null
    _max: Production_submissionsMaxAggregateOutputType | null
  }

  export type Production_submissionsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Production_submissionsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Production_submissionsCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Production_submissionsMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Production_submissionsMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Production_submissionsCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Production_submissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which production_submissions to aggregate.
     */
    where?: production_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_submissions to fetch.
     */
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: production_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned production_submissions
    **/
    _count?: true | Production_submissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Production_submissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Production_submissionsMaxAggregateInputType
  }

  export type GetProduction_submissionsAggregateType<T extends Production_submissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateProduction_submissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduction_submissions[P]>
      : GetScalarType<T[P], AggregateProduction_submissions[P]>
  }




  export type production_submissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: production_submissionsWhereInput
    orderBy?: production_submissionsOrderByWithAggregationInput | production_submissionsOrderByWithAggregationInput[]
    by: Production_submissionsScalarFieldEnum[] | Production_submissionsScalarFieldEnum
    having?: production_submissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Production_submissionsCountAggregateInputType | true
    _min?: Production_submissionsMinAggregateInputType
    _max?: Production_submissionsMaxAggregateInputType
  }

  export type Production_submissionsGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: Production_submissionsCountAggregateOutputType | null
    _min: Production_submissionsMinAggregateOutputType | null
    _max: Production_submissionsMaxAggregateOutputType | null
  }

  type GetProduction_submissionsGroupByPayload<T extends production_submissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Production_submissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Production_submissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Production_submissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Production_submissionsGroupByOutputType[P]>
        }
      >
    >


  export type production_submissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["production_submissions"]>


  export type production_submissionsSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type production_submissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $production_submissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "production_submissions"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["production_submissions"]>
    composites: {}
  }

  type production_submissionsGetPayload<S extends boolean | null | undefined | production_submissionsDefaultArgs> = $Result.GetResult<Prisma.$production_submissionsPayload, S>

  type production_submissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<production_submissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Production_submissionsCountAggregateInputType | true
    }

  export interface production_submissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['production_submissions'], meta: { name: 'production_submissions' } }
    /**
     * Find zero or one Production_submissions that matches the filter.
     * @param {production_submissionsFindUniqueArgs} args - Arguments to find a Production_submissions
     * @example
     * // Get one Production_submissions
     * const production_submissions = await prisma.production_submissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends production_submissionsFindUniqueArgs>(args: SelectSubset<T, production_submissionsFindUniqueArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Production_submissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {production_submissionsFindUniqueOrThrowArgs} args - Arguments to find a Production_submissions
     * @example
     * // Get one Production_submissions
     * const production_submissions = await prisma.production_submissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends production_submissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, production_submissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Production_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsFindFirstArgs} args - Arguments to find a Production_submissions
     * @example
     * // Get one Production_submissions
     * const production_submissions = await prisma.production_submissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends production_submissionsFindFirstArgs>(args?: SelectSubset<T, production_submissionsFindFirstArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Production_submissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsFindFirstOrThrowArgs} args - Arguments to find a Production_submissions
     * @example
     * // Get one Production_submissions
     * const production_submissions = await prisma.production_submissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends production_submissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, production_submissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Production_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Production_submissions
     * const production_submissions = await prisma.production_submissions.findMany()
     * 
     * // Get first 10 Production_submissions
     * const production_submissions = await prisma.production_submissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const production_submissionsWithIdOnly = await prisma.production_submissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends production_submissionsFindManyArgs>(args?: SelectSubset<T, production_submissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Production_submissions.
     * @param {production_submissionsCreateArgs} args - Arguments to create a Production_submissions.
     * @example
     * // Create one Production_submissions
     * const Production_submissions = await prisma.production_submissions.create({
     *   data: {
     *     // ... data to create a Production_submissions
     *   }
     * })
     * 
     */
    create<T extends production_submissionsCreateArgs>(args: SelectSubset<T, production_submissionsCreateArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Production_submissions.
     * @param {production_submissionsCreateManyArgs} args - Arguments to create many Production_submissions.
     * @example
     * // Create many Production_submissions
     * const production_submissions = await prisma.production_submissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends production_submissionsCreateManyArgs>(args?: SelectSubset<T, production_submissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Production_submissions.
     * @param {production_submissionsDeleteArgs} args - Arguments to delete one Production_submissions.
     * @example
     * // Delete one Production_submissions
     * const Production_submissions = await prisma.production_submissions.delete({
     *   where: {
     *     // ... filter to delete one Production_submissions
     *   }
     * })
     * 
     */
    delete<T extends production_submissionsDeleteArgs>(args: SelectSubset<T, production_submissionsDeleteArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Production_submissions.
     * @param {production_submissionsUpdateArgs} args - Arguments to update one Production_submissions.
     * @example
     * // Update one Production_submissions
     * const production_submissions = await prisma.production_submissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends production_submissionsUpdateArgs>(args: SelectSubset<T, production_submissionsUpdateArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Production_submissions.
     * @param {production_submissionsDeleteManyArgs} args - Arguments to filter Production_submissions to delete.
     * @example
     * // Delete a few Production_submissions
     * const { count } = await prisma.production_submissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends production_submissionsDeleteManyArgs>(args?: SelectSubset<T, production_submissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Production_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Production_submissions
     * const production_submissions = await prisma.production_submissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends production_submissionsUpdateManyArgs>(args: SelectSubset<T, production_submissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Production_submissions.
     * @param {production_submissionsUpsertArgs} args - Arguments to update or create a Production_submissions.
     * @example
     * // Update or create a Production_submissions
     * const production_submissions = await prisma.production_submissions.upsert({
     *   create: {
     *     // ... data to create a Production_submissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Production_submissions we want to update
     *   }
     * })
     */
    upsert<T extends production_submissionsUpsertArgs>(args: SelectSubset<T, production_submissionsUpsertArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Production_submissions that matches the filter.
     * @param {production_submissionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const production_submissions = await prisma.production_submissions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: production_submissionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Production_submissions.
     * @param {production_submissionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const production_submissions = await prisma.production_submissions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: production_submissionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Production_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsCountArgs} args - Arguments to filter Production_submissions to count.
     * @example
     * // Count the number of Production_submissions
     * const count = await prisma.production_submissions.count({
     *   where: {
     *     // ... the filter for the Production_submissions we want to count
     *   }
     * })
    **/
    count<T extends production_submissionsCountArgs>(
      args?: Subset<T, production_submissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Production_submissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Production_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Production_submissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Production_submissionsAggregateArgs>(args: Subset<T, Production_submissionsAggregateArgs>): Prisma.PrismaPromise<GetProduction_submissionsAggregateType<T>>

    /**
     * Group by Production_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends production_submissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: production_submissionsGroupByArgs['orderBy'] }
        : { orderBy?: production_submissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, production_submissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduction_submissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the production_submissions model
   */
  readonly fields: production_submissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for production_submissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__production_submissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the production_submissions model
   */ 
  interface production_submissionsFieldRefs {
    readonly id: FieldRef<"production_submissions", 'String'>
    readonly userId: FieldRef<"production_submissions", 'String'>
    readonly createdAt: FieldRef<"production_submissions", 'DateTime'>
    readonly updatedAt: FieldRef<"production_submissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * production_submissions findUnique
   */
  export type production_submissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where: production_submissionsWhereUniqueInput
  }

  /**
   * production_submissions findUniqueOrThrow
   */
  export type production_submissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where: production_submissionsWhereUniqueInput
  }

  /**
   * production_submissions findFirst
   */
  export type production_submissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where?: production_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_submissions to fetch.
     */
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for production_submissions.
     */
    cursor?: production_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of production_submissions.
     */
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * production_submissions findFirstOrThrow
   */
  export type production_submissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where?: production_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_submissions to fetch.
     */
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for production_submissions.
     */
    cursor?: production_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of production_submissions.
     */
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * production_submissions findMany
   */
  export type production_submissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where?: production_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_submissions to fetch.
     */
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing production_submissions.
     */
    cursor?: production_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_submissions.
     */
    skip?: number
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * production_submissions create
   */
  export type production_submissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a production_submissions.
     */
    data: XOR<production_submissionsCreateInput, production_submissionsUncheckedCreateInput>
  }

  /**
   * production_submissions createMany
   */
  export type production_submissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many production_submissions.
     */
    data: production_submissionsCreateManyInput | production_submissionsCreateManyInput[]
  }

  /**
   * production_submissions update
   */
  export type production_submissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a production_submissions.
     */
    data: XOR<production_submissionsUpdateInput, production_submissionsUncheckedUpdateInput>
    /**
     * Choose, which production_submissions to update.
     */
    where: production_submissionsWhereUniqueInput
  }

  /**
   * production_submissions updateMany
   */
  export type production_submissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update production_submissions.
     */
    data: XOR<production_submissionsUpdateManyMutationInput, production_submissionsUncheckedUpdateManyInput>
    /**
     * Filter which production_submissions to update
     */
    where?: production_submissionsWhereInput
  }

  /**
   * production_submissions upsert
   */
  export type production_submissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the production_submissions to update in case it exists.
     */
    where: production_submissionsWhereUniqueInput
    /**
     * In case the production_submissions found by the `where` argument doesn't exist, create a new production_submissions with this data.
     */
    create: XOR<production_submissionsCreateInput, production_submissionsUncheckedCreateInput>
    /**
     * In case the production_submissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<production_submissionsUpdateInput, production_submissionsUncheckedUpdateInput>
  }

  /**
   * production_submissions delete
   */
  export type production_submissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter which production_submissions to delete.
     */
    where: production_submissionsWhereUniqueInput
  }

  /**
   * production_submissions deleteMany
   */
  export type production_submissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which production_submissions to delete
     */
    where?: production_submissionsWhereInput
  }

  /**
   * production_submissions findRaw
   */
  export type production_submissionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * production_submissions aggregateRaw
   */
  export type production_submissionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * production_submissions without action
   */
  export type production_submissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
  }


  /**
   * Model questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    position: number | null
    questionnaireSubCategory: number | null
    maxOptions: number | null
  }

  export type QuestionsSumAggregateOutputType = {
    position: number | null
    questionnaireSubCategory: number | null
    maxOptions: number | null
  }

  export type QuestionsMinAggregateOutputType = {
    id: string | null
    position: number | null
    type: string | null
    classId: string | null
    categoryId: string | null
    onboarding: boolean | null
    randomizeOptions: boolean | null
    fixedOptionSize: boolean | null
    hideOptionText: boolean | null
    brandId: string | null
    correctAnswerId: string | null
    questionnaireId: string | null
    questionnaireSubCategory: number | null
    createdAt: Date | null
    updatedAt: Date | null
    maxOptions: number | null
  }

  export type QuestionsMaxAggregateOutputType = {
    id: string | null
    position: number | null
    type: string | null
    classId: string | null
    categoryId: string | null
    onboarding: boolean | null
    randomizeOptions: boolean | null
    fixedOptionSize: boolean | null
    hideOptionText: boolean | null
    brandId: string | null
    correctAnswerId: string | null
    questionnaireId: string | null
    questionnaireSubCategory: number | null
    createdAt: Date | null
    updatedAt: Date | null
    maxOptions: number | null
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    position: number
    question: number
    type: number
    options: number
    classId: number
    categoryId: number
    onboarding: number
    randomizeOptions: number
    fixedOptionSize: number
    hideOptionText: number
    displayImage: number
    footnote: number
    subtitle: number
    products: number
    brandId: number
    correctAnswerId: number
    questionnaireId: number
    questionnaireSubCategory: number
    createdAt: number
    updatedAt: number
    scaleTopLabel: number
    scaleBottomLabel: number
    maxOptions: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    position?: true
    questionnaireSubCategory?: true
    maxOptions?: true
  }

  export type QuestionsSumAggregateInputType = {
    position?: true
    questionnaireSubCategory?: true
    maxOptions?: true
  }

  export type QuestionsMinAggregateInputType = {
    id?: true
    position?: true
    type?: true
    classId?: true
    categoryId?: true
    onboarding?: true
    randomizeOptions?: true
    fixedOptionSize?: true
    hideOptionText?: true
    brandId?: true
    correctAnswerId?: true
    questionnaireId?: true
    questionnaireSubCategory?: true
    createdAt?: true
    updatedAt?: true
    maxOptions?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    position?: true
    type?: true
    classId?: true
    categoryId?: true
    onboarding?: true
    randomizeOptions?: true
    fixedOptionSize?: true
    hideOptionText?: true
    brandId?: true
    correctAnswerId?: true
    questionnaireId?: true
    questionnaireSubCategory?: true
    createdAt?: true
    updatedAt?: true
    maxOptions?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    position?: true
    question?: true
    type?: true
    options?: true
    classId?: true
    categoryId?: true
    onboarding?: true
    randomizeOptions?: true
    fixedOptionSize?: true
    hideOptionText?: true
    displayImage?: true
    footnote?: true
    subtitle?: true
    products?: true
    brandId?: true
    correctAnswerId?: true
    questionnaireId?: true
    questionnaireSubCategory?: true
    createdAt?: true
    updatedAt?: true
    scaleTopLabel?: true
    scaleBottomLabel?: true
    maxOptions?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to aggregate.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithAggregationInput | questionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _avg?: QuestionsAvgAggregateInputType
    _sum?: QuestionsSumAggregateInputType
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    id: string
    position: number
    question: JsonValue
    type: string
    options: JsonValue[]
    classId: string | null
    categoryId: string | null
    onboarding: boolean
    randomizeOptions: boolean | null
    fixedOptionSize: boolean | null
    hideOptionText: boolean | null
    displayImage: JsonValue | null
    footnote: JsonValue | null
    subtitle: JsonValue | null
    products: JsonValue | null
    brandId: string | null
    correctAnswerId: string | null
    questionnaireId: string | null
    questionnaireSubCategory: number | null
    createdAt: Date
    updatedAt: Date
    scaleTopLabel: JsonValue | null
    scaleBottomLabel: JsonValue | null
    maxOptions: number | null
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    classId?: boolean
    categoryId?: boolean
    onboarding?: boolean
    randomizeOptions?: boolean
    fixedOptionSize?: boolean
    hideOptionText?: boolean
    displayImage?: boolean
    footnote?: boolean
    subtitle?: boolean
    products?: boolean
    brandId?: boolean
    correctAnswerId?: boolean
    questionnaireId?: boolean
    questionnaireSubCategory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scaleTopLabel?: boolean
    scaleBottomLabel?: boolean
    maxOptions?: boolean
    questionClass?: boolean | questions$questionClassArgs<ExtArgs>
    answers?: boolean | questions$answersArgs<ExtArgs>
    brand?: boolean | questions$brandArgs<ExtArgs>
    questionnaire?: boolean | questions$questionnaireArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>


  export type questionsSelectScalar = {
    id?: boolean
    position?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    classId?: boolean
    categoryId?: boolean
    onboarding?: boolean
    randomizeOptions?: boolean
    fixedOptionSize?: boolean
    hideOptionText?: boolean
    displayImage?: boolean
    footnote?: boolean
    subtitle?: boolean
    products?: boolean
    brandId?: boolean
    correctAnswerId?: boolean
    questionnaireId?: boolean
    questionnaireSubCategory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scaleTopLabel?: boolean
    scaleBottomLabel?: boolean
    maxOptions?: boolean
  }

  export type questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionClass?: boolean | questions$questionClassArgs<ExtArgs>
    answers?: boolean | questions$answersArgs<ExtArgs>
    brand?: boolean | questions$brandArgs<ExtArgs>
    questionnaire?: boolean | questions$questionnaireArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions"
    objects: {
      questionClass: Prisma.$question_classesPayload<ExtArgs> | null
      answers: Prisma.$answersPayload<ExtArgs>[]
      brand: Prisma.$brandsPayload<ExtArgs> | null
      questionnaire: Prisma.$questionnairesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      position: number
      question: Prisma.JsonValue
      type: string
      options: Prisma.JsonValue[]
      classId: string | null
      categoryId: string | null
      onboarding: boolean
      randomizeOptions: boolean | null
      fixedOptionSize: boolean | null
      hideOptionText: boolean | null
      displayImage: Prisma.JsonValue | null
      footnote: Prisma.JsonValue | null
      subtitle: Prisma.JsonValue | null
      products: Prisma.JsonValue | null
      brandId: string | null
      correctAnswerId: string | null
      questionnaireId: string | null
      questionnaireSubCategory: number | null
      createdAt: Date
      updatedAt: Date
      scaleTopLabel: Prisma.JsonValue | null
      scaleBottomLabel: Prisma.JsonValue | null
      maxOptions: number | null
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type questionsGetPayload<S extends boolean | null | undefined | questionsDefaultArgs> = $Result.GetResult<Prisma.$questionsPayload, S>

  type questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions'], meta: { name: 'questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {questionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionsFindUniqueArgs>(args: SelectSubset<T, questionsFindUniqueArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionsFindFirstArgs>(args?: SelectSubset<T, questionsFindFirstArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionsFindManyArgs>(args?: SelectSubset<T, questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions.
     * @param {questionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends questionsCreateArgs>(args: SelectSubset<T, questionsCreateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {questionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionsCreateManyArgs>(args?: SelectSubset<T, questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questions.
     * @param {questionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends questionsDeleteArgs>(args: SelectSubset<T, questionsDeleteArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions.
     * @param {questionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionsUpdateArgs>(args: SelectSubset<T, questionsUpdateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {questionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionsDeleteManyArgs>(args?: SelectSubset<T, questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionsUpdateManyArgs>(args: SelectSubset<T, questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions.
     * @param {questionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends questionsUpsertArgs>(args: SelectSubset<T, questionsUpsertArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * @param {questionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const questions = await prisma.questions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: questionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Questions.
     * @param {questionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const questions = await prisma.questions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: questionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionsCountArgs>(
      args?: Subset<T, questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionsGroupByArgs['orderBy'] }
        : { orderBy?: questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions model
   */
  readonly fields: questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questionClass<T extends questions$questionClassArgs<ExtArgs> = {}>(args?: Subset<T, questions$questionClassArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    answers<T extends questions$answersArgs<ExtArgs> = {}>(args?: Subset<T, questions$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany"> | Null>
    brand<T extends questions$brandArgs<ExtArgs> = {}>(args?: Subset<T, questions$brandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    questionnaire<T extends questions$questionnaireArgs<ExtArgs> = {}>(args?: Subset<T, questions$questionnaireArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions model
   */ 
  interface questionsFieldRefs {
    readonly id: FieldRef<"questions", 'String'>
    readonly position: FieldRef<"questions", 'Int'>
    readonly question: FieldRef<"questions", 'Json'>
    readonly type: FieldRef<"questions", 'String'>
    readonly options: FieldRef<"questions", 'Json[]'>
    readonly classId: FieldRef<"questions", 'String'>
    readonly categoryId: FieldRef<"questions", 'String'>
    readonly onboarding: FieldRef<"questions", 'Boolean'>
    readonly randomizeOptions: FieldRef<"questions", 'Boolean'>
    readonly fixedOptionSize: FieldRef<"questions", 'Boolean'>
    readonly hideOptionText: FieldRef<"questions", 'Boolean'>
    readonly displayImage: FieldRef<"questions", 'Json'>
    readonly footnote: FieldRef<"questions", 'Json'>
    readonly subtitle: FieldRef<"questions", 'Json'>
    readonly products: FieldRef<"questions", 'Json'>
    readonly brandId: FieldRef<"questions", 'String'>
    readonly correctAnswerId: FieldRef<"questions", 'String'>
    readonly questionnaireId: FieldRef<"questions", 'String'>
    readonly questionnaireSubCategory: FieldRef<"questions", 'Int'>
    readonly createdAt: FieldRef<"questions", 'DateTime'>
    readonly updatedAt: FieldRef<"questions", 'DateTime'>
    readonly scaleTopLabel: FieldRef<"questions", 'Json'>
    readonly scaleBottomLabel: FieldRef<"questions", 'Json'>
    readonly maxOptions: FieldRef<"questions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * questions findUnique
   */
  export type questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findUniqueOrThrow
   */
  export type questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findFirst
   */
  export type questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findFirstOrThrow
   */
  export type questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findMany
   */
  export type questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions create
   */
  export type questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a questions.
     */
    data: XOR<questionsCreateInput, questionsUncheckedCreateInput>
  }

  /**
   * questions createMany
   */
  export type questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionsCreateManyInput | questionsCreateManyInput[]
  }

  /**
   * questions update
   */
  export type questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a questions.
     */
    data: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
    /**
     * Choose, which questions to update.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions updateMany
   */
  export type questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionsWhereInput
  }

  /**
   * questions upsert
   */
  export type questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the questions to update in case it exists.
     */
    where: questionsWhereUniqueInput
    /**
     * In case the questions found by the `where` argument doesn't exist, create a new questions with this data.
     */
    create: XOR<questionsCreateInput, questionsUncheckedCreateInput>
    /**
     * In case the questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
  }

  /**
   * questions delete
   */
  export type questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter which questions to delete.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions deleteMany
   */
  export type questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionsWhereInput
  }

  /**
   * questions findRaw
   */
  export type questionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * questions aggregateRaw
   */
  export type questionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * questions.questionClass
   */
  export type questions$questionClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    where?: question_classesWhereInput
  }

  /**
   * questions.answers
   */
  export type questions$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    where?: answersWhereInput
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    cursor?: answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * questions.brand
   */
  export type questions$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * questions.questionnaire
   */
  export type questions$questionnaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    where?: questionnairesWhereInput
  }

  /**
   * questions without action
   */
  export type questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
  }


  /**
   * Model ratings
   */

  export type AggregateRatings = {
    _count: RatingsCountAggregateOutputType | null
    _avg: RatingsAvgAggregateOutputType | null
    _sum: RatingsSumAggregateOutputType | null
    _min: RatingsMinAggregateOutputType | null
    _max: RatingsMaxAggregateOutputType | null
  }

  export type RatingsAvgAggregateOutputType = {
    rating: number | null
  }

  export type RatingsSumAggregateOutputType = {
    rating: number | null
  }

  export type RatingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingsCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    rating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RatingsAvgAggregateInputType = {
    rating?: true
  }

  export type RatingsSumAggregateInputType = {
    rating?: true
  }

  export type RatingsMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingsMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingsCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RatingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ratings to aggregate.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ratings
    **/
    _count?: true | RatingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingsMaxAggregateInputType
  }

  export type GetRatingsAggregateType<T extends RatingsAggregateArgs> = {
        [P in keyof T & keyof AggregateRatings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRatings[P]>
      : GetScalarType<T[P], AggregateRatings[P]>
  }




  export type ratingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingsWhereInput
    orderBy?: ratingsOrderByWithAggregationInput | ratingsOrderByWithAggregationInput[]
    by: RatingsScalarFieldEnum[] | RatingsScalarFieldEnum
    having?: ratingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingsCountAggregateInputType | true
    _avg?: RatingsAvgAggregateInputType
    _sum?: RatingsSumAggregateInputType
    _min?: RatingsMinAggregateInputType
    _max?: RatingsMaxAggregateInputType
  }

  export type RatingsGroupByOutputType = {
    id: string
    userId: string
    productId: string | null
    rating: number
    createdAt: Date
    updatedAt: Date
    _count: RatingsCountAggregateOutputType | null
    _avg: RatingsAvgAggregateOutputType | null
    _sum: RatingsSumAggregateOutputType | null
    _min: RatingsMinAggregateOutputType | null
    _max: RatingsMaxAggregateOutputType | null
  }

  type GetRatingsGroupByPayload<T extends ratingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingsGroupByOutputType[P]>
            : GetScalarType<T[P], RatingsGroupByOutputType[P]>
        }
      >
    >


  export type ratingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    product?: boolean | ratings$productArgs<ExtArgs>
  }, ExtArgs["result"]["ratings"]>


  export type ratingsSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ratingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    product?: boolean | ratings$productArgs<ExtArgs>
  }

  export type $ratingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ratings"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      product: Prisma.$productsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string | null
      rating: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ratings"]>
    composites: {}
  }

  type ratingsGetPayload<S extends boolean | null | undefined | ratingsDefaultArgs> = $Result.GetResult<Prisma.$ratingsPayload, S>

  type ratingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ratingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RatingsCountAggregateInputType | true
    }

  export interface ratingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ratings'], meta: { name: 'ratings' } }
    /**
     * Find zero or one Ratings that matches the filter.
     * @param {ratingsFindUniqueArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ratingsFindUniqueArgs>(args: SelectSubset<T, ratingsFindUniqueArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ratings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ratingsFindUniqueOrThrowArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ratingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ratingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindFirstArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ratingsFindFirstArgs>(args?: SelectSubset<T, ratingsFindFirstArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ratings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindFirstOrThrowArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ratingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ratingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.ratings.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.ratings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingsWithIdOnly = await prisma.ratings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ratingsFindManyArgs>(args?: SelectSubset<T, ratingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ratings.
     * @param {ratingsCreateArgs} args - Arguments to create a Ratings.
     * @example
     * // Create one Ratings
     * const Ratings = await prisma.ratings.create({
     *   data: {
     *     // ... data to create a Ratings
     *   }
     * })
     * 
     */
    create<T extends ratingsCreateArgs>(args: SelectSubset<T, ratingsCreateArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ratings.
     * @param {ratingsCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const ratings = await prisma.ratings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ratingsCreateManyArgs>(args?: SelectSubset<T, ratingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ratings.
     * @param {ratingsDeleteArgs} args - Arguments to delete one Ratings.
     * @example
     * // Delete one Ratings
     * const Ratings = await prisma.ratings.delete({
     *   where: {
     *     // ... filter to delete one Ratings
     *   }
     * })
     * 
     */
    delete<T extends ratingsDeleteArgs>(args: SelectSubset<T, ratingsDeleteArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ratings.
     * @param {ratingsUpdateArgs} args - Arguments to update one Ratings.
     * @example
     * // Update one Ratings
     * const ratings = await prisma.ratings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ratingsUpdateArgs>(args: SelectSubset<T, ratingsUpdateArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ratings.
     * @param {ratingsDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.ratings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ratingsDeleteManyArgs>(args?: SelectSubset<T, ratingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const ratings = await prisma.ratings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ratingsUpdateManyArgs>(args: SelectSubset<T, ratingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ratings.
     * @param {ratingsUpsertArgs} args - Arguments to update or create a Ratings.
     * @example
     * // Update or create a Ratings
     * const ratings = await prisma.ratings.upsert({
     *   create: {
     *     // ... data to create a Ratings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ratings we want to update
     *   }
     * })
     */
    upsert<T extends ratingsUpsertArgs>(args: SelectSubset<T, ratingsUpsertArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * @param {ratingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ratings = await prisma.ratings.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ratingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Ratings.
     * @param {ratingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ratings = await prisma.ratings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ratingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.ratings.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends ratingsCountArgs>(
      args?: Subset<T, ratingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingsAggregateArgs>(args: Subset<T, RatingsAggregateArgs>): Prisma.PrismaPromise<GetRatingsAggregateType<T>>

    /**
     * Group by Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ratingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ratingsGroupByArgs['orderBy'] }
        : { orderBy?: ratingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ratingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ratings model
   */
  readonly fields: ratingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ratings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ratingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ratings$productArgs<ExtArgs> = {}>(args?: Subset<T, ratings$productArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ratings model
   */ 
  interface ratingsFieldRefs {
    readonly id: FieldRef<"ratings", 'String'>
    readonly userId: FieldRef<"ratings", 'String'>
    readonly productId: FieldRef<"ratings", 'String'>
    readonly rating: FieldRef<"ratings", 'Float'>
    readonly createdAt: FieldRef<"ratings", 'DateTime'>
    readonly updatedAt: FieldRef<"ratings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ratings findUnique
   */
  export type ratingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings findUniqueOrThrow
   */
  export type ratingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings findFirst
   */
  export type ratingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings findFirstOrThrow
   */
  export type ratingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings findMany
   */
  export type ratingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings create
   */
  export type ratingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * The data needed to create a ratings.
     */
    data: XOR<ratingsCreateInput, ratingsUncheckedCreateInput>
  }

  /**
   * ratings createMany
   */
  export type ratingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ratings.
     */
    data: ratingsCreateManyInput | ratingsCreateManyInput[]
  }

  /**
   * ratings update
   */
  export type ratingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * The data needed to update a ratings.
     */
    data: XOR<ratingsUpdateInput, ratingsUncheckedUpdateInput>
    /**
     * Choose, which ratings to update.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings updateMany
   */
  export type ratingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ratings.
     */
    data: XOR<ratingsUpdateManyMutationInput, ratingsUncheckedUpdateManyInput>
    /**
     * Filter which ratings to update
     */
    where?: ratingsWhereInput
  }

  /**
   * ratings upsert
   */
  export type ratingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * The filter to search for the ratings to update in case it exists.
     */
    where: ratingsWhereUniqueInput
    /**
     * In case the ratings found by the `where` argument doesn't exist, create a new ratings with this data.
     */
    create: XOR<ratingsCreateInput, ratingsUncheckedCreateInput>
    /**
     * In case the ratings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ratingsUpdateInput, ratingsUncheckedUpdateInput>
  }

  /**
   * ratings delete
   */
  export type ratingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter which ratings to delete.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings deleteMany
   */
  export type ratingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ratings to delete
     */
    where?: ratingsWhereInput
  }

  /**
   * ratings findRaw
   */
  export type ratingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ratings aggregateRaw
   */
  export type ratingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ratings.product
   */
  export type ratings$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * ratings without action
   */
  export type ratingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    notificationsToken: string | null
    superUser: boolean | null
    hasCompletedOnboarding: boolean | null
    location: string | null
    friendCode: string | null
    lastOpened: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    notificationsToken: string | null
    superUser: boolean | null
    hasCompletedOnboarding: boolean | null
    location: string | null
    friendCode: string | null
    lastOpened: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    myFavourites: number
    createdAt: number
    updatedAt: number
    name: number
    notificationsToken: number
    superUser: number
    hasCompletedOnboarding: number
    location: number
    profilePicture: number
    friendCode: number
    lastOpened: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    notificationsToken?: true
    superUser?: true
    hasCompletedOnboarding?: true
    location?: true
    friendCode?: true
    lastOpened?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    notificationsToken?: true
    superUser?: true
    hasCompletedOnboarding?: true
    location?: true
    friendCode?: true
    lastOpened?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    myFavourites?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    notificationsToken?: true
    superUser?: true
    hasCompletedOnboarding?: true
    location?: true
    profilePicture?: true
    friendCode?: true
    lastOpened?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    myFavourites: JsonValue[]
    createdAt: Date
    updatedAt: Date
    name: string | null
    notificationsToken: string | null
    superUser: boolean | null
    hasCompletedOnboarding: boolean | null
    location: string | null
    profilePicture: JsonValue | null
    friendCode: string | null
    lastOpened: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    myFavourites?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    notificationsToken?: boolean
    superUser?: boolean
    hasCompletedOnboarding?: boolean
    location?: boolean
    profilePicture?: boolean
    friendCode?: boolean
    lastOpened?: boolean
    productionSubmissions?: boolean | users$productionSubmissionsArgs<ExtArgs>
    pushNotificationHistory?: boolean | users$pushNotificationHistoryArgs<ExtArgs>
    ratings?: boolean | users$ratingsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    myFavourites?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    notificationsToken?: boolean
    superUser?: boolean
    hasCompletedOnboarding?: boolean
    location?: boolean
    profilePicture?: boolean
    friendCode?: boolean
    lastOpened?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionSubmissions?: boolean | users$productionSubmissionsArgs<ExtArgs>
    pushNotificationHistory?: boolean | users$pushNotificationHistoryArgs<ExtArgs>
    ratings?: boolean | users$ratingsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      productionSubmissions: Prisma.$production_submissionsPayload<ExtArgs>[]
      pushNotificationHistory: Prisma.$push_notification_historyPayload<ExtArgs>[]
      ratings: Prisma.$ratingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      myFavourites: Prisma.JsonValue[]
      createdAt: Date
      updatedAt: Date
      name: string | null
      notificationsToken: string | null
      superUser: boolean | null
      hasCompletedOnboarding: boolean | null
      location: string | null
      profilePicture: Prisma.JsonValue | null
      friendCode: string | null
      lastOpened: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users = await prisma.users.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: usersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users.
     * @param {usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users = await prisma.users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: usersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionSubmissions<T extends users$productionSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, users$productionSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findMany"> | Null>
    pushNotificationHistory<T extends users$pushNotificationHistoryArgs<ExtArgs> = {}>(args?: Subset<T, users$pushNotificationHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends users$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, users$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly myFavourites: FieldRef<"users", 'Json[]'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly name: FieldRef<"users", 'String'>
    readonly notificationsToken: FieldRef<"users", 'String'>
    readonly superUser: FieldRef<"users", 'Boolean'>
    readonly hasCompletedOnboarding: FieldRef<"users", 'Boolean'>
    readonly location: FieldRef<"users", 'String'>
    readonly profilePicture: FieldRef<"users", 'Json'>
    readonly friendCode: FieldRef<"users", 'String'>
    readonly lastOpened: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users findRaw
   */
  export type usersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users aggregateRaw
   */
  export type usersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users.productionSubmissions
   */
  export type users$productionSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    where?: production_submissionsWhereInput
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    cursor?: production_submissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * users.pushNotificationHistory
   */
  export type users$pushNotificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    where?: push_notification_historyWhereInput
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    cursor?: push_notification_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Push_notification_historyScalarFieldEnum | Push_notification_historyScalarFieldEnum[]
  }

  /**
   * users.ratings
   */
  export type users$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    where?: ratingsWhereInput
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    cursor?: ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const App_versionsScalarFieldEnum: {
    id: 'id',
    version: 'version',
    critical: 'critical',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type App_versionsScalarFieldEnum = (typeof App_versionsScalarFieldEnum)[keyof typeof App_versionsScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    description: 'description',
    images: 'images',
    regularPrice: 'regularPrice',
    deal: 'deal',
    dealPrice: 'dealPrice',
    purchaseUrl: 'purchaseUrl',
    brandId: 'brandId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uniqueDeal: 'uniqueDeal'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const Push_notificationsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    minDaysInactive: 'minDaysInactive',
    oneTimeOnly: 'oneTimeOnly',
    sendAfterInactiveDays: 'sendAfterInactiveDays',
    repeatAfterDays: 'repeatAfterDays',
    daysAfterActivation: 'daysAfterActivation',
    daysBeforeExpiry: 'daysBeforeExpiry'
  };

  export type Push_notificationsScalarFieldEnum = (typeof Push_notificationsScalarFieldEnum)[keyof typeof Push_notificationsScalarFieldEnum]


  export const Push_notification_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    entityId: 'entityId',
    content: 'content',
    title: 'title',
    sentAt: 'sentAt'
  };

  export type Push_notification_historyScalarFieldEnum = (typeof Push_notification_historyScalarFieldEnum)[keyof typeof Push_notification_historyScalarFieldEnum]


  export const BrandsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandsScalarFieldEnum = (typeof BrandsScalarFieldEnum)[keyof typeof BrandsScalarFieldEnum]


  export const Link_visitsScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    createdAt: 'createdAt'
  };

  export type Link_visitsScalarFieldEnum = (typeof Link_visitsScalarFieldEnum)[keyof typeof Link_visitsScalarFieldEnum]


  export const EventsScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventsScalarFieldEnum = (typeof EventsScalarFieldEnum)[keyof typeof EventsScalarFieldEnum]


  export const Question_classesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Question_classesScalarFieldEnum = (typeof Question_classesScalarFieldEnum)[keyof typeof Question_classesScalarFieldEnum]


  export const AnswersScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    answer: 'answer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnswersScalarFieldEnum = (typeof AnswersScalarFieldEnum)[keyof typeof AnswersScalarFieldEnum]


  export const QuestionnairesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionnairesScalarFieldEnum = (typeof QuestionnairesScalarFieldEnum)[keyof typeof QuestionnairesScalarFieldEnum]


  export const Production_submissionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Production_submissionsScalarFieldEnum = (typeof Production_submissionsScalarFieldEnum)[keyof typeof Production_submissionsScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    position: 'position',
    question: 'question',
    type: 'type',
    options: 'options',
    classId: 'classId',
    categoryId: 'categoryId',
    onboarding: 'onboarding',
    randomizeOptions: 'randomizeOptions',
    fixedOptionSize: 'fixedOptionSize',
    hideOptionText: 'hideOptionText',
    displayImage: 'displayImage',
    footnote: 'footnote',
    subtitle: 'subtitle',
    products: 'products',
    brandId: 'brandId',
    correctAnswerId: 'correctAnswerId',
    questionnaireId: 'questionnaireId',
    questionnaireSubCategory: 'questionnaireSubCategory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    scaleTopLabel: 'scaleTopLabel',
    scaleBottomLabel: 'scaleBottomLabel',
    maxOptions: 'maxOptions'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const RatingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    rating: 'rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RatingsScalarFieldEnum = (typeof RatingsScalarFieldEnum)[keyof typeof RatingsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    myFavourites: 'myFavourites',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    notificationsToken: 'notificationsToken',
    superUser: 'superUser',
    hasCompletedOnboarding: 'hasCompletedOnboarding',
    location: 'location',
    profilePicture: 'profilePicture',
    friendCode: 'friendCode',
    lastOpened: 'lastOpened'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type app_versionsWhereInput = {
    AND?: app_versionsWhereInput | app_versionsWhereInput[]
    OR?: app_versionsWhereInput[]
    NOT?: app_versionsWhereInput | app_versionsWhereInput[]
    id?: StringFilter<"app_versions"> | string
    version?: StringFilter<"app_versions"> | string
    critical?: BoolFilter<"app_versions"> | boolean
    createdAt?: DateTimeFilter<"app_versions"> | Date | string
    updatedAt?: DateTimeFilter<"app_versions"> | Date | string
  }

  export type app_versionsOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type app_versionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: app_versionsWhereInput | app_versionsWhereInput[]
    OR?: app_versionsWhereInput[]
    NOT?: app_versionsWhereInput | app_versionsWhereInput[]
    version?: StringFilter<"app_versions"> | string
    critical?: BoolFilter<"app_versions"> | boolean
    createdAt?: DateTimeFilter<"app_versions"> | Date | string
    updatedAt?: DateTimeFilter<"app_versions"> | Date | string
  }, "id">

  export type app_versionsOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: app_versionsCountOrderByAggregateInput
    _max?: app_versionsMaxOrderByAggregateInput
    _min?: app_versionsMinOrderByAggregateInput
  }

  export type app_versionsScalarWhereWithAggregatesInput = {
    AND?: app_versionsScalarWhereWithAggregatesInput | app_versionsScalarWhereWithAggregatesInput[]
    OR?: app_versionsScalarWhereWithAggregatesInput[]
    NOT?: app_versionsScalarWhereWithAggregatesInput | app_versionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"app_versions"> | string
    version?: StringWithAggregatesFilter<"app_versions"> | string
    critical?: BoolWithAggregatesFilter<"app_versions"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"app_versions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"app_versions"> | Date | string
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    id?: StringFilter<"products"> | string
    description?: JsonNullableFilter<"products">
    images?: JsonNullableListFilter<"products">
    regularPrice?: StringNullableFilter<"products"> | string | null
    deal?: StringNullableFilter<"products"> | string | null
    dealPrice?: StringNullableFilter<"products"> | string | null
    purchaseUrl?: StringNullableFilter<"products"> | string | null
    brandId?: StringFilter<"products"> | string
    name?: StringFilter<"products"> | string
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
    uniqueDeal?: BoolNullableFilter<"products"> | boolean | null
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
    linkVisits?: Link_visitsListRelationFilter
    ratings?: RatingsListRelationFilter
    events?: EventsListRelationFilter
  }

  export type productsOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    images?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
    brand?: brandsOrderByWithRelationInput
    linkVisits?: link_visitsOrderByRelationAggregateInput
    ratings?: ratingsOrderByRelationAggregateInput
    events?: eventsOrderByRelationAggregateInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    description?: JsonNullableFilter<"products">
    images?: JsonNullableListFilter<"products">
    regularPrice?: StringNullableFilter<"products"> | string | null
    deal?: StringNullableFilter<"products"> | string | null
    dealPrice?: StringNullableFilter<"products"> | string | null
    purchaseUrl?: StringNullableFilter<"products"> | string | null
    brandId?: StringFilter<"products"> | string
    name?: StringFilter<"products"> | string
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
    uniqueDeal?: BoolNullableFilter<"products"> | boolean | null
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
    linkVisits?: Link_visitsListRelationFilter
    ratings?: RatingsListRelationFilter
    events?: EventsListRelationFilter
  }, "id">

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    images?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
    _count?: productsCountOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"products"> | string
    description?: JsonNullableWithAggregatesFilter<"products">
    images?: JsonNullableListFilter<"products">
    regularPrice?: StringNullableWithAggregatesFilter<"products"> | string | null
    deal?: StringNullableWithAggregatesFilter<"products"> | string | null
    dealPrice?: StringNullableWithAggregatesFilter<"products"> | string | null
    purchaseUrl?: StringNullableWithAggregatesFilter<"products"> | string | null
    brandId?: StringWithAggregatesFilter<"products"> | string
    name?: StringWithAggregatesFilter<"products"> | string
    createdAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
    uniqueDeal?: BoolNullableWithAggregatesFilter<"products"> | boolean | null
  }

  export type push_notificationsWhereInput = {
    AND?: push_notificationsWhereInput | push_notificationsWhereInput[]
    OR?: push_notificationsWhereInput[]
    NOT?: push_notificationsWhereInput | push_notificationsWhereInput[]
    id?: StringFilter<"push_notifications"> | string
    title?: StringNullableFilter<"push_notifications"> | string | null
    content?: StringFilter<"push_notifications"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notifications"> | $Enums.NotificationType | null
    minDaysInactive?: IntNullableFilter<"push_notifications"> | number | null
    oneTimeOnly?: BoolNullableFilter<"push_notifications"> | boolean | null
    sendAfterInactiveDays?: IntNullableFilter<"push_notifications"> | number | null
    repeatAfterDays?: IntNullableFilter<"push_notifications"> | number | null
    daysAfterActivation?: IntNullableFilter<"push_notifications"> | number | null
    daysBeforeExpiry?: IntNullableFilter<"push_notifications"> | number | null
  }

  export type push_notificationsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: push_notificationsWhereInput | push_notificationsWhereInput[]
    OR?: push_notificationsWhereInput[]
    NOT?: push_notificationsWhereInput | push_notificationsWhereInput[]
    title?: StringNullableFilter<"push_notifications"> | string | null
    content?: StringFilter<"push_notifications"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notifications"> | $Enums.NotificationType | null
    minDaysInactive?: IntNullableFilter<"push_notifications"> | number | null
    oneTimeOnly?: BoolNullableFilter<"push_notifications"> | boolean | null
    sendAfterInactiveDays?: IntNullableFilter<"push_notifications"> | number | null
    repeatAfterDays?: IntNullableFilter<"push_notifications"> | number | null
    daysAfterActivation?: IntNullableFilter<"push_notifications"> | number | null
    daysBeforeExpiry?: IntNullableFilter<"push_notifications"> | number | null
  }, "id">

  export type push_notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
    _count?: push_notificationsCountOrderByAggregateInput
    _avg?: push_notificationsAvgOrderByAggregateInput
    _max?: push_notificationsMaxOrderByAggregateInput
    _min?: push_notificationsMinOrderByAggregateInput
    _sum?: push_notificationsSumOrderByAggregateInput
  }

  export type push_notificationsScalarWhereWithAggregatesInput = {
    AND?: push_notificationsScalarWhereWithAggregatesInput | push_notificationsScalarWhereWithAggregatesInput[]
    OR?: push_notificationsScalarWhereWithAggregatesInput[]
    NOT?: push_notificationsScalarWhereWithAggregatesInput | push_notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"push_notifications"> | string
    title?: StringNullableWithAggregatesFilter<"push_notifications"> | string | null
    content?: StringWithAggregatesFilter<"push_notifications"> | string
    type?: EnumNotificationTypeNullableWithAggregatesFilter<"push_notifications"> | $Enums.NotificationType | null
    minDaysInactive?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
    oneTimeOnly?: BoolNullableWithAggregatesFilter<"push_notifications"> | boolean | null
    sendAfterInactiveDays?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
    repeatAfterDays?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
    daysAfterActivation?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
    daysBeforeExpiry?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
  }

  export type push_notification_historyWhereInput = {
    AND?: push_notification_historyWhereInput | push_notification_historyWhereInput[]
    OR?: push_notification_historyWhereInput[]
    NOT?: push_notification_historyWhereInput | push_notification_historyWhereInput[]
    id?: StringFilter<"push_notification_history"> | string
    userId?: StringFilter<"push_notification_history"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notification_history"> | $Enums.NotificationType | null
    entityId?: StringNullableFilter<"push_notification_history"> | string | null
    content?: StringFilter<"push_notification_history"> | string
    title?: StringFilter<"push_notification_history"> | string
    sentAt?: DateTimeFilter<"push_notification_history"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type push_notification_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type push_notification_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: push_notification_historyWhereInput | push_notification_historyWhereInput[]
    OR?: push_notification_historyWhereInput[]
    NOT?: push_notification_historyWhereInput | push_notification_historyWhereInput[]
    userId?: StringFilter<"push_notification_history"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notification_history"> | $Enums.NotificationType | null
    entityId?: StringNullableFilter<"push_notification_history"> | string | null
    content?: StringFilter<"push_notification_history"> | string
    title?: StringFilter<"push_notification_history"> | string
    sentAt?: DateTimeFilter<"push_notification_history"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type push_notification_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
    _count?: push_notification_historyCountOrderByAggregateInput
    _max?: push_notification_historyMaxOrderByAggregateInput
    _min?: push_notification_historyMinOrderByAggregateInput
  }

  export type push_notification_historyScalarWhereWithAggregatesInput = {
    AND?: push_notification_historyScalarWhereWithAggregatesInput | push_notification_historyScalarWhereWithAggregatesInput[]
    OR?: push_notification_historyScalarWhereWithAggregatesInput[]
    NOT?: push_notification_historyScalarWhereWithAggregatesInput | push_notification_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"push_notification_history"> | string
    userId?: StringWithAggregatesFilter<"push_notification_history"> | string
    type?: EnumNotificationTypeNullableWithAggregatesFilter<"push_notification_history"> | $Enums.NotificationType | null
    entityId?: StringNullableWithAggregatesFilter<"push_notification_history"> | string | null
    content?: StringWithAggregatesFilter<"push_notification_history"> | string
    title?: StringWithAggregatesFilter<"push_notification_history"> | string
    sentAt?: DateTimeWithAggregatesFilter<"push_notification_history"> | Date | string
  }

  export type brandsWhereInput = {
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    id?: StringFilter<"brands"> | string
    name?: StringFilter<"brands"> | string
    createdAt?: DateTimeFilter<"brands"> | Date | string
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    products?: ProductsListRelationFilter
    questions?: QuestionsListRelationFilter
  }

  export type brandsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: productsOrderByRelationAggregateInput
    questions?: questionsOrderByRelationAggregateInput
  }

  export type brandsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    name?: StringFilter<"brands"> | string
    createdAt?: DateTimeFilter<"brands"> | Date | string
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    products?: ProductsListRelationFilter
    questions?: QuestionsListRelationFilter
  }, "id">

  export type brandsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: brandsCountOrderByAggregateInput
    _max?: brandsMaxOrderByAggregateInput
    _min?: brandsMinOrderByAggregateInput
  }

  export type brandsScalarWhereWithAggregatesInput = {
    AND?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    OR?: brandsScalarWhereWithAggregatesInput[]
    NOT?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"brands"> | string
    name?: StringWithAggregatesFilter<"brands"> | string
    createdAt?: DateTimeWithAggregatesFilter<"brands"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"brands"> | Date | string
  }

  export type link_visitsWhereInput = {
    AND?: link_visitsWhereInput | link_visitsWhereInput[]
    OR?: link_visitsWhereInput[]
    NOT?: link_visitsWhereInput | link_visitsWhereInput[]
    id?: StringFilter<"link_visits"> | string
    productId?: StringFilter<"link_visits"> | string
    createdAt?: DateTimeFilter<"link_visits"> | Date | string
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }

  export type link_visitsOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    product?: productsOrderByWithRelationInput
  }

  export type link_visitsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: link_visitsWhereInput | link_visitsWhereInput[]
    OR?: link_visitsWhereInput[]
    NOT?: link_visitsWhereInput | link_visitsWhereInput[]
    productId?: StringFilter<"link_visits"> | string
    createdAt?: DateTimeFilter<"link_visits"> | Date | string
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }, "id">

  export type link_visitsOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    _count?: link_visitsCountOrderByAggregateInput
    _max?: link_visitsMaxOrderByAggregateInput
    _min?: link_visitsMinOrderByAggregateInput
  }

  export type link_visitsScalarWhereWithAggregatesInput = {
    AND?: link_visitsScalarWhereWithAggregatesInput | link_visitsScalarWhereWithAggregatesInput[]
    OR?: link_visitsScalarWhereWithAggregatesInput[]
    NOT?: link_visitsScalarWhereWithAggregatesInput | link_visitsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"link_visits"> | string
    productId?: StringWithAggregatesFilter<"link_visits"> | string
    createdAt?: DateTimeWithAggregatesFilter<"link_visits"> | Date | string
  }

  export type eventsWhereInput = {
    AND?: eventsWhereInput | eventsWhereInput[]
    OR?: eventsWhereInput[]
    NOT?: eventsWhereInput | eventsWhereInput[]
    id?: StringFilter<"events"> | string
    productId?: StringFilter<"events"> | string
    createdAt?: DateTimeFilter<"events"> | Date | string
    updatedAt?: DateTimeFilter<"events"> | Date | string
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }

  export type eventsOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: productsOrderByWithRelationInput
  }

  export type eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: eventsWhereInput | eventsWhereInput[]
    OR?: eventsWhereInput[]
    NOT?: eventsWhereInput | eventsWhereInput[]
    productId?: StringFilter<"events"> | string
    createdAt?: DateTimeFilter<"events"> | Date | string
    updatedAt?: DateTimeFilter<"events"> | Date | string
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }, "id">

  export type eventsOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: eventsCountOrderByAggregateInput
    _max?: eventsMaxOrderByAggregateInput
    _min?: eventsMinOrderByAggregateInput
  }

  export type eventsScalarWhereWithAggregatesInput = {
    AND?: eventsScalarWhereWithAggregatesInput | eventsScalarWhereWithAggregatesInput[]
    OR?: eventsScalarWhereWithAggregatesInput[]
    NOT?: eventsScalarWhereWithAggregatesInput | eventsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"events"> | string
    productId?: StringWithAggregatesFilter<"events"> | string
    createdAt?: DateTimeWithAggregatesFilter<"events"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"events"> | Date | string
  }

  export type question_classesWhereInput = {
    AND?: question_classesWhereInput | question_classesWhereInput[]
    OR?: question_classesWhereInput[]
    NOT?: question_classesWhereInput | question_classesWhereInput[]
    id?: StringFilter<"question_classes"> | string
    name?: StringFilter<"question_classes"> | string
    createdAt?: DateTimeFilter<"question_classes"> | Date | string
    updatedAt?: DateTimeFilter<"question_classes"> | Date | string
    questions?: QuestionsListRelationFilter
  }

  export type question_classesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: questionsOrderByRelationAggregateInput
  }

  export type question_classesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: question_classesWhereInput | question_classesWhereInput[]
    OR?: question_classesWhereInput[]
    NOT?: question_classesWhereInput | question_classesWhereInput[]
    name?: StringFilter<"question_classes"> | string
    createdAt?: DateTimeFilter<"question_classes"> | Date | string
    updatedAt?: DateTimeFilter<"question_classes"> | Date | string
    questions?: QuestionsListRelationFilter
  }, "id">

  export type question_classesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: question_classesCountOrderByAggregateInput
    _max?: question_classesMaxOrderByAggregateInput
    _min?: question_classesMinOrderByAggregateInput
  }

  export type question_classesScalarWhereWithAggregatesInput = {
    AND?: question_classesScalarWhereWithAggregatesInput | question_classesScalarWhereWithAggregatesInput[]
    OR?: question_classesScalarWhereWithAggregatesInput[]
    NOT?: question_classesScalarWhereWithAggregatesInput | question_classesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"question_classes"> | string
    name?: StringWithAggregatesFilter<"question_classes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"question_classes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"question_classes"> | Date | string
  }

  export type answersWhereInput = {
    AND?: answersWhereInput | answersWhereInput[]
    OR?: answersWhereInput[]
    NOT?: answersWhereInput | answersWhereInput[]
    id?: StringFilter<"answers"> | string
    questionId?: StringFilter<"answers"> | string
    answer?: JsonFilter<"answers">
    createdAt?: DateTimeFilter<"answers"> | Date | string
    updatedAt?: DateTimeFilter<"answers"> | Date | string
    question?: XOR<QuestionsRelationFilter, questionsWhereInput>
  }

  export type answersOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: questionsOrderByWithRelationInput
  }

  export type answersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: answersWhereInput | answersWhereInput[]
    OR?: answersWhereInput[]
    NOT?: answersWhereInput | answersWhereInput[]
    questionId?: StringFilter<"answers"> | string
    answer?: JsonFilter<"answers">
    createdAt?: DateTimeFilter<"answers"> | Date | string
    updatedAt?: DateTimeFilter<"answers"> | Date | string
    question?: XOR<QuestionsRelationFilter, questionsWhereInput>
  }, "id">

  export type answersOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: answersCountOrderByAggregateInput
    _max?: answersMaxOrderByAggregateInput
    _min?: answersMinOrderByAggregateInput
  }

  export type answersScalarWhereWithAggregatesInput = {
    AND?: answersScalarWhereWithAggregatesInput | answersScalarWhereWithAggregatesInput[]
    OR?: answersScalarWhereWithAggregatesInput[]
    NOT?: answersScalarWhereWithAggregatesInput | answersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"answers"> | string
    questionId?: StringWithAggregatesFilter<"answers"> | string
    answer?: JsonWithAggregatesFilter<"answers">
    createdAt?: DateTimeWithAggregatesFilter<"answers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"answers"> | Date | string
  }

  export type questionnairesWhereInput = {
    AND?: questionnairesWhereInput | questionnairesWhereInput[]
    OR?: questionnairesWhereInput[]
    NOT?: questionnairesWhereInput | questionnairesWhereInput[]
    id?: StringFilter<"questionnaires"> | string
    name?: StringFilter<"questionnaires"> | string
    createdAt?: DateTimeFilter<"questionnaires"> | Date | string
    updatedAt?: DateTimeFilter<"questionnaires"> | Date | string
    questions?: QuestionsListRelationFilter
  }

  export type questionnairesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: questionsOrderByRelationAggregateInput
  }

  export type questionnairesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: questionnairesWhereInput | questionnairesWhereInput[]
    OR?: questionnairesWhereInput[]
    NOT?: questionnairesWhereInput | questionnairesWhereInput[]
    name?: StringFilter<"questionnaires"> | string
    createdAt?: DateTimeFilter<"questionnaires"> | Date | string
    updatedAt?: DateTimeFilter<"questionnaires"> | Date | string
    questions?: QuestionsListRelationFilter
  }, "id">

  export type questionnairesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: questionnairesCountOrderByAggregateInput
    _max?: questionnairesMaxOrderByAggregateInput
    _min?: questionnairesMinOrderByAggregateInput
  }

  export type questionnairesScalarWhereWithAggregatesInput = {
    AND?: questionnairesScalarWhereWithAggregatesInput | questionnairesScalarWhereWithAggregatesInput[]
    OR?: questionnairesScalarWhereWithAggregatesInput[]
    NOT?: questionnairesScalarWhereWithAggregatesInput | questionnairesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"questionnaires"> | string
    name?: StringWithAggregatesFilter<"questionnaires"> | string
    createdAt?: DateTimeWithAggregatesFilter<"questionnaires"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"questionnaires"> | Date | string
  }

  export type production_submissionsWhereInput = {
    AND?: production_submissionsWhereInput | production_submissionsWhereInput[]
    OR?: production_submissionsWhereInput[]
    NOT?: production_submissionsWhereInput | production_submissionsWhereInput[]
    id?: StringFilter<"production_submissions"> | string
    userId?: StringFilter<"production_submissions"> | string
    createdAt?: DateTimeFilter<"production_submissions"> | Date | string
    updatedAt?: DateTimeFilter<"production_submissions"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type production_submissionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type production_submissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: production_submissionsWhereInput | production_submissionsWhereInput[]
    OR?: production_submissionsWhereInput[]
    NOT?: production_submissionsWhereInput | production_submissionsWhereInput[]
    userId?: StringFilter<"production_submissions"> | string
    createdAt?: DateTimeFilter<"production_submissions"> | Date | string
    updatedAt?: DateTimeFilter<"production_submissions"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type production_submissionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: production_submissionsCountOrderByAggregateInput
    _max?: production_submissionsMaxOrderByAggregateInput
    _min?: production_submissionsMinOrderByAggregateInput
  }

  export type production_submissionsScalarWhereWithAggregatesInput = {
    AND?: production_submissionsScalarWhereWithAggregatesInput | production_submissionsScalarWhereWithAggregatesInput[]
    OR?: production_submissionsScalarWhereWithAggregatesInput[]
    NOT?: production_submissionsScalarWhereWithAggregatesInput | production_submissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"production_submissions"> | string
    userId?: StringWithAggregatesFilter<"production_submissions"> | string
    createdAt?: DateTimeWithAggregatesFilter<"production_submissions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"production_submissions"> | Date | string
  }

  export type questionsWhereInput = {
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    id?: StringFilter<"questions"> | string
    position?: IntFilter<"questions"> | number
    question?: JsonFilter<"questions">
    type?: StringFilter<"questions"> | string
    options?: JsonNullableListFilter<"questions">
    classId?: StringNullableFilter<"questions"> | string | null
    categoryId?: StringNullableFilter<"questions"> | string | null
    onboarding?: BoolFilter<"questions"> | boolean
    randomizeOptions?: BoolNullableFilter<"questions"> | boolean | null
    fixedOptionSize?: BoolNullableFilter<"questions"> | boolean | null
    hideOptionText?: BoolNullableFilter<"questions"> | boolean | null
    displayImage?: JsonNullableFilter<"questions">
    footnote?: JsonNullableFilter<"questions">
    subtitle?: JsonNullableFilter<"questions">
    products?: JsonNullableFilter<"questions">
    brandId?: StringNullableFilter<"questions"> | string | null
    correctAnswerId?: StringNullableFilter<"questions"> | string | null
    questionnaireId?: StringNullableFilter<"questions"> | string | null
    questionnaireSubCategory?: IntNullableFilter<"questions"> | number | null
    createdAt?: DateTimeFilter<"questions"> | Date | string
    updatedAt?: DateTimeFilter<"questions"> | Date | string
    scaleTopLabel?: JsonNullableFilter<"questions">
    scaleBottomLabel?: JsonNullableFilter<"questions">
    maxOptions?: IntNullableFilter<"questions"> | number | null
    questionClass?: XOR<Question_classesNullableRelationFilter, question_classesWhereInput> | null
    answers?: AnswersListRelationFilter
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    questionnaire?: XOR<QuestionnairesNullableRelationFilter, questionnairesWhereInput> | null
  }

  export type questionsOrderByWithRelationInput = {
    id?: SortOrder
    position?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    displayImage?: SortOrder
    footnote?: SortOrder
    subtitle?: SortOrder
    products?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scaleTopLabel?: SortOrder
    scaleBottomLabel?: SortOrder
    maxOptions?: SortOrder
    questionClass?: question_classesOrderByWithRelationInput
    answers?: answersOrderByRelationAggregateInput
    brand?: brandsOrderByWithRelationInput
    questionnaire?: questionnairesOrderByWithRelationInput
  }

  export type questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    position?: IntFilter<"questions"> | number
    question?: JsonFilter<"questions">
    type?: StringFilter<"questions"> | string
    options?: JsonNullableListFilter<"questions">
    classId?: StringNullableFilter<"questions"> | string | null
    categoryId?: StringNullableFilter<"questions"> | string | null
    onboarding?: BoolFilter<"questions"> | boolean
    randomizeOptions?: BoolNullableFilter<"questions"> | boolean | null
    fixedOptionSize?: BoolNullableFilter<"questions"> | boolean | null
    hideOptionText?: BoolNullableFilter<"questions"> | boolean | null
    displayImage?: JsonNullableFilter<"questions">
    footnote?: JsonNullableFilter<"questions">
    subtitle?: JsonNullableFilter<"questions">
    products?: JsonNullableFilter<"questions">
    brandId?: StringNullableFilter<"questions"> | string | null
    correctAnswerId?: StringNullableFilter<"questions"> | string | null
    questionnaireId?: StringNullableFilter<"questions"> | string | null
    questionnaireSubCategory?: IntNullableFilter<"questions"> | number | null
    createdAt?: DateTimeFilter<"questions"> | Date | string
    updatedAt?: DateTimeFilter<"questions"> | Date | string
    scaleTopLabel?: JsonNullableFilter<"questions">
    scaleBottomLabel?: JsonNullableFilter<"questions">
    maxOptions?: IntNullableFilter<"questions"> | number | null
    questionClass?: XOR<Question_classesNullableRelationFilter, question_classesWhereInput> | null
    answers?: AnswersListRelationFilter
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    questionnaire?: XOR<QuestionnairesNullableRelationFilter, questionnairesWhereInput> | null
  }, "id">

  export type questionsOrderByWithAggregationInput = {
    id?: SortOrder
    position?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    displayImage?: SortOrder
    footnote?: SortOrder
    subtitle?: SortOrder
    products?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scaleTopLabel?: SortOrder
    scaleBottomLabel?: SortOrder
    maxOptions?: SortOrder
    _count?: questionsCountOrderByAggregateInput
    _avg?: questionsAvgOrderByAggregateInput
    _max?: questionsMaxOrderByAggregateInput
    _min?: questionsMinOrderByAggregateInput
    _sum?: questionsSumOrderByAggregateInput
  }

  export type questionsScalarWhereWithAggregatesInput = {
    AND?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    OR?: questionsScalarWhereWithAggregatesInput[]
    NOT?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"questions"> | string
    position?: IntWithAggregatesFilter<"questions"> | number
    question?: JsonWithAggregatesFilter<"questions">
    type?: StringWithAggregatesFilter<"questions"> | string
    options?: JsonNullableListFilter<"questions">
    classId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    onboarding?: BoolWithAggregatesFilter<"questions"> | boolean
    randomizeOptions?: BoolNullableWithAggregatesFilter<"questions"> | boolean | null
    fixedOptionSize?: BoolNullableWithAggregatesFilter<"questions"> | boolean | null
    hideOptionText?: BoolNullableWithAggregatesFilter<"questions"> | boolean | null
    displayImage?: JsonNullableWithAggregatesFilter<"questions">
    footnote?: JsonNullableWithAggregatesFilter<"questions">
    subtitle?: JsonNullableWithAggregatesFilter<"questions">
    products?: JsonNullableWithAggregatesFilter<"questions">
    brandId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    correctAnswerId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    questionnaireId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    questionnaireSubCategory?: IntNullableWithAggregatesFilter<"questions"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"questions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"questions"> | Date | string
    scaleTopLabel?: JsonNullableWithAggregatesFilter<"questions">
    scaleBottomLabel?: JsonNullableWithAggregatesFilter<"questions">
    maxOptions?: IntNullableWithAggregatesFilter<"questions"> | number | null
  }

  export type ratingsWhereInput = {
    AND?: ratingsWhereInput | ratingsWhereInput[]
    OR?: ratingsWhereInput[]
    NOT?: ratingsWhereInput | ratingsWhereInput[]
    id?: StringFilter<"ratings"> | string
    userId?: StringFilter<"ratings"> | string
    productId?: StringNullableFilter<"ratings"> | string | null
    rating?: FloatFilter<"ratings"> | number
    createdAt?: DateTimeFilter<"ratings"> | Date | string
    updatedAt?: DateTimeFilter<"ratings"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    product?: XOR<ProductsNullableRelationFilter, productsWhereInput> | null
  }

  export type ratingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    product?: productsOrderByWithRelationInput
  }

  export type ratingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_productId?: ratingsUserIdProductIdCompoundUniqueInput
    AND?: ratingsWhereInput | ratingsWhereInput[]
    OR?: ratingsWhereInput[]
    NOT?: ratingsWhereInput | ratingsWhereInput[]
    userId?: StringFilter<"ratings"> | string
    productId?: StringNullableFilter<"ratings"> | string | null
    rating?: FloatFilter<"ratings"> | number
    createdAt?: DateTimeFilter<"ratings"> | Date | string
    updatedAt?: DateTimeFilter<"ratings"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    product?: XOR<ProductsNullableRelationFilter, productsWhereInput> | null
  }, "id" | "userId_productId">

  export type ratingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ratingsCountOrderByAggregateInput
    _avg?: ratingsAvgOrderByAggregateInput
    _max?: ratingsMaxOrderByAggregateInput
    _min?: ratingsMinOrderByAggregateInput
    _sum?: ratingsSumOrderByAggregateInput
  }

  export type ratingsScalarWhereWithAggregatesInput = {
    AND?: ratingsScalarWhereWithAggregatesInput | ratingsScalarWhereWithAggregatesInput[]
    OR?: ratingsScalarWhereWithAggregatesInput[]
    NOT?: ratingsScalarWhereWithAggregatesInput | ratingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ratings"> | string
    userId?: StringWithAggregatesFilter<"ratings"> | string
    productId?: StringNullableWithAggregatesFilter<"ratings"> | string | null
    rating?: FloatWithAggregatesFilter<"ratings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ratings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ratings"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    myFavourites?: JsonNullableListFilter<"users">
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    name?: StringNullableFilter<"users"> | string | null
    notificationsToken?: StringNullableFilter<"users"> | string | null
    superUser?: BoolNullableFilter<"users"> | boolean | null
    hasCompletedOnboarding?: BoolNullableFilter<"users"> | boolean | null
    location?: StringNullableFilter<"users"> | string | null
    profilePicture?: JsonNullableFilter<"users">
    friendCode?: StringNullableFilter<"users"> | string | null
    lastOpened?: DateTimeNullableFilter<"users"> | Date | string | null
    productionSubmissions?: Production_submissionsListRelationFilter
    pushNotificationHistory?: Push_notification_historyListRelationFilter
    ratings?: RatingsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    myFavourites?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    superUser?: SortOrder
    hasCompletedOnboarding?: SortOrder
    location?: SortOrder
    profilePicture?: SortOrder
    friendCode?: SortOrder
    lastOpened?: SortOrder
    productionSubmissions?: production_submissionsOrderByRelationAggregateInput
    pushNotificationHistory?: push_notification_historyOrderByRelationAggregateInput
    ratings?: ratingsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    email?: StringFilter<"users"> | string
    myFavourites?: JsonNullableListFilter<"users">
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    name?: StringNullableFilter<"users"> | string | null
    notificationsToken?: StringNullableFilter<"users"> | string | null
    superUser?: BoolNullableFilter<"users"> | boolean | null
    hasCompletedOnboarding?: BoolNullableFilter<"users"> | boolean | null
    location?: StringNullableFilter<"users"> | string | null
    profilePicture?: JsonNullableFilter<"users">
    friendCode?: StringNullableFilter<"users"> | string | null
    lastOpened?: DateTimeNullableFilter<"users"> | Date | string | null
    productionSubmissions?: Production_submissionsListRelationFilter
    pushNotificationHistory?: Push_notification_historyListRelationFilter
    ratings?: RatingsListRelationFilter
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    myFavourites?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    superUser?: SortOrder
    hasCompletedOnboarding?: SortOrder
    location?: SortOrder
    profilePicture?: SortOrder
    friendCode?: SortOrder
    lastOpened?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    myFavourites?: JsonNullableListFilter<"users">
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    notificationsToken?: StringNullableWithAggregatesFilter<"users"> | string | null
    superUser?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    hasCompletedOnboarding?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    location?: StringNullableWithAggregatesFilter<"users"> | string | null
    profilePicture?: JsonNullableWithAggregatesFilter<"users">
    friendCode?: StringNullableWithAggregatesFilter<"users"> | string | null
    lastOpened?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type app_versionsCreateInput = {
    id?: string
    version: string
    critical: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type app_versionsUncheckedCreateInput = {
    id?: string
    version: string
    critical: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type app_versionsUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    critical?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_versionsUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    critical?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_versionsCreateManyInput = {
    id?: string
    version: string
    critical: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type app_versionsUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    critical?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_versionsUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    critical?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsCreateInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    brand: brandsCreateNestedOneWithoutProductsInput
    linkVisits?: link_visitsCreateNestedManyWithoutProductInput
    ratings?: ratingsCreateNestedManyWithoutProductInput
    events?: eventsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutProductInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutProductInput
    events?: eventsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsUpdateInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: brandsUpdateOneRequiredWithoutProductsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutProductNestedInput
    ratings?: ratingsUpdateManyWithoutProductNestedInput
    events?: eventsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutProductNestedInput
    events?: eventsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productsCreateManyInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
  }

  export type productsUpdateManyMutationInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type productsUncheckedUpdateManyInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type push_notificationsCreateInput = {
    id?: string
    title?: string | null
    content: string
    type?: $Enums.NotificationType | null
    minDaysInactive?: number | null
    oneTimeOnly?: boolean | null
    sendAfterInactiveDays?: number | null
    repeatAfterDays?: number | null
    daysAfterActivation?: number | null
    daysBeforeExpiry?: number | null
  }

  export type push_notificationsUncheckedCreateInput = {
    id?: string
    title?: string | null
    content: string
    type?: $Enums.NotificationType | null
    minDaysInactive?: number | null
    oneTimeOnly?: boolean | null
    sendAfterInactiveDays?: number | null
    repeatAfterDays?: number | null
    daysAfterActivation?: number | null
    daysBeforeExpiry?: number | null
  }

  export type push_notificationsUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    minDaysInactive?: NullableIntFieldUpdateOperationsInput | number | null
    oneTimeOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAfterInactiveDays?: NullableIntFieldUpdateOperationsInput | number | null
    repeatAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    daysAfterActivation?: NullableIntFieldUpdateOperationsInput | number | null
    daysBeforeExpiry?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type push_notificationsUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    minDaysInactive?: NullableIntFieldUpdateOperationsInput | number | null
    oneTimeOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAfterInactiveDays?: NullableIntFieldUpdateOperationsInput | number | null
    repeatAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    daysAfterActivation?: NullableIntFieldUpdateOperationsInput | number | null
    daysBeforeExpiry?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type push_notificationsCreateManyInput = {
    id?: string
    title?: string | null
    content: string
    type?: $Enums.NotificationType | null
    minDaysInactive?: number | null
    oneTimeOnly?: boolean | null
    sendAfterInactiveDays?: number | null
    repeatAfterDays?: number | null
    daysAfterActivation?: number | null
    daysBeforeExpiry?: number | null
  }

  export type push_notificationsUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    minDaysInactive?: NullableIntFieldUpdateOperationsInput | number | null
    oneTimeOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAfterInactiveDays?: NullableIntFieldUpdateOperationsInput | number | null
    repeatAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    daysAfterActivation?: NullableIntFieldUpdateOperationsInput | number | null
    daysBeforeExpiry?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type push_notificationsUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    minDaysInactive?: NullableIntFieldUpdateOperationsInput | number | null
    oneTimeOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAfterInactiveDays?: NullableIntFieldUpdateOperationsInput | number | null
    repeatAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    daysAfterActivation?: NullableIntFieldUpdateOperationsInput | number | null
    daysBeforeExpiry?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type push_notification_historyCreateInput = {
    id?: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
    user: usersCreateNestedOneWithoutPushNotificationHistoryInput
  }

  export type push_notification_historyUncheckedCreateInput = {
    id?: string
    userId: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type push_notification_historyUpdateInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutPushNotificationHistoryNestedInput
  }

  export type push_notification_historyUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyCreateManyInput = {
    id?: string
    userId: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type push_notification_historyUpdateManyMutationInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: productsCreateNestedManyWithoutBrandInput
    questions?: questionsCreateNestedManyWithoutBrandInput
  }

  export type brandsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    questions?: questionsUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: productsUpdateManyWithoutBrandNestedInput
    questions?: questionsUpdateManyWithoutBrandNestedInput
  }

  export type brandsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    questions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type brandsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsCreateInput = {
    id?: string
    createdAt?: Date | string
    product: productsCreateNestedOneWithoutLinkVisitsInput
  }

  export type link_visitsUncheckedCreateInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type link_visitsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productsUpdateOneRequiredWithoutLinkVisitsNestedInput
  }

  export type link_visitsUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsCreateManyInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type link_visitsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: productsCreateNestedOneWithoutEventsInput
  }

  export type eventsUncheckedCreateInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type eventsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productsUpdateOneRequiredWithoutEventsNestedInput
  }

  export type eventsUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventsCreateManyInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type eventsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventsUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_classesCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsCreateNestedManyWithoutQuestionClassInput
  }

  export type question_classesUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsUncheckedCreateNestedManyWithoutQuestionClassInput
  }

  export type question_classesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUpdateManyWithoutQuestionClassNestedInput
  }

  export type question_classesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutQuestionClassNestedInput
  }

  export type question_classesCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type question_classesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_classesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersCreateInput = {
    id?: string
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    question: questionsCreateNestedOneWithoutAnswersInput
  }

  export type answersUncheckedCreateInput = {
    id?: string
    questionId: string
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answersUpdateInput = {
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: questionsUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type answersUncheckedUpdateInput = {
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersCreateManyInput = {
    id?: string
    questionId: string
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answersUpdateManyMutationInput = {
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUncheckedUpdateManyInput = {
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionnairesCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsCreateNestedManyWithoutQuestionnaireInput
  }

  export type questionnairesUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsUncheckedCreateNestedManyWithoutQuestionnaireInput
  }

  export type questionnairesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUpdateManyWithoutQuestionnaireNestedInput
  }

  export type questionnairesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutQuestionnaireNestedInput
  }

  export type questionnairesCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionnairesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionnairesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutProductionSubmissionsInput
  }

  export type production_submissionsUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type production_submissionsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutProductionSubmissionsNestedInput
  }

  export type production_submissionsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type production_submissionsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionsCreateInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    questionClass?: question_classesCreateNestedOneWithoutQuestionsInput
    answers?: answersCreateNestedManyWithoutQuestionInput
    brand?: brandsCreateNestedOneWithoutQuestionsInput
    questionnaire?: questionnairesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    questionClass?: question_classesUpdateOneWithoutQuestionsNestedInput
    answers?: answersUpdateManyWithoutQuestionNestedInput
    brand?: brandsUpdateOneWithoutQuestionsNestedInput
    questionnaire?: questionnairesUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsCreateManyInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type questionsUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questionsUncheckedUpdateManyInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ratingsCreateInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutRatingsInput
    product?: productsCreateNestedOneWithoutRatingsInput
  }

  export type ratingsUncheckedCreateInput = {
    id?: string
    userId: string
    productId?: string | null
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsUpdateInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutRatingsNestedInput
    product?: productsUpdateOneWithoutRatingsNestedInput
  }

  export type ratingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsCreateManyInput = {
    id?: string
    userId: string
    productId?: string | null
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsUpdateManyMutationInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type app_versionsCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type app_versionsMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type app_versionsMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type BrandsRelationFilter = {
    is?: brandsWhereInput
    isNot?: brandsWhereInput
  }

  export type Link_visitsListRelationFilter = {
    every?: link_visitsWhereInput
    some?: link_visitsWhereInput
    none?: link_visitsWhereInput
  }

  export type RatingsListRelationFilter = {
    every?: ratingsWhereInput
    some?: ratingsWhereInput
    none?: ratingsWhereInput
  }

  export type EventsListRelationFilter = {
    every?: eventsWhereInput
    some?: eventsWhereInput
    none?: eventsWhereInput
  }

  export type link_visitsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ratingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type eventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    images?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumNotificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableFilter<$PrismaModel> | $Enums.NotificationType | null
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type push_notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsAvgOrderByAggregateInput = {
    minDaysInactive?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsSumOrderByAggregateInput = {
    minDaysInactive?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type EnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type push_notification_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
  }

  export type push_notification_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
  }

  export type push_notification_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
  }

  export type ProductsListRelationFilter = {
    every?: productsWhereInput
    some?: productsWhereInput
    none?: productsWhereInput
  }

  export type QuestionsListRelationFilter = {
    every?: questionsWhereInput
    some?: questionsWhereInput
    none?: questionsWhereInput
  }

  export type productsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type brandsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductsRelationFilter = {
    is?: productsWhereInput
    isNot?: productsWhereInput
  }

  export type link_visitsCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type link_visitsMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type link_visitsMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type eventsCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type eventsMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type question_classesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type question_classesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type question_classesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type QuestionsRelationFilter = {
    is?: questionsWhereInput
    isNot?: questionsWhereInput
  }

  export type answersCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type answersMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type answersMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type questionnairesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionnairesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionnairesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type production_submissionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type production_submissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type production_submissionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type Question_classesNullableRelationFilter = {
    is?: question_classesWhereInput | null
    isNot?: question_classesWhereInput | null
  }

  export type AnswersListRelationFilter = {
    every?: answersWhereInput
    some?: answersWhereInput
    none?: answersWhereInput
  }

  export type BrandsNullableRelationFilter = {
    is?: brandsWhereInput | null
    isNot?: brandsWhereInput | null
  }

  export type QuestionnairesNullableRelationFilter = {
    is?: questionnairesWhereInput | null
    isNot?: questionnairesWhereInput | null
  }

  export type answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionsCountOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    displayImage?: SortOrder
    footnote?: SortOrder
    subtitle?: SortOrder
    products?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scaleTopLabel?: SortOrder
    scaleBottomLabel?: SortOrder
    maxOptions?: SortOrder
  }

  export type questionsAvgOrderByAggregateInput = {
    position?: SortOrder
    questionnaireSubCategory?: SortOrder
    maxOptions?: SortOrder
  }

  export type questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    type?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxOptions?: SortOrder
  }

  export type questionsMinOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    type?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxOptions?: SortOrder
  }

  export type questionsSumOrderByAggregateInput = {
    position?: SortOrder
    questionnaireSubCategory?: SortOrder
    maxOptions?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProductsNullableRelationFilter = {
    is?: productsWhereInput | null
    isNot?: productsWhereInput | null
  }

  export type ratingsUserIdProductIdCompoundUniqueInput = {
    userId: string
    productId: string
  }

  export type ratingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ratingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type Production_submissionsListRelationFilter = {
    every?: production_submissionsWhereInput
    some?: production_submissionsWhereInput
    none?: production_submissionsWhereInput
  }

  export type Push_notification_historyListRelationFilter = {
    every?: push_notification_historyWhereInput
    some?: push_notification_historyWhereInput
    none?: push_notification_historyWhereInput
  }

  export type production_submissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type push_notification_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    myFavourites?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    superUser?: SortOrder
    hasCompletedOnboarding?: SortOrder
    location?: SortOrder
    profilePicture?: SortOrder
    friendCode?: SortOrder
    lastOpened?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    superUser?: SortOrder
    hasCompletedOnboarding?: SortOrder
    location?: SortOrder
    friendCode?: SortOrder
    lastOpened?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    superUser?: SortOrder
    hasCompletedOnboarding?: SortOrder
    location?: SortOrder
    friendCode?: SortOrder
    lastOpened?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type productsCreateimagesInput = {
    set: InputJsonValue[]
  }

  export type brandsCreateNestedOneWithoutProductsInput = {
    create?: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductsInput
    connect?: brandsWhereUniqueInput
  }

  export type link_visitsCreateNestedManyWithoutProductInput = {
    create?: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput> | link_visitsCreateWithoutProductInput[] | link_visitsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutProductInput | link_visitsCreateOrConnectWithoutProductInput[]
    createMany?: link_visitsCreateManyProductInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type ratingsCreateNestedManyWithoutProductInput = {
    create?: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput> | ratingsCreateWithoutProductInput[] | ratingsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutProductInput | ratingsCreateOrConnectWithoutProductInput[]
    createMany?: ratingsCreateManyProductInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type eventsCreateNestedManyWithoutProductInput = {
    create?: XOR<eventsCreateWithoutProductInput, eventsUncheckedCreateWithoutProductInput> | eventsCreateWithoutProductInput[] | eventsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutProductInput | eventsCreateOrConnectWithoutProductInput[]
    createMany?: eventsCreateManyProductInputEnvelope
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
  }

  export type link_visitsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput> | link_visitsCreateWithoutProductInput[] | link_visitsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutProductInput | link_visitsCreateOrConnectWithoutProductInput[]
    createMany?: link_visitsCreateManyProductInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type ratingsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput> | ratingsCreateWithoutProductInput[] | ratingsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutProductInput | ratingsCreateOrConnectWithoutProductInput[]
    createMany?: ratingsCreateManyProductInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type eventsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<eventsCreateWithoutProductInput, eventsUncheckedCreateWithoutProductInput> | eventsCreateWithoutProductInput[] | eventsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutProductInput | eventsCreateOrConnectWithoutProductInput[]
    createMany?: eventsCreateManyProductInputEnvelope
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
  }

  export type productsUpdateimagesInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type brandsUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductsInput
    upsert?: brandsUpsertWithoutProductsInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutProductsInput, brandsUpdateWithoutProductsInput>, brandsUncheckedUpdateWithoutProductsInput>
  }

  export type link_visitsUpdateManyWithoutProductNestedInput = {
    create?: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput> | link_visitsCreateWithoutProductInput[] | link_visitsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutProductInput | link_visitsCreateOrConnectWithoutProductInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutProductInput | link_visitsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: link_visitsCreateManyProductInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutProductInput | link_visitsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutProductInput | link_visitsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type ratingsUpdateManyWithoutProductNestedInput = {
    create?: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput> | ratingsCreateWithoutProductInput[] | ratingsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutProductInput | ratingsCreateOrConnectWithoutProductInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutProductInput | ratingsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ratingsCreateManyProductInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutProductInput | ratingsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutProductInput | ratingsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type eventsUpdateManyWithoutProductNestedInput = {
    create?: XOR<eventsCreateWithoutProductInput, eventsUncheckedCreateWithoutProductInput> | eventsCreateWithoutProductInput[] | eventsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutProductInput | eventsCreateOrConnectWithoutProductInput[]
    upsert?: eventsUpsertWithWhereUniqueWithoutProductInput | eventsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: eventsCreateManyProductInputEnvelope
    set?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    disconnect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    delete?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    update?: eventsUpdateWithWhereUniqueWithoutProductInput | eventsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: eventsUpdateManyWithWhereWithoutProductInput | eventsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: eventsScalarWhereInput | eventsScalarWhereInput[]
  }

  export type link_visitsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput> | link_visitsCreateWithoutProductInput[] | link_visitsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutProductInput | link_visitsCreateOrConnectWithoutProductInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutProductInput | link_visitsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: link_visitsCreateManyProductInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutProductInput | link_visitsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutProductInput | link_visitsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type ratingsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput> | ratingsCreateWithoutProductInput[] | ratingsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutProductInput | ratingsCreateOrConnectWithoutProductInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutProductInput | ratingsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ratingsCreateManyProductInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutProductInput | ratingsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutProductInput | ratingsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type eventsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<eventsCreateWithoutProductInput, eventsUncheckedCreateWithoutProductInput> | eventsCreateWithoutProductInput[] | eventsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: eventsCreateOrConnectWithoutProductInput | eventsCreateOrConnectWithoutProductInput[]
    upsert?: eventsUpsertWithWhereUniqueWithoutProductInput | eventsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: eventsCreateManyProductInputEnvelope
    set?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    disconnect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    delete?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    connect?: eventsWhereUniqueInput | eventsWhereUniqueInput[]
    update?: eventsUpdateWithWhereUniqueWithoutProductInput | eventsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: eventsUpdateManyWithWhereWithoutProductInput | eventsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: eventsScalarWhereInput | eventsScalarWhereInput[]
  }

  export type NullableEnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType | null
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type usersCreateNestedOneWithoutPushNotificationHistoryInput = {
    create?: XOR<usersCreateWithoutPushNotificationHistoryInput, usersUncheckedCreateWithoutPushNotificationHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutPushNotificationHistoryInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPushNotificationHistoryNestedInput = {
    create?: XOR<usersCreateWithoutPushNotificationHistoryInput, usersUncheckedCreateWithoutPushNotificationHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutPushNotificationHistoryInput
    upsert?: usersUpsertWithoutPushNotificationHistoryInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPushNotificationHistoryInput, usersUpdateWithoutPushNotificationHistoryInput>, usersUncheckedUpdateWithoutPushNotificationHistoryInput>
  }

  export type productsCreateNestedManyWithoutBrandInput = {
    create?: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput> | productsCreateWithoutBrandInput[] | productsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandInput | productsCreateOrConnectWithoutBrandInput[]
    createMany?: productsCreateManyBrandInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type questionsCreateNestedManyWithoutBrandInput = {
    create?: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput> | questionsCreateWithoutBrandInput[] | questionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutBrandInput | questionsCreateOrConnectWithoutBrandInput[]
    createMany?: questionsCreateManyBrandInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput> | productsCreateWithoutBrandInput[] | productsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandInput | productsCreateOrConnectWithoutBrandInput[]
    createMany?: productsCreateManyBrandInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type questionsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput> | questionsCreateWithoutBrandInput[] | questionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutBrandInput | questionsCreateOrConnectWithoutBrandInput[]
    createMany?: questionsCreateManyBrandInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type productsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput> | productsCreateWithoutBrandInput[] | productsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandInput | productsCreateOrConnectWithoutBrandInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutBrandInput | productsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: productsCreateManyBrandInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutBrandInput | productsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: productsUpdateManyWithWhereWithoutBrandInput | productsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type questionsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput> | questionsCreateWithoutBrandInput[] | questionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutBrandInput | questionsCreateOrConnectWithoutBrandInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutBrandInput | questionsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: questionsCreateManyBrandInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutBrandInput | questionsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutBrandInput | questionsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput> | productsCreateWithoutBrandInput[] | productsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandInput | productsCreateOrConnectWithoutBrandInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutBrandInput | productsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: productsCreateManyBrandInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutBrandInput | productsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: productsUpdateManyWithWhereWithoutBrandInput | productsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type questionsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput> | questionsCreateWithoutBrandInput[] | questionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutBrandInput | questionsCreateOrConnectWithoutBrandInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutBrandInput | questionsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: questionsCreateManyBrandInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutBrandInput | questionsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutBrandInput | questionsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type productsCreateNestedOneWithoutLinkVisitsInput = {
    create?: XOR<productsCreateWithoutLinkVisitsInput, productsUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: productsCreateOrConnectWithoutLinkVisitsInput
    connect?: productsWhereUniqueInput
  }

  export type productsUpdateOneRequiredWithoutLinkVisitsNestedInput = {
    create?: XOR<productsCreateWithoutLinkVisitsInput, productsUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: productsCreateOrConnectWithoutLinkVisitsInput
    upsert?: productsUpsertWithoutLinkVisitsInput
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutLinkVisitsInput, productsUpdateWithoutLinkVisitsInput>, productsUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type productsCreateNestedOneWithoutEventsInput = {
    create?: XOR<productsCreateWithoutEventsInput, productsUncheckedCreateWithoutEventsInput>
    connectOrCreate?: productsCreateOrConnectWithoutEventsInput
    connect?: productsWhereUniqueInput
  }

  export type productsUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<productsCreateWithoutEventsInput, productsUncheckedCreateWithoutEventsInput>
    connectOrCreate?: productsCreateOrConnectWithoutEventsInput
    upsert?: productsUpsertWithoutEventsInput
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutEventsInput, productsUpdateWithoutEventsInput>, productsUncheckedUpdateWithoutEventsInput>
  }

  export type questionsCreateNestedManyWithoutQuestionClassInput = {
    create?: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput> | questionsCreateWithoutQuestionClassInput[] | questionsUncheckedCreateWithoutQuestionClassInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionClassInput | questionsCreateOrConnectWithoutQuestionClassInput[]
    createMany?: questionsCreateManyQuestionClassInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUncheckedCreateNestedManyWithoutQuestionClassInput = {
    create?: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput> | questionsCreateWithoutQuestionClassInput[] | questionsUncheckedCreateWithoutQuestionClassInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionClassInput | questionsCreateOrConnectWithoutQuestionClassInput[]
    createMany?: questionsCreateManyQuestionClassInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUpdateManyWithoutQuestionClassNestedInput = {
    create?: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput> | questionsCreateWithoutQuestionClassInput[] | questionsUncheckedCreateWithoutQuestionClassInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionClassInput | questionsCreateOrConnectWithoutQuestionClassInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestionClassInput | questionsUpsertWithWhereUniqueWithoutQuestionClassInput[]
    createMany?: questionsCreateManyQuestionClassInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestionClassInput | questionsUpdateWithWhereUniqueWithoutQuestionClassInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestionClassInput | questionsUpdateManyWithWhereWithoutQuestionClassInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type questionsUncheckedUpdateManyWithoutQuestionClassNestedInput = {
    create?: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput> | questionsCreateWithoutQuestionClassInput[] | questionsUncheckedCreateWithoutQuestionClassInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionClassInput | questionsCreateOrConnectWithoutQuestionClassInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestionClassInput | questionsUpsertWithWhereUniqueWithoutQuestionClassInput[]
    createMany?: questionsCreateManyQuestionClassInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestionClassInput | questionsUpdateWithWhereUniqueWithoutQuestionClassInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestionClassInput | questionsUpdateManyWithWhereWithoutQuestionClassInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type questionsCreateNestedOneWithoutAnswersInput = {
    create?: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: questionsCreateOrConnectWithoutAnswersInput
    connect?: questionsWhereUniqueInput
  }

  export type questionsUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: questionsCreateOrConnectWithoutAnswersInput
    upsert?: questionsUpsertWithoutAnswersInput
    connect?: questionsWhereUniqueInput
    update?: XOR<XOR<questionsUpdateToOneWithWhereWithoutAnswersInput, questionsUpdateWithoutAnswersInput>, questionsUncheckedUpdateWithoutAnswersInput>
  }

  export type questionsCreateNestedManyWithoutQuestionnaireInput = {
    create?: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput> | questionsCreateWithoutQuestionnaireInput[] | questionsUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionnaireInput | questionsCreateOrConnectWithoutQuestionnaireInput[]
    createMany?: questionsCreateManyQuestionnaireInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUncheckedCreateNestedManyWithoutQuestionnaireInput = {
    create?: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput> | questionsCreateWithoutQuestionnaireInput[] | questionsUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionnaireInput | questionsCreateOrConnectWithoutQuestionnaireInput[]
    createMany?: questionsCreateManyQuestionnaireInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUpdateManyWithoutQuestionnaireNestedInput = {
    create?: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput> | questionsCreateWithoutQuestionnaireInput[] | questionsUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionnaireInput | questionsCreateOrConnectWithoutQuestionnaireInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestionnaireInput | questionsUpsertWithWhereUniqueWithoutQuestionnaireInput[]
    createMany?: questionsCreateManyQuestionnaireInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestionnaireInput | questionsUpdateWithWhereUniqueWithoutQuestionnaireInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestionnaireInput | questionsUpdateManyWithWhereWithoutQuestionnaireInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type questionsUncheckedUpdateManyWithoutQuestionnaireNestedInput = {
    create?: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput> | questionsCreateWithoutQuestionnaireInput[] | questionsUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionnaireInput | questionsCreateOrConnectWithoutQuestionnaireInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestionnaireInput | questionsUpsertWithWhereUniqueWithoutQuestionnaireInput[]
    createMany?: questionsCreateManyQuestionnaireInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestionnaireInput | questionsUpdateWithWhereUniqueWithoutQuestionnaireInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestionnaireInput | questionsUpdateManyWithWhereWithoutQuestionnaireInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutProductionSubmissionsInput = {
    create?: XOR<usersCreateWithoutProductionSubmissionsInput, usersUncheckedCreateWithoutProductionSubmissionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutProductionSubmissionsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutProductionSubmissionsNestedInput = {
    create?: XOR<usersCreateWithoutProductionSubmissionsInput, usersUncheckedCreateWithoutProductionSubmissionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutProductionSubmissionsInput
    upsert?: usersUpsertWithoutProductionSubmissionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProductionSubmissionsInput, usersUpdateWithoutProductionSubmissionsInput>, usersUncheckedUpdateWithoutProductionSubmissionsInput>
  }

  export type questionsCreateoptionsInput = {
    set: InputJsonValue[]
  }

  export type question_classesCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<question_classesCreateWithoutQuestionsInput, question_classesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: question_classesCreateOrConnectWithoutQuestionsInput
    connect?: question_classesWhereUniqueInput
  }

  export type answersCreateNestedManyWithoutQuestionInput = {
    create?: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput> | answersCreateWithoutQuestionInput[] | answersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionInput | answersCreateOrConnectWithoutQuestionInput[]
    createMany?: answersCreateManyQuestionInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<brandsCreateWithoutQuestionsInput, brandsUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutQuestionsInput
    connect?: brandsWhereUniqueInput
  }

  export type questionnairesCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<questionnairesCreateWithoutQuestionsInput, questionnairesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: questionnairesCreateOrConnectWithoutQuestionsInput
    connect?: questionnairesWhereUniqueInput
  }

  export type answersUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput> | answersCreateWithoutQuestionInput[] | answersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionInput | answersCreateOrConnectWithoutQuestionInput[]
    createMany?: answersCreateManyQuestionInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type questionsUpdateoptionsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type question_classesUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<question_classesCreateWithoutQuestionsInput, question_classesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: question_classesCreateOrConnectWithoutQuestionsInput
    upsert?: question_classesUpsertWithoutQuestionsInput
    disconnect?: boolean
    delete?: question_classesWhereInput | boolean
    connect?: question_classesWhereUniqueInput
    update?: XOR<XOR<question_classesUpdateToOneWithWhereWithoutQuestionsInput, question_classesUpdateWithoutQuestionsInput>, question_classesUncheckedUpdateWithoutQuestionsInput>
  }

  export type answersUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput> | answersCreateWithoutQuestionInput[] | answersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionInput | answersCreateOrConnectWithoutQuestionInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutQuestionInput | answersUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: answersCreateManyQuestionInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutQuestionInput | answersUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: answersUpdateManyWithWhereWithoutQuestionInput | answersUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<brandsCreateWithoutQuestionsInput, brandsUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutQuestionsInput
    upsert?: brandsUpsertWithoutQuestionsInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutQuestionsInput, brandsUpdateWithoutQuestionsInput>, brandsUncheckedUpdateWithoutQuestionsInput>
  }

  export type questionnairesUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<questionnairesCreateWithoutQuestionsInput, questionnairesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: questionnairesCreateOrConnectWithoutQuestionsInput
    upsert?: questionnairesUpsertWithoutQuestionsInput
    disconnect?: boolean
    delete?: questionnairesWhereInput | boolean
    connect?: questionnairesWhereUniqueInput
    update?: XOR<XOR<questionnairesUpdateToOneWithWhereWithoutQuestionsInput, questionnairesUpdateWithoutQuestionsInput>, questionnairesUncheckedUpdateWithoutQuestionsInput>
  }

  export type answersUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput> | answersCreateWithoutQuestionInput[] | answersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionInput | answersCreateOrConnectWithoutQuestionInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutQuestionInput | answersUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: answersCreateManyQuestionInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutQuestionInput | answersUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: answersUpdateManyWithWhereWithoutQuestionInput | answersUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutRatingsInput = {
    create?: XOR<usersCreateWithoutRatingsInput, usersUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRatingsInput
    connect?: usersWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutRatingsInput = {
    create?: XOR<productsCreateWithoutRatingsInput, productsUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: productsCreateOrConnectWithoutRatingsInput
    connect?: productsWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<usersCreateWithoutRatingsInput, usersUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRatingsInput
    upsert?: usersUpsertWithoutRatingsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRatingsInput, usersUpdateWithoutRatingsInput>, usersUncheckedUpdateWithoutRatingsInput>
  }

  export type productsUpdateOneWithoutRatingsNestedInput = {
    create?: XOR<productsCreateWithoutRatingsInput, productsUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: productsCreateOrConnectWithoutRatingsInput
    upsert?: productsUpsertWithoutRatingsInput
    disconnect?: boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutRatingsInput, productsUpdateWithoutRatingsInput>, productsUncheckedUpdateWithoutRatingsInput>
  }

  export type usersCreatemyFavouritesInput = {
    set: InputJsonValue[]
  }

  export type production_submissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput> | production_submissionsCreateWithoutUserInput[] | production_submissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutUserInput | production_submissionsCreateOrConnectWithoutUserInput[]
    createMany?: production_submissionsCreateManyUserInputEnvelope
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
  }

  export type push_notification_historyCreateNestedManyWithoutUserInput = {
    create?: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput> | push_notification_historyCreateWithoutUserInput[] | push_notification_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: push_notification_historyCreateOrConnectWithoutUserInput | push_notification_historyCreateOrConnectWithoutUserInput[]
    createMany?: push_notification_historyCreateManyUserInputEnvelope
    connect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
  }

  export type ratingsCreateNestedManyWithoutUserInput = {
    create?: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput> | ratingsCreateWithoutUserInput[] | ratingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutUserInput | ratingsCreateOrConnectWithoutUserInput[]
    createMany?: ratingsCreateManyUserInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type production_submissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput> | production_submissionsCreateWithoutUserInput[] | production_submissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutUserInput | production_submissionsCreateOrConnectWithoutUserInput[]
    createMany?: production_submissionsCreateManyUserInputEnvelope
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
  }

  export type push_notification_historyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput> | push_notification_historyCreateWithoutUserInput[] | push_notification_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: push_notification_historyCreateOrConnectWithoutUserInput | push_notification_historyCreateOrConnectWithoutUserInput[]
    createMany?: push_notification_historyCreateManyUserInputEnvelope
    connect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
  }

  export type ratingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput> | ratingsCreateWithoutUserInput[] | ratingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutUserInput | ratingsCreateOrConnectWithoutUserInput[]
    createMany?: ratingsCreateManyUserInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type usersUpdatemyFavouritesInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type production_submissionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput> | production_submissionsCreateWithoutUserInput[] | production_submissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutUserInput | production_submissionsCreateOrConnectWithoutUserInput[]
    upsert?: production_submissionsUpsertWithWhereUniqueWithoutUserInput | production_submissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: production_submissionsCreateManyUserInputEnvelope
    set?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    disconnect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    delete?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    update?: production_submissionsUpdateWithWhereUniqueWithoutUserInput | production_submissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: production_submissionsUpdateManyWithWhereWithoutUserInput | production_submissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
  }

  export type push_notification_historyUpdateManyWithoutUserNestedInput = {
    create?: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput> | push_notification_historyCreateWithoutUserInput[] | push_notification_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: push_notification_historyCreateOrConnectWithoutUserInput | push_notification_historyCreateOrConnectWithoutUserInput[]
    upsert?: push_notification_historyUpsertWithWhereUniqueWithoutUserInput | push_notification_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: push_notification_historyCreateManyUserInputEnvelope
    set?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    disconnect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    delete?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    connect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    update?: push_notification_historyUpdateWithWhereUniqueWithoutUserInput | push_notification_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: push_notification_historyUpdateManyWithWhereWithoutUserInput | push_notification_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: push_notification_historyScalarWhereInput | push_notification_historyScalarWhereInput[]
  }

  export type ratingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput> | ratingsCreateWithoutUserInput[] | ratingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutUserInput | ratingsCreateOrConnectWithoutUserInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutUserInput | ratingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ratingsCreateManyUserInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutUserInput | ratingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutUserInput | ratingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type production_submissionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput> | production_submissionsCreateWithoutUserInput[] | production_submissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutUserInput | production_submissionsCreateOrConnectWithoutUserInput[]
    upsert?: production_submissionsUpsertWithWhereUniqueWithoutUserInput | production_submissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: production_submissionsCreateManyUserInputEnvelope
    set?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    disconnect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    delete?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    update?: production_submissionsUpdateWithWhereUniqueWithoutUserInput | production_submissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: production_submissionsUpdateManyWithWhereWithoutUserInput | production_submissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
  }

  export type push_notification_historyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput> | push_notification_historyCreateWithoutUserInput[] | push_notification_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: push_notification_historyCreateOrConnectWithoutUserInput | push_notification_historyCreateOrConnectWithoutUserInput[]
    upsert?: push_notification_historyUpsertWithWhereUniqueWithoutUserInput | push_notification_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: push_notification_historyCreateManyUserInputEnvelope
    set?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    disconnect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    delete?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    connect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    update?: push_notification_historyUpdateWithWhereUniqueWithoutUserInput | push_notification_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: push_notification_historyUpdateManyWithWhereWithoutUserInput | push_notification_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: push_notification_historyScalarWhereInput | push_notification_historyScalarWhereInput[]
  }

  export type ratingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput> | ratingsCreateWithoutUserInput[] | ratingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutUserInput | ratingsCreateOrConnectWithoutUserInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutUserInput | ratingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ratingsCreateManyUserInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutUserInput | ratingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutUserInput | ratingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumNotificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableFilter<$PrismaModel> | $Enums.NotificationType | null
    isSet?: boolean
  }

  export type NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type brandsCreateWithoutProductsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsCreateNestedManyWithoutBrandInput
  }

  export type brandsUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandsCreateOrConnectWithoutProductsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
  }

  export type link_visitsCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
  }

  export type link_visitsUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
  }

  export type link_visitsCreateOrConnectWithoutProductInput = {
    where: link_visitsWhereUniqueInput
    create: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput>
  }

  export type link_visitsCreateManyProductInputEnvelope = {
    data: link_visitsCreateManyProductInput | link_visitsCreateManyProductInput[]
  }

  export type ratingsCreateWithoutProductInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutRatingsInput
  }

  export type ratingsUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsCreateOrConnectWithoutProductInput = {
    where: ratingsWhereUniqueInput
    create: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput>
  }

  export type ratingsCreateManyProductInputEnvelope = {
    data: ratingsCreateManyProductInput | ratingsCreateManyProductInput[]
  }

  export type eventsCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type eventsUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type eventsCreateOrConnectWithoutProductInput = {
    where: eventsWhereUniqueInput
    create: XOR<eventsCreateWithoutProductInput, eventsUncheckedCreateWithoutProductInput>
  }

  export type eventsCreateManyProductInputEnvelope = {
    data: eventsCreateManyProductInput | eventsCreateManyProductInput[]
  }

  export type brandsUpsertWithoutProductsInput = {
    update: XOR<brandsUpdateWithoutProductsInput, brandsUncheckedUpdateWithoutProductsInput>
    create: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutProductsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutProductsInput, brandsUncheckedUpdateWithoutProductsInput>
  }

  export type brandsUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUpdateManyWithoutBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type link_visitsUpsertWithWhereUniqueWithoutProductInput = {
    where: link_visitsWhereUniqueInput
    update: XOR<link_visitsUpdateWithoutProductInput, link_visitsUncheckedUpdateWithoutProductInput>
    create: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput>
  }

  export type link_visitsUpdateWithWhereUniqueWithoutProductInput = {
    where: link_visitsWhereUniqueInput
    data: XOR<link_visitsUpdateWithoutProductInput, link_visitsUncheckedUpdateWithoutProductInput>
  }

  export type link_visitsUpdateManyWithWhereWithoutProductInput = {
    where: link_visitsScalarWhereInput
    data: XOR<link_visitsUpdateManyMutationInput, link_visitsUncheckedUpdateManyWithoutProductInput>
  }

  export type link_visitsScalarWhereInput = {
    AND?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
    OR?: link_visitsScalarWhereInput[]
    NOT?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
    id?: StringFilter<"link_visits"> | string
    productId?: StringFilter<"link_visits"> | string
    createdAt?: DateTimeFilter<"link_visits"> | Date | string
  }

  export type ratingsUpsertWithWhereUniqueWithoutProductInput = {
    where: ratingsWhereUniqueInput
    update: XOR<ratingsUpdateWithoutProductInput, ratingsUncheckedUpdateWithoutProductInput>
    create: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput>
  }

  export type ratingsUpdateWithWhereUniqueWithoutProductInput = {
    where: ratingsWhereUniqueInput
    data: XOR<ratingsUpdateWithoutProductInput, ratingsUncheckedUpdateWithoutProductInput>
  }

  export type ratingsUpdateManyWithWhereWithoutProductInput = {
    where: ratingsScalarWhereInput
    data: XOR<ratingsUpdateManyMutationInput, ratingsUncheckedUpdateManyWithoutProductInput>
  }

  export type ratingsScalarWhereInput = {
    AND?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
    OR?: ratingsScalarWhereInput[]
    NOT?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
    id?: StringFilter<"ratings"> | string
    userId?: StringFilter<"ratings"> | string
    productId?: StringNullableFilter<"ratings"> | string | null
    rating?: FloatFilter<"ratings"> | number
    createdAt?: DateTimeFilter<"ratings"> | Date | string
    updatedAt?: DateTimeFilter<"ratings"> | Date | string
  }

  export type eventsUpsertWithWhereUniqueWithoutProductInput = {
    where: eventsWhereUniqueInput
    update: XOR<eventsUpdateWithoutProductInput, eventsUncheckedUpdateWithoutProductInput>
    create: XOR<eventsCreateWithoutProductInput, eventsUncheckedCreateWithoutProductInput>
  }

  export type eventsUpdateWithWhereUniqueWithoutProductInput = {
    where: eventsWhereUniqueInput
    data: XOR<eventsUpdateWithoutProductInput, eventsUncheckedUpdateWithoutProductInput>
  }

  export type eventsUpdateManyWithWhereWithoutProductInput = {
    where: eventsScalarWhereInput
    data: XOR<eventsUpdateManyMutationInput, eventsUncheckedUpdateManyWithoutProductInput>
  }

  export type eventsScalarWhereInput = {
    AND?: eventsScalarWhereInput | eventsScalarWhereInput[]
    OR?: eventsScalarWhereInput[]
    NOT?: eventsScalarWhereInput | eventsScalarWhereInput[]
    id?: StringFilter<"events"> | string
    productId?: StringFilter<"events"> | string
    createdAt?: DateTimeFilter<"events"> | Date | string
    updatedAt?: DateTimeFilter<"events"> | Date | string
  }

  export type usersCreateWithoutPushNotificationHistoryInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutPushNotificationHistoryInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutPushNotificationHistoryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPushNotificationHistoryInput, usersUncheckedCreateWithoutPushNotificationHistoryInput>
  }

  export type usersUpsertWithoutPushNotificationHistoryInput = {
    update: XOR<usersUpdateWithoutPushNotificationHistoryInput, usersUncheckedUpdateWithoutPushNotificationHistoryInput>
    create: XOR<usersCreateWithoutPushNotificationHistoryInput, usersUncheckedCreateWithoutPushNotificationHistoryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPushNotificationHistoryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPushNotificationHistoryInput, usersUncheckedUpdateWithoutPushNotificationHistoryInput>
  }

  export type usersUpdateWithoutPushNotificationHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutPushNotificationHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type productsCreateWithoutBrandInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsCreateNestedManyWithoutProductInput
    ratings?: ratingsCreateNestedManyWithoutProductInput
    events?: eventsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutBrandInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutProductInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutProductInput
    events?: eventsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutBrandInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput>
  }

  export type productsCreateManyBrandInputEnvelope = {
    data: productsCreateManyBrandInput | productsCreateManyBrandInput[]
  }

  export type questionsCreateWithoutBrandInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    questionClass?: question_classesCreateNestedOneWithoutQuestionsInput
    answers?: answersCreateNestedManyWithoutQuestionInput
    questionnaire?: questionnairesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutBrandInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsCreateOrConnectWithoutBrandInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput>
  }

  export type questionsCreateManyBrandInputEnvelope = {
    data: questionsCreateManyBrandInput | questionsCreateManyBrandInput[]
  }

  export type productsUpsertWithWhereUniqueWithoutBrandInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutBrandInput, productsUncheckedUpdateWithoutBrandInput>
    create: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput>
  }

  export type productsUpdateWithWhereUniqueWithoutBrandInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutBrandInput, productsUncheckedUpdateWithoutBrandInput>
  }

  export type productsUpdateManyWithWhereWithoutBrandInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutBrandInput>
  }

  export type productsScalarWhereInput = {
    AND?: productsScalarWhereInput | productsScalarWhereInput[]
    OR?: productsScalarWhereInput[]
    NOT?: productsScalarWhereInput | productsScalarWhereInput[]
    id?: StringFilter<"products"> | string
    description?: JsonNullableFilter<"products">
    images?: JsonNullableListFilter<"products">
    regularPrice?: StringNullableFilter<"products"> | string | null
    deal?: StringNullableFilter<"products"> | string | null
    dealPrice?: StringNullableFilter<"products"> | string | null
    purchaseUrl?: StringNullableFilter<"products"> | string | null
    brandId?: StringFilter<"products"> | string
    name?: StringFilter<"products"> | string
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
    uniqueDeal?: BoolNullableFilter<"products"> | boolean | null
  }

  export type questionsUpsertWithWhereUniqueWithoutBrandInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutBrandInput, questionsUncheckedUpdateWithoutBrandInput>
    create: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutBrandInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutBrandInput, questionsUncheckedUpdateWithoutBrandInput>
  }

  export type questionsUpdateManyWithWhereWithoutBrandInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutBrandInput>
  }

  export type questionsScalarWhereInput = {
    AND?: questionsScalarWhereInput | questionsScalarWhereInput[]
    OR?: questionsScalarWhereInput[]
    NOT?: questionsScalarWhereInput | questionsScalarWhereInput[]
    id?: StringFilter<"questions"> | string
    position?: IntFilter<"questions"> | number
    question?: JsonFilter<"questions">
    type?: StringFilter<"questions"> | string
    options?: JsonNullableListFilter<"questions">
    classId?: StringNullableFilter<"questions"> | string | null
    categoryId?: StringNullableFilter<"questions"> | string | null
    onboarding?: BoolFilter<"questions"> | boolean
    randomizeOptions?: BoolNullableFilter<"questions"> | boolean | null
    fixedOptionSize?: BoolNullableFilter<"questions"> | boolean | null
    hideOptionText?: BoolNullableFilter<"questions"> | boolean | null
    displayImage?: JsonNullableFilter<"questions">
    footnote?: JsonNullableFilter<"questions">
    subtitle?: JsonNullableFilter<"questions">
    products?: JsonNullableFilter<"questions">
    brandId?: StringNullableFilter<"questions"> | string | null
    correctAnswerId?: StringNullableFilter<"questions"> | string | null
    questionnaireId?: StringNullableFilter<"questions"> | string | null
    questionnaireSubCategory?: IntNullableFilter<"questions"> | number | null
    createdAt?: DateTimeFilter<"questions"> | Date | string
    updatedAt?: DateTimeFilter<"questions"> | Date | string
    scaleTopLabel?: JsonNullableFilter<"questions">
    scaleBottomLabel?: JsonNullableFilter<"questions">
    maxOptions?: IntNullableFilter<"questions"> | number | null
  }

  export type productsCreateWithoutLinkVisitsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    brand: brandsCreateNestedOneWithoutProductsInput
    ratings?: ratingsCreateNestedManyWithoutProductInput
    events?: eventsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutLinkVisitsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    ratings?: ratingsUncheckedCreateNestedManyWithoutProductInput
    events?: eventsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutLinkVisitsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutLinkVisitsInput, productsUncheckedCreateWithoutLinkVisitsInput>
  }

  export type productsUpsertWithoutLinkVisitsInput = {
    update: XOR<productsUpdateWithoutLinkVisitsInput, productsUncheckedUpdateWithoutLinkVisitsInput>
    create: XOR<productsCreateWithoutLinkVisitsInput, productsUncheckedCreateWithoutLinkVisitsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutLinkVisitsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutLinkVisitsInput, productsUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type productsUpdateWithoutLinkVisitsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: brandsUpdateOneRequiredWithoutProductsNestedInput
    ratings?: ratingsUpdateManyWithoutProductNestedInput
    events?: eventsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutLinkVisitsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ratings?: ratingsUncheckedUpdateManyWithoutProductNestedInput
    events?: eventsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productsCreateWithoutEventsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    brand: brandsCreateNestedOneWithoutProductsInput
    linkVisits?: link_visitsCreateNestedManyWithoutProductInput
    ratings?: ratingsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutEventsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutProductInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutEventsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutEventsInput, productsUncheckedCreateWithoutEventsInput>
  }

  export type productsUpsertWithoutEventsInput = {
    update: XOR<productsUpdateWithoutEventsInput, productsUncheckedUpdateWithoutEventsInput>
    create: XOR<productsCreateWithoutEventsInput, productsUncheckedCreateWithoutEventsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutEventsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutEventsInput, productsUncheckedUpdateWithoutEventsInput>
  }

  export type productsUpdateWithoutEventsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: brandsUpdateOneRequiredWithoutProductsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutProductNestedInput
    ratings?: ratingsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutEventsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type questionsCreateWithoutQuestionClassInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersCreateNestedManyWithoutQuestionInput
    brand?: brandsCreateNestedOneWithoutQuestionsInput
    questionnaire?: questionnairesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutQuestionClassInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsCreateOrConnectWithoutQuestionClassInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput>
  }

  export type questionsCreateManyQuestionClassInputEnvelope = {
    data: questionsCreateManyQuestionClassInput | questionsCreateManyQuestionClassInput[]
  }

  export type questionsUpsertWithWhereUniqueWithoutQuestionClassInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutQuestionClassInput, questionsUncheckedUpdateWithoutQuestionClassInput>
    create: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutQuestionClassInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutQuestionClassInput, questionsUncheckedUpdateWithoutQuestionClassInput>
  }

  export type questionsUpdateManyWithWhereWithoutQuestionClassInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutQuestionClassInput>
  }

  export type questionsCreateWithoutAnswersInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    questionClass?: question_classesCreateNestedOneWithoutQuestionsInput
    brand?: brandsCreateNestedOneWithoutQuestionsInput
    questionnaire?: questionnairesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutAnswersInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type questionsCreateOrConnectWithoutAnswersInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
  }

  export type questionsUpsertWithoutAnswersInput = {
    update: XOR<questionsUpdateWithoutAnswersInput, questionsUncheckedUpdateWithoutAnswersInput>
    create: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    where?: questionsWhereInput
  }

  export type questionsUpdateToOneWithWhereWithoutAnswersInput = {
    where?: questionsWhereInput
    data: XOR<questionsUpdateWithoutAnswersInput, questionsUncheckedUpdateWithoutAnswersInput>
  }

  export type questionsUpdateWithoutAnswersInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    questionClass?: question_classesUpdateOneWithoutQuestionsNestedInput
    brand?: brandsUpdateOneWithoutQuestionsNestedInput
    questionnaire?: questionnairesUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutAnswersInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questionsCreateWithoutQuestionnaireInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    questionClass?: question_classesCreateNestedOneWithoutQuestionsInput
    answers?: answersCreateNestedManyWithoutQuestionInput
    brand?: brandsCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutQuestionnaireInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsCreateOrConnectWithoutQuestionnaireInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput>
  }

  export type questionsCreateManyQuestionnaireInputEnvelope = {
    data: questionsCreateManyQuestionnaireInput | questionsCreateManyQuestionnaireInput[]
  }

  export type questionsUpsertWithWhereUniqueWithoutQuestionnaireInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutQuestionnaireInput, questionsUncheckedUpdateWithoutQuestionnaireInput>
    create: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutQuestionnaireInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutQuestionnaireInput, questionsUncheckedUpdateWithoutQuestionnaireInput>
  }

  export type questionsUpdateManyWithWhereWithoutQuestionnaireInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutQuestionnaireInput>
  }

  export type usersCreateWithoutProductionSubmissionsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutProductionSubmissionsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutProductionSubmissionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProductionSubmissionsInput, usersUncheckedCreateWithoutProductionSubmissionsInput>
  }

  export type usersUpsertWithoutProductionSubmissionsInput = {
    update: XOR<usersUpdateWithoutProductionSubmissionsInput, usersUncheckedUpdateWithoutProductionSubmissionsInput>
    create: XOR<usersCreateWithoutProductionSubmissionsInput, usersUncheckedCreateWithoutProductionSubmissionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProductionSubmissionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProductionSubmissionsInput, usersUncheckedUpdateWithoutProductionSubmissionsInput>
  }

  export type usersUpdateWithoutProductionSubmissionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutProductionSubmissionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type question_classesCreateWithoutQuestionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type question_classesUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type question_classesCreateOrConnectWithoutQuestionsInput = {
    where: question_classesWhereUniqueInput
    create: XOR<question_classesCreateWithoutQuestionsInput, question_classesUncheckedCreateWithoutQuestionsInput>
  }

  export type answersCreateWithoutQuestionInput = {
    id?: string
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answersUncheckedCreateWithoutQuestionInput = {
    id?: string
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answersCreateOrConnectWithoutQuestionInput = {
    where: answersWhereUniqueInput
    create: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput>
  }

  export type answersCreateManyQuestionInputEnvelope = {
    data: answersCreateManyQuestionInput | answersCreateManyQuestionInput[]
  }

  export type brandsCreateWithoutQuestionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: productsCreateNestedManyWithoutBrandInput
  }

  export type brandsUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandsCreateOrConnectWithoutQuestionsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutQuestionsInput, brandsUncheckedCreateWithoutQuestionsInput>
  }

  export type questionnairesCreateWithoutQuestionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionnairesUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionnairesCreateOrConnectWithoutQuestionsInput = {
    where: questionnairesWhereUniqueInput
    create: XOR<questionnairesCreateWithoutQuestionsInput, questionnairesUncheckedCreateWithoutQuestionsInput>
  }

  export type question_classesUpsertWithoutQuestionsInput = {
    update: XOR<question_classesUpdateWithoutQuestionsInput, question_classesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<question_classesCreateWithoutQuestionsInput, question_classesUncheckedCreateWithoutQuestionsInput>
    where?: question_classesWhereInput
  }

  export type question_classesUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: question_classesWhereInput
    data: XOR<question_classesUpdateWithoutQuestionsInput, question_classesUncheckedUpdateWithoutQuestionsInput>
  }

  export type question_classesUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_classesUncheckedUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUpsertWithWhereUniqueWithoutQuestionInput = {
    where: answersWhereUniqueInput
    update: XOR<answersUpdateWithoutQuestionInput, answersUncheckedUpdateWithoutQuestionInput>
    create: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput>
  }

  export type answersUpdateWithWhereUniqueWithoutQuestionInput = {
    where: answersWhereUniqueInput
    data: XOR<answersUpdateWithoutQuestionInput, answersUncheckedUpdateWithoutQuestionInput>
  }

  export type answersUpdateManyWithWhereWithoutQuestionInput = {
    where: answersScalarWhereInput
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyWithoutQuestionInput>
  }

  export type answersScalarWhereInput = {
    AND?: answersScalarWhereInput | answersScalarWhereInput[]
    OR?: answersScalarWhereInput[]
    NOT?: answersScalarWhereInput | answersScalarWhereInput[]
    id?: StringFilter<"answers"> | string
    questionId?: StringFilter<"answers"> | string
    answer?: JsonFilter<"answers">
    createdAt?: DateTimeFilter<"answers"> | Date | string
    updatedAt?: DateTimeFilter<"answers"> | Date | string
  }

  export type brandsUpsertWithoutQuestionsInput = {
    update: XOR<brandsUpdateWithoutQuestionsInput, brandsUncheckedUpdateWithoutQuestionsInput>
    create: XOR<brandsCreateWithoutQuestionsInput, brandsUncheckedCreateWithoutQuestionsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutQuestionsInput, brandsUncheckedUpdateWithoutQuestionsInput>
  }

  export type brandsUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: productsUpdateManyWithoutBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type questionnairesUpsertWithoutQuestionsInput = {
    update: XOR<questionnairesUpdateWithoutQuestionsInput, questionnairesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<questionnairesCreateWithoutQuestionsInput, questionnairesUncheckedCreateWithoutQuestionsInput>
    where?: questionnairesWhereInput
  }

  export type questionnairesUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: questionnairesWhereInput
    data: XOR<questionnairesUpdateWithoutQuestionsInput, questionnairesUncheckedUpdateWithoutQuestionsInput>
  }

  export type questionnairesUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionnairesUncheckedUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateWithoutRatingsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutRatingsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    superUser?: boolean | null
    hasCompletedOnboarding?: boolean | null
    location?: string | null
    profilePicture?: InputJsonValue | null
    friendCode?: string | null
    lastOpened?: Date | string | null
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutRatingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRatingsInput, usersUncheckedCreateWithoutRatingsInput>
  }

  export type productsCreateWithoutRatingsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    brand: brandsCreateNestedOneWithoutProductsInput
    linkVisits?: link_visitsCreateNestedManyWithoutProductInput
    events?: eventsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutRatingsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutProductInput
    events?: eventsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutRatingsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutRatingsInput, productsUncheckedCreateWithoutRatingsInput>
  }

  export type usersUpsertWithoutRatingsInput = {
    update: XOR<usersUpdateWithoutRatingsInput, usersUncheckedUpdateWithoutRatingsInput>
    create: XOR<usersCreateWithoutRatingsInput, usersUncheckedCreateWithoutRatingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRatingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRatingsInput, usersUncheckedUpdateWithoutRatingsInput>
  }

  export type usersUpdateWithoutRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasCompletedOnboarding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: InputJsonValue | InputJsonValue | null
    friendCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type productsUpsertWithoutRatingsInput = {
    update: XOR<productsUpdateWithoutRatingsInput, productsUncheckedUpdateWithoutRatingsInput>
    create: XOR<productsCreateWithoutRatingsInput, productsUncheckedCreateWithoutRatingsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutRatingsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutRatingsInput, productsUncheckedUpdateWithoutRatingsInput>
  }

  export type productsUpdateWithoutRatingsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: brandsUpdateOneRequiredWithoutProductsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutProductNestedInput
    events?: eventsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutRatingsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUncheckedUpdateManyWithoutProductNestedInput
    events?: eventsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type production_submissionsCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type production_submissionsUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type production_submissionsCreateOrConnectWithoutUserInput = {
    where: production_submissionsWhereUniqueInput
    create: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput>
  }

  export type production_submissionsCreateManyUserInputEnvelope = {
    data: production_submissionsCreateManyUserInput | production_submissionsCreateManyUserInput[]
  }

  export type push_notification_historyCreateWithoutUserInput = {
    id?: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type push_notification_historyUncheckedCreateWithoutUserInput = {
    id?: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type push_notification_historyCreateOrConnectWithoutUserInput = {
    where: push_notification_historyWhereUniqueInput
    create: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput>
  }

  export type push_notification_historyCreateManyUserInputEnvelope = {
    data: push_notification_historyCreateManyUserInput | push_notification_historyCreateManyUserInput[]
  }

  export type ratingsCreateWithoutUserInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: productsCreateNestedOneWithoutRatingsInput
  }

  export type ratingsUncheckedCreateWithoutUserInput = {
    id?: string
    productId?: string | null
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsCreateOrConnectWithoutUserInput = {
    where: ratingsWhereUniqueInput
    create: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput>
  }

  export type ratingsCreateManyUserInputEnvelope = {
    data: ratingsCreateManyUserInput | ratingsCreateManyUserInput[]
  }

  export type production_submissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: production_submissionsWhereUniqueInput
    update: XOR<production_submissionsUpdateWithoutUserInput, production_submissionsUncheckedUpdateWithoutUserInput>
    create: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput>
  }

  export type production_submissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: production_submissionsWhereUniqueInput
    data: XOR<production_submissionsUpdateWithoutUserInput, production_submissionsUncheckedUpdateWithoutUserInput>
  }

  export type production_submissionsUpdateManyWithWhereWithoutUserInput = {
    where: production_submissionsScalarWhereInput
    data: XOR<production_submissionsUpdateManyMutationInput, production_submissionsUncheckedUpdateManyWithoutUserInput>
  }

  export type production_submissionsScalarWhereInput = {
    AND?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
    OR?: production_submissionsScalarWhereInput[]
    NOT?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
    id?: StringFilter<"production_submissions"> | string
    userId?: StringFilter<"production_submissions"> | string
    createdAt?: DateTimeFilter<"production_submissions"> | Date | string
    updatedAt?: DateTimeFilter<"production_submissions"> | Date | string
  }

  export type push_notification_historyUpsertWithWhereUniqueWithoutUserInput = {
    where: push_notification_historyWhereUniqueInput
    update: XOR<push_notification_historyUpdateWithoutUserInput, push_notification_historyUncheckedUpdateWithoutUserInput>
    create: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput>
  }

  export type push_notification_historyUpdateWithWhereUniqueWithoutUserInput = {
    where: push_notification_historyWhereUniqueInput
    data: XOR<push_notification_historyUpdateWithoutUserInput, push_notification_historyUncheckedUpdateWithoutUserInput>
  }

  export type push_notification_historyUpdateManyWithWhereWithoutUserInput = {
    where: push_notification_historyScalarWhereInput
    data: XOR<push_notification_historyUpdateManyMutationInput, push_notification_historyUncheckedUpdateManyWithoutUserInput>
  }

  export type push_notification_historyScalarWhereInput = {
    AND?: push_notification_historyScalarWhereInput | push_notification_historyScalarWhereInput[]
    OR?: push_notification_historyScalarWhereInput[]
    NOT?: push_notification_historyScalarWhereInput | push_notification_historyScalarWhereInput[]
    id?: StringFilter<"push_notification_history"> | string
    userId?: StringFilter<"push_notification_history"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notification_history"> | $Enums.NotificationType | null
    entityId?: StringNullableFilter<"push_notification_history"> | string | null
    content?: StringFilter<"push_notification_history"> | string
    title?: StringFilter<"push_notification_history"> | string
    sentAt?: DateTimeFilter<"push_notification_history"> | Date | string
  }

  export type ratingsUpsertWithWhereUniqueWithoutUserInput = {
    where: ratingsWhereUniqueInput
    update: XOR<ratingsUpdateWithoutUserInput, ratingsUncheckedUpdateWithoutUserInput>
    create: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput>
  }

  export type ratingsUpdateWithWhereUniqueWithoutUserInput = {
    where: ratingsWhereUniqueInput
    data: XOR<ratingsUpdateWithoutUserInput, ratingsUncheckedUpdateWithoutUserInput>
  }

  export type ratingsUpdateManyWithWhereWithoutUserInput = {
    where: ratingsScalarWhereInput
    data: XOR<ratingsUpdateManyMutationInput, ratingsUncheckedUpdateManyWithoutUserInput>
  }

  export type link_visitsCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
  }

  export type ratingsCreateManyProductInput = {
    id?: string
    userId: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type eventsCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type link_visitsUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsUncheckedUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsUncheckedUpdateManyWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUpdateWithoutProductInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ratingsUncheckedUpdateWithoutProductInput = {
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateManyWithoutProductInput = {
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventsUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventsUncheckedUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type eventsUncheckedUpdateManyWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsCreateManyBrandInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
  }

  export type questionsCreateManyBrandInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type productsUpdateWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUpdateManyWithoutProductNestedInput
    ratings?: ratingsUpdateManyWithoutProductNestedInput
    events?: eventsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutProductNestedInput
    events?: eventsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateManyWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type questionsUpdateWithoutBrandInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    questionClass?: question_classesUpdateOneWithoutQuestionsNestedInput
    answers?: answersUpdateManyWithoutQuestionNestedInput
    questionnaire?: questionnairesUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutBrandInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutBrandInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questionsCreateManyQuestionClassInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type questionsUpdateWithoutQuestionClassInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUpdateManyWithoutQuestionNestedInput
    brand?: brandsUpdateOneWithoutQuestionsNestedInput
    questionnaire?: questionnairesUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutQuestionClassInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutQuestionClassInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questionsCreateManyQuestionnaireInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type questionsUpdateWithoutQuestionnaireInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    questionClass?: question_classesUpdateOneWithoutQuestionsNestedInput
    answers?: answersUpdateManyWithoutQuestionNestedInput
    brand?: brandsUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutQuestionnaireInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutQuestionnaireInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type answersCreateManyQuestionInput = {
    id?: string
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answersUpdateWithoutQuestionInput = {
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUncheckedUpdateWithoutQuestionInput = {
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUncheckedUpdateManyWithoutQuestionInput = {
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type push_notification_historyCreateManyUserInput = {
    id?: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type ratingsCreateManyUserInput = {
    id?: string
    productId?: string | null
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type production_submissionsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsUncheckedUpdateManyWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyUpdateWithoutUserInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyUncheckedUpdateWithoutUserInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyUncheckedUpdateManyWithoutUserInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUpdateWithoutUserInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productsUpdateOneWithoutRatingsNestedInput
  }

  export type ratingsUncheckedUpdateWithoutUserInput = {
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateManyWithoutUserInput = {
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ProductsCountOutputTypeDefaultArgs instead
     */
    export type ProductsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandsCountOutputTypeDefaultArgs instead
     */
    export type BrandsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Question_classesCountOutputTypeDefaultArgs instead
     */
    export type Question_classesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Question_classesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionnairesCountOutputTypeDefaultArgs instead
     */
    export type QuestionnairesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionnairesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionsCountOutputTypeDefaultArgs instead
     */
    export type QuestionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_versionsDefaultArgs instead
     */
    export type app_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_versionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productsDefaultArgs instead
     */
    export type productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use push_notificationsDefaultArgs instead
     */
    export type push_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = push_notificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use push_notification_historyDefaultArgs instead
     */
    export type push_notification_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = push_notification_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use brandsDefaultArgs instead
     */
    export type brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = brandsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use link_visitsDefaultArgs instead
     */
    export type link_visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = link_visitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventsDefaultArgs instead
     */
    export type eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use question_classesDefaultArgs instead
     */
    export type question_classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = question_classesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use answersDefaultArgs instead
     */
    export type answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = answersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questionnairesDefaultArgs instead
     */
    export type questionnairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questionnairesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use production_submissionsDefaultArgs instead
     */
    export type production_submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = production_submissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questionsDefaultArgs instead
     */
    export type questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ratingsDefaultArgs instead
     */
    export type ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ratingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}