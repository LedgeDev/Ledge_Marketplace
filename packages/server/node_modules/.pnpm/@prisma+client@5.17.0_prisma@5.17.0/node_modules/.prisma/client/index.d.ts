
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model order_history
 * 
 */
export type order_history = $Result.DefaultSelection<Prisma.$order_historyPayload>
/**
 * Model answers
 * 
 */
export type answers = $Result.DefaultSelection<Prisma.$answersPayload>
/**
 * Model app_versions
 * 
 */
export type app_versions = $Result.DefaultSelection<Prisma.$app_versionsPayload>
/**
 * Model benefits
 * 
 */
export type benefits = $Result.DefaultSelection<Prisma.$benefitsPayload>
/**
 * Model brands
 * 
 */
export type brands = $Result.DefaultSelection<Prisma.$brandsPayload>
/**
 * Model unlocked_brands_history
 * 
 */
export type unlocked_brands_history = $Result.DefaultSelection<Prisma.$unlocked_brands_historyPayload>
/**
 * Model brand_screen_times
 * 
 */
export type brand_screen_times = $Result.DefaultSelection<Prisma.$brand_screen_timesPayload>
/**
 * Model categories
 * 
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model category_choices
 * 
 */
export type category_choices = $Result.DefaultSelection<Prisma.$category_choicesPayload>
/**
 * Model foundersReachedLeaderboard
 * 
 */
export type foundersReachedLeaderboard = $Result.DefaultSelection<Prisma.$foundersReachedLeaderboardPayload>
/**
 * Model link_visits
 * 
 */
export type link_visits = $Result.DefaultSelection<Prisma.$link_visitsPayload>
/**
 * Model pitch_views
 * 
 */
export type pitch_views = $Result.DefaultSelection<Prisma.$pitch_viewsPayload>
/**
 * Model posts
 * 
 */
export type posts = $Result.DefaultSelection<Prisma.$postsPayload>
/**
 * Model production_submissions
 * 
 */
export type production_submissions = $Result.DefaultSelection<Prisma.$production_submissionsPayload>
/**
 * Model products
 * 
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model push_notifications
 * 
 */
export type push_notifications = $Result.DefaultSelection<Prisma.$push_notificationsPayload>
/**
 * Model push_notification_history
 * 
 */
export type push_notification_history = $Result.DefaultSelection<Prisma.$push_notification_historyPayload>
/**
 * Model questionnaires
 * 
 */
export type questionnaires = $Result.DefaultSelection<Prisma.$questionnairesPayload>
/**
 * Model question_classes
 * 
 */
export type question_classes = $Result.DefaultSelection<Prisma.$question_classesPayload>
/**
 * Model questions
 * 
 */
export type questions = $Result.DefaultSelection<Prisma.$questionsPayload>
/**
 * Model ratings
 * 
 */
export type ratings = $Result.DefaultSelection<Prisma.$ratingsPayload>
/**
 * Model settings
 * 
 */
export type settings = $Result.DefaultSelection<Prisma.$settingsPayload>
/**
 * Model terms_and_conditions
 * 
 */
export type terms_and_conditions = $Result.DefaultSelection<Prisma.$terms_and_conditionsPayload>
/**
 * Model feedback
 * 
 */
export type feedback = $Result.DefaultSelection<Prisma.$feedbackPayload>
/**
 * Model levels
 * 
 */
export type levels = $Result.DefaultSelection<Prisma.$levelsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model deal_codes
 * 
 */
export type deal_codes = $Result.DefaultSelection<Prisma.$deal_codesPayload>
/**
 * Model deal_code_groups
 * 
 */
export type deal_code_groups = $Result.DefaultSelection<Prisma.$deal_code_groupsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GenderPreference: {
  men: 'men',
  women: 'women',
  both: 'both',
  other: 'other'
};

export type GenderPreference = (typeof GenderPreference)[keyof typeof GenderPreference]


export const NotificationType: {
  QUESTIONS_AWAY: 'QUESTIONS_AWAY',
  BRANDS_AWAY: 'BRANDS_AWAY',
  PRODUCT_FEEDBACK: 'PRODUCT_FEEDBACK',
  COMEBACK_REMINDER: 'COMEBACK_REMINDER',
  EXPIRING_DEALS: 'EXPIRING_DEALS',
  NEW_BRANDS: 'NEW_BRANDS',
  NEW_BENEFITS: 'NEW_BENEFITS',
  GLOABL: 'GLOABL'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type GenderPreference = $Enums.GenderPreference

export const GenderPreference: typeof $Enums.GenderPreference

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Order_histories
 * const order_histories = await prisma.order_history.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Order_histories
   * const order_histories = await prisma.order_history.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.order_history`: Exposes CRUD operations for the **order_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_histories
    * const order_histories = await prisma.order_history.findMany()
    * ```
    */
  get order_history(): Prisma.order_historyDelegate<ExtArgs>;

  /**
   * `prisma.answers`: Exposes CRUD operations for the **answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answers.findMany()
    * ```
    */
  get answers(): Prisma.answersDelegate<ExtArgs>;

  /**
   * `prisma.app_versions`: Exposes CRUD operations for the **app_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_versions
    * const app_versions = await prisma.app_versions.findMany()
    * ```
    */
  get app_versions(): Prisma.app_versionsDelegate<ExtArgs>;

  /**
   * `prisma.benefits`: Exposes CRUD operations for the **benefits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Benefits
    * const benefits = await prisma.benefits.findMany()
    * ```
    */
  get benefits(): Prisma.benefitsDelegate<ExtArgs>;

  /**
   * `prisma.brands`: Exposes CRUD operations for the **brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brands.findMany()
    * ```
    */
  get brands(): Prisma.brandsDelegate<ExtArgs>;

  /**
   * `prisma.unlocked_brands_history`: Exposes CRUD operations for the **unlocked_brands_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unlocked_brands_histories
    * const unlocked_brands_histories = await prisma.unlocked_brands_history.findMany()
    * ```
    */
  get unlocked_brands_history(): Prisma.unlocked_brands_historyDelegate<ExtArgs>;

  /**
   * `prisma.brand_screen_times`: Exposes CRUD operations for the **brand_screen_times** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brand_screen_times
    * const brand_screen_times = await prisma.brand_screen_times.findMany()
    * ```
    */
  get brand_screen_times(): Prisma.brand_screen_timesDelegate<ExtArgs>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs>;

  /**
   * `prisma.category_choices`: Exposes CRUD operations for the **category_choices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Category_choices
    * const category_choices = await prisma.category_choices.findMany()
    * ```
    */
  get category_choices(): Prisma.category_choicesDelegate<ExtArgs>;

  /**
   * `prisma.foundersReachedLeaderboard`: Exposes CRUD operations for the **foundersReachedLeaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoundersReachedLeaderboards
    * const foundersReachedLeaderboards = await prisma.foundersReachedLeaderboard.findMany()
    * ```
    */
  get foundersReachedLeaderboard(): Prisma.foundersReachedLeaderboardDelegate<ExtArgs>;

  /**
   * `prisma.link_visits`: Exposes CRUD operations for the **link_visits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Link_visits
    * const link_visits = await prisma.link_visits.findMany()
    * ```
    */
  get link_visits(): Prisma.link_visitsDelegate<ExtArgs>;

  /**
   * `prisma.pitch_views`: Exposes CRUD operations for the **pitch_views** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pitch_views
    * const pitch_views = await prisma.pitch_views.findMany()
    * ```
    */
  get pitch_views(): Prisma.pitch_viewsDelegate<ExtArgs>;

  /**
   * `prisma.posts`: Exposes CRUD operations for the **posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.posts.findMany()
    * ```
    */
  get posts(): Prisma.postsDelegate<ExtArgs>;

  /**
   * `prisma.production_submissions`: Exposes CRUD operations for the **production_submissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Production_submissions
    * const production_submissions = await prisma.production_submissions.findMany()
    * ```
    */
  get production_submissions(): Prisma.production_submissionsDelegate<ExtArgs>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs>;

  /**
   * `prisma.push_notifications`: Exposes CRUD operations for the **push_notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Push_notifications
    * const push_notifications = await prisma.push_notifications.findMany()
    * ```
    */
  get push_notifications(): Prisma.push_notificationsDelegate<ExtArgs>;

  /**
   * `prisma.push_notification_history`: Exposes CRUD operations for the **push_notification_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Push_notification_histories
    * const push_notification_histories = await prisma.push_notification_history.findMany()
    * ```
    */
  get push_notification_history(): Prisma.push_notification_historyDelegate<ExtArgs>;

  /**
   * `prisma.questionnaires`: Exposes CRUD operations for the **questionnaires** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questionnaires
    * const questionnaires = await prisma.questionnaires.findMany()
    * ```
    */
  get questionnaires(): Prisma.questionnairesDelegate<ExtArgs>;

  /**
   * `prisma.question_classes`: Exposes CRUD operations for the **question_classes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Question_classes
    * const question_classes = await prisma.question_classes.findMany()
    * ```
    */
  get question_classes(): Prisma.question_classesDelegate<ExtArgs>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.questionsDelegate<ExtArgs>;

  /**
   * `prisma.ratings`: Exposes CRUD operations for the **ratings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.ratings.findMany()
    * ```
    */
  get ratings(): Prisma.ratingsDelegate<ExtArgs>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.settingsDelegate<ExtArgs>;

  /**
   * `prisma.terms_and_conditions`: Exposes CRUD operations for the **terms_and_conditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terms_and_conditions
    * const terms_and_conditions = await prisma.terms_and_conditions.findMany()
    * ```
    */
  get terms_and_conditions(): Prisma.terms_and_conditionsDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.feedbackDelegate<ExtArgs>;

  /**
   * `prisma.levels`: Exposes CRUD operations for the **levels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.levels.findMany()
    * ```
    */
  get levels(): Prisma.levelsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.deal_codes`: Exposes CRUD operations for the **deal_codes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deal_codes
    * const deal_codes = await prisma.deal_codes.findMany()
    * ```
    */
  get deal_codes(): Prisma.deal_codesDelegate<ExtArgs>;

  /**
   * `prisma.deal_code_groups`: Exposes CRUD operations for the **deal_code_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deal_code_groups
    * const deal_code_groups = await prisma.deal_code_groups.findMany()
    * ```
    */
  get deal_code_groups(): Prisma.deal_code_groupsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    order_history: 'order_history',
    answers: 'answers',
    app_versions: 'app_versions',
    benefits: 'benefits',
    brands: 'brands',
    unlocked_brands_history: 'unlocked_brands_history',
    brand_screen_times: 'brand_screen_times',
    categories: 'categories',
    category_choices: 'category_choices',
    foundersReachedLeaderboard: 'foundersReachedLeaderboard',
    link_visits: 'link_visits',
    pitch_views: 'pitch_views',
    posts: 'posts',
    production_submissions: 'production_submissions',
    products: 'products',
    push_notifications: 'push_notifications',
    push_notification_history: 'push_notification_history',
    questionnaires: 'questionnaires',
    question_classes: 'question_classes',
    questions: 'questions',
    ratings: 'ratings',
    settings: 'settings',
    terms_and_conditions: 'terms_and_conditions',
    feedback: 'feedback',
    levels: 'levels',
    users: 'users',
    deal_codes: 'deal_codes',
    deal_code_groups: 'deal_code_groups'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "order_history" | "answers" | "app_versions" | "benefits" | "brands" | "unlocked_brands_history" | "brand_screen_times" | "categories" | "category_choices" | "foundersReachedLeaderboard" | "link_visits" | "pitch_views" | "posts" | "production_submissions" | "products" | "push_notifications" | "push_notification_history" | "questionnaires" | "question_classes" | "questions" | "ratings" | "settings" | "terms_and_conditions" | "feedback" | "levels" | "users" | "deal_codes" | "deal_code_groups"
      txIsolationLevel: never
    }
    model: {
      order_history: {
        payload: Prisma.$order_historyPayload<ExtArgs>
        fields: Prisma.order_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload>
          }
          findFirst: {
            args: Prisma.order_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload>
          }
          findMany: {
            args: Prisma.order_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload>[]
          }
          create: {
            args: Prisma.order_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload>
          }
          createMany: {
            args: Prisma.order_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.order_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload>
          }
          update: {
            args: Prisma.order_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload>
          }
          deleteMany: {
            args: Prisma.order_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.order_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_historyPayload>
          }
          aggregate: {
            args: Prisma.Order_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_history>
          }
          groupBy: {
            args: Prisma.order_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_historyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.order_historyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.order_historyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.order_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Order_historyCountAggregateOutputType> | number
          }
        }
      }
      answers: {
        payload: Prisma.$answersPayload<ExtArgs>
        fields: Prisma.answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          findFirst: {
            args: Prisma.answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          findMany: {
            args: Prisma.answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>[]
          }
          create: {
            args: Prisma.answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          createMany: {
            args: Prisma.answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          update: {
            args: Prisma.answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          deleteMany: {
            args: Prisma.answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          aggregate: {
            args: Prisma.AnswersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswers>
          }
          groupBy: {
            args: Prisma.answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.answersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.answersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.answersCountArgs<ExtArgs>
            result: $Utils.Optional<AnswersCountAggregateOutputType> | number
          }
        }
      }
      app_versions: {
        payload: Prisma.$app_versionsPayload<ExtArgs>
        fields: Prisma.app_versionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_versionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_versionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          findFirst: {
            args: Prisma.app_versionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_versionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          findMany: {
            args: Prisma.app_versionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>[]
          }
          create: {
            args: Prisma.app_versionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          createMany: {
            args: Prisma.app_versionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.app_versionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          update: {
            args: Prisma.app_versionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          deleteMany: {
            args: Prisma.app_versionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_versionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.app_versionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_versionsPayload>
          }
          aggregate: {
            args: Prisma.App_versionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_versions>
          }
          groupBy: {
            args: Prisma.app_versionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_versionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.app_versionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.app_versionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.app_versionsCountArgs<ExtArgs>
            result: $Utils.Optional<App_versionsCountAggregateOutputType> | number
          }
        }
      }
      benefits: {
        payload: Prisma.$benefitsPayload<ExtArgs>
        fields: Prisma.benefitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.benefitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.benefitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload>
          }
          findFirst: {
            args: Prisma.benefitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.benefitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload>
          }
          findMany: {
            args: Prisma.benefitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload>[]
          }
          create: {
            args: Prisma.benefitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload>
          }
          createMany: {
            args: Prisma.benefitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.benefitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload>
          }
          update: {
            args: Prisma.benefitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload>
          }
          deleteMany: {
            args: Prisma.benefitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.benefitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.benefitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$benefitsPayload>
          }
          aggregate: {
            args: Prisma.BenefitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBenefits>
          }
          groupBy: {
            args: Prisma.benefitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BenefitsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.benefitsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.benefitsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.benefitsCountArgs<ExtArgs>
            result: $Utils.Optional<BenefitsCountAggregateOutputType> | number
          }
        }
      }
      brands: {
        payload: Prisma.$brandsPayload<ExtArgs>
        fields: Prisma.brandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findFirst: {
            args: Prisma.brandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findMany: {
            args: Prisma.brandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          create: {
            args: Prisma.brandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          createMany: {
            args: Prisma.brandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.brandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          update: {
            args: Prisma.brandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          deleteMany: {
            args: Prisma.brandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.brandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.brandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          aggregate: {
            args: Prisma.BrandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrands>
          }
          groupBy: {
            args: Prisma.brandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.brandsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.brandsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.brandsCountArgs<ExtArgs>
            result: $Utils.Optional<BrandsCountAggregateOutputType> | number
          }
        }
      }
      unlocked_brands_history: {
        payload: Prisma.$unlocked_brands_historyPayload<ExtArgs>
        fields: Prisma.unlocked_brands_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.unlocked_brands_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.unlocked_brands_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload>
          }
          findFirst: {
            args: Prisma.unlocked_brands_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.unlocked_brands_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload>
          }
          findMany: {
            args: Prisma.unlocked_brands_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload>[]
          }
          create: {
            args: Prisma.unlocked_brands_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload>
          }
          createMany: {
            args: Prisma.unlocked_brands_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.unlocked_brands_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload>
          }
          update: {
            args: Prisma.unlocked_brands_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload>
          }
          deleteMany: {
            args: Prisma.unlocked_brands_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.unlocked_brands_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.unlocked_brands_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$unlocked_brands_historyPayload>
          }
          aggregate: {
            args: Prisma.Unlocked_brands_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnlocked_brands_history>
          }
          groupBy: {
            args: Prisma.unlocked_brands_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Unlocked_brands_historyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.unlocked_brands_historyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.unlocked_brands_historyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.unlocked_brands_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Unlocked_brands_historyCountAggregateOutputType> | number
          }
        }
      }
      brand_screen_times: {
        payload: Prisma.$brand_screen_timesPayload<ExtArgs>
        fields: Prisma.brand_screen_timesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brand_screen_timesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brand_screen_timesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload>
          }
          findFirst: {
            args: Prisma.brand_screen_timesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brand_screen_timesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload>
          }
          findMany: {
            args: Prisma.brand_screen_timesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload>[]
          }
          create: {
            args: Prisma.brand_screen_timesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload>
          }
          createMany: {
            args: Prisma.brand_screen_timesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.brand_screen_timesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload>
          }
          update: {
            args: Prisma.brand_screen_timesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload>
          }
          deleteMany: {
            args: Prisma.brand_screen_timesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.brand_screen_timesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.brand_screen_timesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brand_screen_timesPayload>
          }
          aggregate: {
            args: Prisma.Brand_screen_timesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand_screen_times>
          }
          groupBy: {
            args: Prisma.brand_screen_timesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Brand_screen_timesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.brand_screen_timesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.brand_screen_timesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.brand_screen_timesCountArgs<ExtArgs>
            result: $Utils.Optional<Brand_screen_timesCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.categoriesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.categoriesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      category_choices: {
        payload: Prisma.$category_choicesPayload<ExtArgs>
        fields: Prisma.category_choicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.category_choicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.category_choicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload>
          }
          findFirst: {
            args: Prisma.category_choicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.category_choicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload>
          }
          findMany: {
            args: Prisma.category_choicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload>[]
          }
          create: {
            args: Prisma.category_choicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload>
          }
          createMany: {
            args: Prisma.category_choicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.category_choicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload>
          }
          update: {
            args: Prisma.category_choicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload>
          }
          deleteMany: {
            args: Prisma.category_choicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.category_choicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.category_choicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$category_choicesPayload>
          }
          aggregate: {
            args: Prisma.Category_choicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory_choices>
          }
          groupBy: {
            args: Prisma.category_choicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Category_choicesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.category_choicesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.category_choicesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.category_choicesCountArgs<ExtArgs>
            result: $Utils.Optional<Category_choicesCountAggregateOutputType> | number
          }
        }
      }
      foundersReachedLeaderboard: {
        payload: Prisma.$foundersReachedLeaderboardPayload<ExtArgs>
        fields: Prisma.foundersReachedLeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.foundersReachedLeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.foundersReachedLeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload>
          }
          findFirst: {
            args: Prisma.foundersReachedLeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.foundersReachedLeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload>
          }
          findMany: {
            args: Prisma.foundersReachedLeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload>[]
          }
          create: {
            args: Prisma.foundersReachedLeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload>
          }
          createMany: {
            args: Prisma.foundersReachedLeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.foundersReachedLeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload>
          }
          update: {
            args: Prisma.foundersReachedLeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.foundersReachedLeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.foundersReachedLeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.foundersReachedLeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$foundersReachedLeaderboardPayload>
          }
          aggregate: {
            args: Prisma.FoundersReachedLeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoundersReachedLeaderboard>
          }
          groupBy: {
            args: Prisma.foundersReachedLeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoundersReachedLeaderboardGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.foundersReachedLeaderboardFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.foundersReachedLeaderboardAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.foundersReachedLeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<FoundersReachedLeaderboardCountAggregateOutputType> | number
          }
        }
      }
      link_visits: {
        payload: Prisma.$link_visitsPayload<ExtArgs>
        fields: Prisma.link_visitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.link_visitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.link_visitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          findFirst: {
            args: Prisma.link_visitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.link_visitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          findMany: {
            args: Prisma.link_visitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>[]
          }
          create: {
            args: Prisma.link_visitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          createMany: {
            args: Prisma.link_visitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.link_visitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          update: {
            args: Prisma.link_visitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          deleteMany: {
            args: Prisma.link_visitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.link_visitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.link_visitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$link_visitsPayload>
          }
          aggregate: {
            args: Prisma.Link_visitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLink_visits>
          }
          groupBy: {
            args: Prisma.link_visitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Link_visitsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.link_visitsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.link_visitsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.link_visitsCountArgs<ExtArgs>
            result: $Utils.Optional<Link_visitsCountAggregateOutputType> | number
          }
        }
      }
      pitch_views: {
        payload: Prisma.$pitch_viewsPayload<ExtArgs>
        fields: Prisma.pitch_viewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pitch_viewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pitch_viewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload>
          }
          findFirst: {
            args: Prisma.pitch_viewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pitch_viewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload>
          }
          findMany: {
            args: Prisma.pitch_viewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload>[]
          }
          create: {
            args: Prisma.pitch_viewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload>
          }
          createMany: {
            args: Prisma.pitch_viewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pitch_viewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload>
          }
          update: {
            args: Prisma.pitch_viewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload>
          }
          deleteMany: {
            args: Prisma.pitch_viewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pitch_viewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pitch_viewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pitch_viewsPayload>
          }
          aggregate: {
            args: Prisma.Pitch_viewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePitch_views>
          }
          groupBy: {
            args: Prisma.pitch_viewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pitch_viewsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.pitch_viewsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.pitch_viewsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.pitch_viewsCountArgs<ExtArgs>
            result: $Utils.Optional<Pitch_viewsCountAggregateOutputType> | number
          }
        }
      }
      posts: {
        payload: Prisma.$postsPayload<ExtArgs>
        fields: Prisma.postsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.postsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.postsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          findFirst: {
            args: Prisma.postsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.postsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          findMany: {
            args: Prisma.postsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]
          }
          create: {
            args: Prisma.postsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          createMany: {
            args: Prisma.postsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.postsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          update: {
            args: Prisma.postsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          deleteMany: {
            args: Prisma.postsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.postsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.postsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          aggregate: {
            args: Prisma.PostsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosts>
          }
          groupBy: {
            args: Prisma.postsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.postsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.postsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.postsCountArgs<ExtArgs>
            result: $Utils.Optional<PostsCountAggregateOutputType> | number
          }
        }
      }
      production_submissions: {
        payload: Prisma.$production_submissionsPayload<ExtArgs>
        fields: Prisma.production_submissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.production_submissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.production_submissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          findFirst: {
            args: Prisma.production_submissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.production_submissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          findMany: {
            args: Prisma.production_submissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>[]
          }
          create: {
            args: Prisma.production_submissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          createMany: {
            args: Prisma.production_submissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.production_submissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          update: {
            args: Prisma.production_submissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          deleteMany: {
            args: Prisma.production_submissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.production_submissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.production_submissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$production_submissionsPayload>
          }
          aggregate: {
            args: Prisma.Production_submissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduction_submissions>
          }
          groupBy: {
            args: Prisma.production_submissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Production_submissionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.production_submissionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.production_submissionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.production_submissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Production_submissionsCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.productsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.productsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      push_notifications: {
        payload: Prisma.$push_notificationsPayload<ExtArgs>
        fields: Prisma.push_notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.push_notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.push_notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          findFirst: {
            args: Prisma.push_notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.push_notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          findMany: {
            args: Prisma.push_notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>[]
          }
          create: {
            args: Prisma.push_notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          createMany: {
            args: Prisma.push_notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.push_notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          update: {
            args: Prisma.push_notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          deleteMany: {
            args: Prisma.push_notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.push_notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.push_notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notificationsPayload>
          }
          aggregate: {
            args: Prisma.Push_notificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePush_notifications>
          }
          groupBy: {
            args: Prisma.push_notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Push_notificationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.push_notificationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.push_notificationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.push_notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<Push_notificationsCountAggregateOutputType> | number
          }
        }
      }
      push_notification_history: {
        payload: Prisma.$push_notification_historyPayload<ExtArgs>
        fields: Prisma.push_notification_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.push_notification_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.push_notification_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          findFirst: {
            args: Prisma.push_notification_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.push_notification_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          findMany: {
            args: Prisma.push_notification_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>[]
          }
          create: {
            args: Prisma.push_notification_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          createMany: {
            args: Prisma.push_notification_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.push_notification_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          update: {
            args: Prisma.push_notification_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          deleteMany: {
            args: Prisma.push_notification_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.push_notification_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.push_notification_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$push_notification_historyPayload>
          }
          aggregate: {
            args: Prisma.Push_notification_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePush_notification_history>
          }
          groupBy: {
            args: Prisma.push_notification_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Push_notification_historyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.push_notification_historyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.push_notification_historyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.push_notification_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Push_notification_historyCountAggregateOutputType> | number
          }
        }
      }
      questionnaires: {
        payload: Prisma.$questionnairesPayload<ExtArgs>
        fields: Prisma.questionnairesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionnairesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionnairesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          findFirst: {
            args: Prisma.questionnairesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionnairesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          findMany: {
            args: Prisma.questionnairesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>[]
          }
          create: {
            args: Prisma.questionnairesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          createMany: {
            args: Prisma.questionnairesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questionnairesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          update: {
            args: Prisma.questionnairesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          deleteMany: {
            args: Prisma.questionnairesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionnairesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questionnairesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionnairesPayload>
          }
          aggregate: {
            args: Prisma.QuestionnairesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionnaires>
          }
          groupBy: {
            args: Prisma.questionnairesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionnairesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.questionnairesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.questionnairesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.questionnairesCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionnairesCountAggregateOutputType> | number
          }
        }
      }
      question_classes: {
        payload: Prisma.$question_classesPayload<ExtArgs>
        fields: Prisma.question_classesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.question_classesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.question_classesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          findFirst: {
            args: Prisma.question_classesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.question_classesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          findMany: {
            args: Prisma.question_classesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>[]
          }
          create: {
            args: Prisma.question_classesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          createMany: {
            args: Prisma.question_classesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.question_classesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          update: {
            args: Prisma.question_classesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          deleteMany: {
            args: Prisma.question_classesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.question_classesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.question_classesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_classesPayload>
          }
          aggregate: {
            args: Prisma.Question_classesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion_classes>
          }
          groupBy: {
            args: Prisma.question_classesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Question_classesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.question_classesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.question_classesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.question_classesCountArgs<ExtArgs>
            result: $Utils.Optional<Question_classesCountAggregateOutputType> | number
          }
        }
      }
      questions: {
        payload: Prisma.$questionsPayload<ExtArgs>
        fields: Prisma.questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findFirst: {
            args: Prisma.questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findMany: {
            args: Prisma.questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          create: {
            args: Prisma.questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          createMany: {
            args: Prisma.questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          update: {
            args: Prisma.questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          deleteMany: {
            args: Prisma.questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.questionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.questionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.questionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      ratings: {
        payload: Prisma.$ratingsPayload<ExtArgs>
        fields: Prisma.ratingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ratingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ratingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          findFirst: {
            args: Prisma.ratingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ratingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          findMany: {
            args: Prisma.ratingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>[]
          }
          create: {
            args: Prisma.ratingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          createMany: {
            args: Prisma.ratingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ratingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          update: {
            args: Prisma.ratingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          deleteMany: {
            args: Prisma.ratingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ratingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ratingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ratingsPayload>
          }
          aggregate: {
            args: Prisma.RatingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRatings>
          }
          groupBy: {
            args: Prisma.ratingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RatingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ratingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ratingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ratingsCountArgs<ExtArgs>
            result: $Utils.Optional<RatingsCountAggregateOutputType> | number
          }
        }
      }
      settings: {
        payload: Prisma.$settingsPayload<ExtArgs>
        fields: Prisma.settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findFirst: {
            args: Prisma.settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findMany: {
            args: Prisma.settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          create: {
            args: Prisma.settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          createMany: {
            args: Prisma.settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          update: {
            args: Prisma.settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          deleteMany: {
            args: Prisma.settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.settingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.settingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.settingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      terms_and_conditions: {
        payload: Prisma.$terms_and_conditionsPayload<ExtArgs>
        fields: Prisma.terms_and_conditionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.terms_and_conditionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.terms_and_conditionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>
          }
          findFirst: {
            args: Prisma.terms_and_conditionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.terms_and_conditionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>
          }
          findMany: {
            args: Prisma.terms_and_conditionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>[]
          }
          create: {
            args: Prisma.terms_and_conditionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>
          }
          createMany: {
            args: Prisma.terms_and_conditionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.terms_and_conditionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>
          }
          update: {
            args: Prisma.terms_and_conditionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>
          }
          deleteMany: {
            args: Prisma.terms_and_conditionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.terms_and_conditionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.terms_and_conditionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>
          }
          aggregate: {
            args: Prisma.Terms_and_conditionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerms_and_conditions>
          }
          groupBy: {
            args: Prisma.terms_and_conditionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Terms_and_conditionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.terms_and_conditionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.terms_and_conditionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.terms_and_conditionsCountArgs<ExtArgs>
            result: $Utils.Optional<Terms_and_conditionsCountAggregateOutputType> | number
          }
        }
      }
      feedback: {
        payload: Prisma.$feedbackPayload<ExtArgs>
        fields: Prisma.feedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          findFirst: {
            args: Prisma.feedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          findMany: {
            args: Prisma.feedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>[]
          }
          create: {
            args: Prisma.feedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          createMany: {
            args: Prisma.feedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.feedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          update: {
            args: Prisma.feedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          deleteMany: {
            args: Prisma.feedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.feedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.feedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.feedbackFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.feedbackAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.feedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      levels: {
        payload: Prisma.$levelsPayload<ExtArgs>
        fields: Prisma.levelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.levelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.levelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          findFirst: {
            args: Prisma.levelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.levelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          findMany: {
            args: Prisma.levelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>[]
          }
          create: {
            args: Prisma.levelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          createMany: {
            args: Prisma.levelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.levelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          update: {
            args: Prisma.levelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          deleteMany: {
            args: Prisma.levelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.levelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.levelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$levelsPayload>
          }
          aggregate: {
            args: Prisma.LevelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevels>
          }
          groupBy: {
            args: Prisma.levelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.levelsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.levelsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.levelsCountArgs<ExtArgs>
            result: $Utils.Optional<LevelsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.usersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.usersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      deal_codes: {
        payload: Prisma.$deal_codesPayload<ExtArgs>
        fields: Prisma.deal_codesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deal_codesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deal_codesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload>
          }
          findFirst: {
            args: Prisma.deal_codesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deal_codesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload>
          }
          findMany: {
            args: Prisma.deal_codesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload>[]
          }
          create: {
            args: Prisma.deal_codesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload>
          }
          createMany: {
            args: Prisma.deal_codesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.deal_codesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload>
          }
          update: {
            args: Prisma.deal_codesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload>
          }
          deleteMany: {
            args: Prisma.deal_codesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deal_codesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.deal_codesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_codesPayload>
          }
          aggregate: {
            args: Prisma.Deal_codesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal_codes>
          }
          groupBy: {
            args: Prisma.deal_codesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Deal_codesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.deal_codesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.deal_codesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.deal_codesCountArgs<ExtArgs>
            result: $Utils.Optional<Deal_codesCountAggregateOutputType> | number
          }
        }
      }
      deal_code_groups: {
        payload: Prisma.$deal_code_groupsPayload<ExtArgs>
        fields: Prisma.deal_code_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deal_code_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deal_code_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload>
          }
          findFirst: {
            args: Prisma.deal_code_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deal_code_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload>
          }
          findMany: {
            args: Prisma.deal_code_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload>[]
          }
          create: {
            args: Prisma.deal_code_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload>
          }
          createMany: {
            args: Prisma.deal_code_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.deal_code_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload>
          }
          update: {
            args: Prisma.deal_code_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload>
          }
          deleteMany: {
            args: Prisma.deal_code_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deal_code_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.deal_code_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deal_code_groupsPayload>
          }
          aggregate: {
            args: Prisma.Deal_code_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal_code_groups>
          }
          groupBy: {
            args: Prisma.deal_code_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Deal_code_groupsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.deal_code_groupsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.deal_code_groupsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.deal_code_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Deal_code_groupsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BenefitsCountOutputType
   */

  export type BenefitsCountOutputType = {
    linkVisits: number
  }

  export type BenefitsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linkVisits?: boolean | BenefitsCountOutputTypeCountLinkVisitsArgs
  }

  // Custom InputTypes
  /**
   * BenefitsCountOutputType without action
   */
  export type BenefitsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitsCountOutputType
     */
    select?: BenefitsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BenefitsCountOutputType without action
   */
  export type BenefitsCountOutputTypeCountLinkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: link_visitsWhereInput
  }


  /**
   * Count Type BrandsCountOutputType
   */

  export type BrandsCountOutputType = {
    pitchQuestions: number
    pitchViews: number
    products: number
    ratings: number
    usersForYou: number
    usersForYouPool: number
    usersNotInterestedBrands: number
    linkVisits: number
    brandScreenTimes: number
    productionSubmissions: number
    posts: number
    dealCodeGroups: number
    unlockHistory: number
    pitchExitBrandAnswers: number
    productFeedbackAnswers: number
  }

  export type BrandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pitchQuestions?: boolean | BrandsCountOutputTypeCountPitchQuestionsArgs
    pitchViews?: boolean | BrandsCountOutputTypeCountPitchViewsArgs
    products?: boolean | BrandsCountOutputTypeCountProductsArgs
    ratings?: boolean | BrandsCountOutputTypeCountRatingsArgs
    usersForYou?: boolean | BrandsCountOutputTypeCountUsersForYouArgs
    usersForYouPool?: boolean | BrandsCountOutputTypeCountUsersForYouPoolArgs
    usersNotInterestedBrands?: boolean | BrandsCountOutputTypeCountUsersNotInterestedBrandsArgs
    linkVisits?: boolean | BrandsCountOutputTypeCountLinkVisitsArgs
    brandScreenTimes?: boolean | BrandsCountOutputTypeCountBrandScreenTimesArgs
    productionSubmissions?: boolean | BrandsCountOutputTypeCountProductionSubmissionsArgs
    posts?: boolean | BrandsCountOutputTypeCountPostsArgs
    dealCodeGroups?: boolean | BrandsCountOutputTypeCountDealCodeGroupsArgs
    unlockHistory?: boolean | BrandsCountOutputTypeCountUnlockHistoryArgs
    pitchExitBrandAnswers?: boolean | BrandsCountOutputTypeCountPitchExitBrandAnswersArgs
    productFeedbackAnswers?: boolean | BrandsCountOutputTypeCountProductFeedbackAnswersArgs
  }

  // Custom InputTypes
  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandsCountOutputType
     */
    select?: BrandsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountPitchQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountPitchViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pitch_viewsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountUsersForYouArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountUsersForYouPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountUsersNotInterestedBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountLinkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: link_visitsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountBrandScreenTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brand_screen_timesWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountProductionSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: production_submissionsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountDealCodeGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deal_code_groupsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountUnlockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unlocked_brands_historyWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountPitchExitBrandAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountProductFeedbackAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    brands: number
    userChoices: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | CategoriesCountOutputTypeCountBrandsArgs
    userChoices?: boolean | CategoriesCountOutputTypeCountUserChoicesArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountUserChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_choicesWhereInput
  }


  /**
   * Count Type FoundersReachedLeaderboardCountOutputType
   */

  export type FoundersReachedLeaderboardCountOutputType = {
    users: number
  }

  export type FoundersReachedLeaderboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | FoundersReachedLeaderboardCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * FoundersReachedLeaderboardCountOutputType without action
   */
  export type FoundersReachedLeaderboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoundersReachedLeaderboardCountOutputType
     */
    select?: FoundersReachedLeaderboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoundersReachedLeaderboardCountOutputType without action
   */
  export type FoundersReachedLeaderboardCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type PostsCountOutputType
   */

  export type PostsCountOutputType = {
    userLikes: number
  }

  export type PostsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLikes?: boolean | PostsCountOutputTypeCountUserLikesArgs
  }

  // Custom InputTypes
  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsCountOutputType
     */
    select?: PostsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountUserLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    linkVisits: number
    ratings: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linkVisits?: boolean | ProductsCountOutputTypeCountLinkVisitsArgs
    ratings?: boolean | ProductsCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountLinkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: link_visitsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingsWhereInput
  }


  /**
   * Count Type QuestionnairesCountOutputType
   */

  export type QuestionnairesCountOutputType = {
    questions: number
  }

  export type QuestionnairesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuestionnairesCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * QuestionnairesCountOutputType without action
   */
  export type QuestionnairesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnairesCountOutputType
     */
    select?: QuestionnairesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionnairesCountOutputType without action
   */
  export type QuestionnairesCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type Question_classesCountOutputType
   */

  export type Question_classesCountOutputType = {
    questions: number
  }

  export type Question_classesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Question_classesCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * Question_classesCountOutputType without action
   */
  export type Question_classesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question_classesCountOutputType
     */
    select?: Question_classesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Question_classesCountOutputType without action
   */
  export type Question_classesCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type QuestionsCountOutputType
   */

  export type QuestionsCountOutputType = {
    answers: number
  }

  export type QuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuestionsCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsCountOutputType
     */
    select?: QuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
  }


  /**
   * Count Type LevelsCountOutputType
   */

  export type LevelsCountOutputType = {
    benefits: number
    users: number
  }

  export type LevelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benefits?: boolean | LevelsCountOutputTypeCountBenefitsArgs
    users?: boolean | LevelsCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * LevelsCountOutputType without action
   */
  export type LevelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelsCountOutputType
     */
    select?: LevelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelsCountOutputType without action
   */
  export type LevelsCountOutputTypeCountBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: benefitsWhereInput
  }

  /**
   * LevelsCountOutputType without action
   */
  export type LevelsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    answers: number
    pitchViews: number
    ratings: number
    forYouBrands: number
    forYouBrandsPool: number
    notInterestedBrands: number
    linkVisits: number
    brandScreenTimes: number
    feedbacks: number
    productionSubmissions: number
    dealCodes: number
    brandUnlockHistory: number
    categoryChoices: number
    likedPosts: number
    pushNotificationHistory: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | UsersCountOutputTypeCountAnswersArgs
    pitchViews?: boolean | UsersCountOutputTypeCountPitchViewsArgs
    ratings?: boolean | UsersCountOutputTypeCountRatingsArgs
    forYouBrands?: boolean | UsersCountOutputTypeCountForYouBrandsArgs
    forYouBrandsPool?: boolean | UsersCountOutputTypeCountForYouBrandsPoolArgs
    notInterestedBrands?: boolean | UsersCountOutputTypeCountNotInterestedBrandsArgs
    linkVisits?: boolean | UsersCountOutputTypeCountLinkVisitsArgs
    brandScreenTimes?: boolean | UsersCountOutputTypeCountBrandScreenTimesArgs
    feedbacks?: boolean | UsersCountOutputTypeCountFeedbacksArgs
    productionSubmissions?: boolean | UsersCountOutputTypeCountProductionSubmissionsArgs
    dealCodes?: boolean | UsersCountOutputTypeCountDealCodesArgs
    brandUnlockHistory?: boolean | UsersCountOutputTypeCountBrandUnlockHistoryArgs
    categoryChoices?: boolean | UsersCountOutputTypeCountCategoryChoicesArgs
    likedPosts?: boolean | UsersCountOutputTypeCountLikedPostsArgs
    pushNotificationHistory?: boolean | UsersCountOutputTypeCountPushNotificationHistoryArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPitchViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pitch_viewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountForYouBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountForYouBrandsPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotInterestedBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLinkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: link_visitsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBrandScreenTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brand_screen_timesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbackWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountProductionSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: production_submissionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDealCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deal_codesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBrandUnlockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unlocked_brands_historyWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCategoryChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_choicesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLikedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPushNotificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: push_notification_historyWhereInput
  }


  /**
   * Count Type Deal_code_groupsCountOutputType
   */

  export type Deal_code_groupsCountOutputType = {
    dealCodes: number
  }

  export type Deal_code_groupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dealCodes?: boolean | Deal_code_groupsCountOutputTypeCountDealCodesArgs
  }

  // Custom InputTypes
  /**
   * Deal_code_groupsCountOutputType without action
   */
  export type Deal_code_groupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal_code_groupsCountOutputType
     */
    select?: Deal_code_groupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Deal_code_groupsCountOutputType without action
   */
  export type Deal_code_groupsCountOutputTypeCountDealCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deal_codesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model order_history
   */

  export type AggregateOrder_history = {
    _count: Order_historyCountAggregateOutputType | null
    _min: Order_historyMinAggregateOutputType | null
    _max: Order_historyMaxAggregateOutputType | null
  }

  export type Order_historyMinAggregateOutputType = {
    id: string | null
    brandId: string | null
    brandName: string | null
    createdAt: Date | null
  }

  export type Order_historyMaxAggregateOutputType = {
    id: string | null
    brandId: string | null
    brandName: string | null
    createdAt: Date | null
  }

  export type Order_historyCountAggregateOutputType = {
    id: number
    brandId: number
    brandName: number
    dealCodes: number
    orderJson: number
    createdAt: number
    _all: number
  }


  export type Order_historyMinAggregateInputType = {
    id?: true
    brandId?: true
    brandName?: true
    createdAt?: true
  }

  export type Order_historyMaxAggregateInputType = {
    id?: true
    brandId?: true
    brandName?: true
    createdAt?: true
  }

  export type Order_historyCountAggregateInputType = {
    id?: true
    brandId?: true
    brandName?: true
    dealCodes?: true
    orderJson?: true
    createdAt?: true
    _all?: true
  }

  export type Order_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_history to aggregate.
     */
    where?: order_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_histories to fetch.
     */
    orderBy?: order_historyOrderByWithRelationInput | order_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_histories
    **/
    _count?: true | Order_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_historyMaxAggregateInputType
  }

  export type GetOrder_historyAggregateType<T extends Order_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_history[P]>
      : GetScalarType<T[P], AggregateOrder_history[P]>
  }




  export type order_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_historyWhereInput
    orderBy?: order_historyOrderByWithAggregationInput | order_historyOrderByWithAggregationInput[]
    by: Order_historyScalarFieldEnum[] | Order_historyScalarFieldEnum
    having?: order_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_historyCountAggregateInputType | true
    _min?: Order_historyMinAggregateInputType
    _max?: Order_historyMaxAggregateInputType
  }

  export type Order_historyGroupByOutputType = {
    id: string
    brandId: string
    brandName: string
    dealCodes: string[]
    orderJson: JsonValue
    createdAt: Date
    _count: Order_historyCountAggregateOutputType | null
    _min: Order_historyMinAggregateOutputType | null
    _max: Order_historyMaxAggregateOutputType | null
  }

  type GetOrder_historyGroupByPayload<T extends order_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Order_historyGroupByOutputType[P]>
        }
      >
    >


  export type order_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    brandName?: boolean
    dealCodes?: boolean
    orderJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["order_history"]>


  export type order_historySelectScalar = {
    id?: boolean
    brandId?: boolean
    brandName?: boolean
    dealCodes?: boolean
    orderJson?: boolean
    createdAt?: boolean
  }


  export type $order_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      brandId: string
      brandName: string
      dealCodes: string[]
      orderJson: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["order_history"]>
    composites: {}
  }

  type order_historyGetPayload<S extends boolean | null | undefined | order_historyDefaultArgs> = $Result.GetResult<Prisma.$order_historyPayload, S>

  type order_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<order_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Order_historyCountAggregateInputType | true
    }

  export interface order_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_history'], meta: { name: 'order_history' } }
    /**
     * Find zero or one Order_history that matches the filter.
     * @param {order_historyFindUniqueArgs} args - Arguments to find a Order_history
     * @example
     * // Get one Order_history
     * const order_history = await prisma.order_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_historyFindUniqueArgs>(args: SelectSubset<T, order_historyFindUniqueArgs<ExtArgs>>): Prisma__order_historyClient<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {order_historyFindUniqueOrThrowArgs} args - Arguments to find a Order_history
     * @example
     * // Get one Order_history
     * const order_history = await prisma.order_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, order_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_historyClient<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_historyFindFirstArgs} args - Arguments to find a Order_history
     * @example
     * // Get one Order_history
     * const order_history = await prisma.order_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_historyFindFirstArgs>(args?: SelectSubset<T, order_historyFindFirstArgs<ExtArgs>>): Prisma__order_historyClient<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_historyFindFirstOrThrowArgs} args - Arguments to find a Order_history
     * @example
     * // Get one Order_history
     * const order_history = await prisma.order_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, order_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_historyClient<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Order_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_histories
     * const order_histories = await prisma.order_history.findMany()
     * 
     * // Get first 10 Order_histories
     * const order_histories = await prisma.order_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const order_historyWithIdOnly = await prisma.order_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends order_historyFindManyArgs>(args?: SelectSubset<T, order_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order_history.
     * @param {order_historyCreateArgs} args - Arguments to create a Order_history.
     * @example
     * // Create one Order_history
     * const Order_history = await prisma.order_history.create({
     *   data: {
     *     // ... data to create a Order_history
     *   }
     * })
     * 
     */
    create<T extends order_historyCreateArgs>(args: SelectSubset<T, order_historyCreateArgs<ExtArgs>>): Prisma__order_historyClient<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Order_histories.
     * @param {order_historyCreateManyArgs} args - Arguments to create many Order_histories.
     * @example
     * // Create many Order_histories
     * const order_history = await prisma.order_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_historyCreateManyArgs>(args?: SelectSubset<T, order_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order_history.
     * @param {order_historyDeleteArgs} args - Arguments to delete one Order_history.
     * @example
     * // Delete one Order_history
     * const Order_history = await prisma.order_history.delete({
     *   where: {
     *     // ... filter to delete one Order_history
     *   }
     * })
     * 
     */
    delete<T extends order_historyDeleteArgs>(args: SelectSubset<T, order_historyDeleteArgs<ExtArgs>>): Prisma__order_historyClient<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order_history.
     * @param {order_historyUpdateArgs} args - Arguments to update one Order_history.
     * @example
     * // Update one Order_history
     * const order_history = await prisma.order_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_historyUpdateArgs>(args: SelectSubset<T, order_historyUpdateArgs<ExtArgs>>): Prisma__order_historyClient<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Order_histories.
     * @param {order_historyDeleteManyArgs} args - Arguments to filter Order_histories to delete.
     * @example
     * // Delete a few Order_histories
     * const { count } = await prisma.order_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_historyDeleteManyArgs>(args?: SelectSubset<T, order_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_histories
     * const order_history = await prisma.order_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_historyUpdateManyArgs>(args: SelectSubset<T, order_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_history.
     * @param {order_historyUpsertArgs} args - Arguments to update or create a Order_history.
     * @example
     * // Update or create a Order_history
     * const order_history = await prisma.order_history.upsert({
     *   create: {
     *     // ... data to create a Order_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_history we want to update
     *   }
     * })
     */
    upsert<T extends order_historyUpsertArgs>(args: SelectSubset<T, order_historyUpsertArgs<ExtArgs>>): Prisma__order_historyClient<$Result.GetResult<Prisma.$order_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Order_histories that matches the filter.
     * @param {order_historyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const order_history = await prisma.order_history.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: order_historyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Order_history.
     * @param {order_historyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const order_history = await prisma.order_history.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: order_historyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Order_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_historyCountArgs} args - Arguments to filter Order_histories to count.
     * @example
     * // Count the number of Order_histories
     * const count = await prisma.order_history.count({
     *   where: {
     *     // ... the filter for the Order_histories we want to count
     *   }
     * })
    **/
    count<T extends order_historyCountArgs>(
      args?: Subset<T, order_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_historyAggregateArgs>(args: Subset<T, Order_historyAggregateArgs>): Prisma.PrismaPromise<GetOrder_historyAggregateType<T>>

    /**
     * Group by Order_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_historyGroupByArgs['orderBy'] }
        : { orderBy?: order_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_history model
   */
  readonly fields: order_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_history model
   */ 
  interface order_historyFieldRefs {
    readonly id: FieldRef<"order_history", 'String'>
    readonly brandId: FieldRef<"order_history", 'String'>
    readonly brandName: FieldRef<"order_history", 'String'>
    readonly dealCodes: FieldRef<"order_history", 'String[]'>
    readonly orderJson: FieldRef<"order_history", 'Json'>
    readonly createdAt: FieldRef<"order_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * order_history findUnique
   */
  export type order_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * Filter, which order_history to fetch.
     */
    where: order_historyWhereUniqueInput
  }

  /**
   * order_history findUniqueOrThrow
   */
  export type order_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * Filter, which order_history to fetch.
     */
    where: order_historyWhereUniqueInput
  }

  /**
   * order_history findFirst
   */
  export type order_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * Filter, which order_history to fetch.
     */
    where?: order_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_histories to fetch.
     */
    orderBy?: order_historyOrderByWithRelationInput | order_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_histories.
     */
    cursor?: order_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_histories.
     */
    distinct?: Order_historyScalarFieldEnum | Order_historyScalarFieldEnum[]
  }

  /**
   * order_history findFirstOrThrow
   */
  export type order_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * Filter, which order_history to fetch.
     */
    where?: order_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_histories to fetch.
     */
    orderBy?: order_historyOrderByWithRelationInput | order_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_histories.
     */
    cursor?: order_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_histories.
     */
    distinct?: Order_historyScalarFieldEnum | Order_historyScalarFieldEnum[]
  }

  /**
   * order_history findMany
   */
  export type order_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * Filter, which order_histories to fetch.
     */
    where?: order_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_histories to fetch.
     */
    orderBy?: order_historyOrderByWithRelationInput | order_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_histories.
     */
    cursor?: order_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_histories.
     */
    skip?: number
    distinct?: Order_historyScalarFieldEnum | Order_historyScalarFieldEnum[]
  }

  /**
   * order_history create
   */
  export type order_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * The data needed to create a order_history.
     */
    data: XOR<order_historyCreateInput, order_historyUncheckedCreateInput>
  }

  /**
   * order_history createMany
   */
  export type order_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_histories.
     */
    data: order_historyCreateManyInput | order_historyCreateManyInput[]
  }

  /**
   * order_history update
   */
  export type order_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * The data needed to update a order_history.
     */
    data: XOR<order_historyUpdateInput, order_historyUncheckedUpdateInput>
    /**
     * Choose, which order_history to update.
     */
    where: order_historyWhereUniqueInput
  }

  /**
   * order_history updateMany
   */
  export type order_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_histories.
     */
    data: XOR<order_historyUpdateManyMutationInput, order_historyUncheckedUpdateManyInput>
    /**
     * Filter which order_histories to update
     */
    where?: order_historyWhereInput
  }

  /**
   * order_history upsert
   */
  export type order_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * The filter to search for the order_history to update in case it exists.
     */
    where: order_historyWhereUniqueInput
    /**
     * In case the order_history found by the `where` argument doesn't exist, create a new order_history with this data.
     */
    create: XOR<order_historyCreateInput, order_historyUncheckedCreateInput>
    /**
     * In case the order_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_historyUpdateInput, order_historyUncheckedUpdateInput>
  }

  /**
   * order_history delete
   */
  export type order_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
    /**
     * Filter which order_history to delete.
     */
    where: order_historyWhereUniqueInput
  }

  /**
   * order_history deleteMany
   */
  export type order_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_histories to delete
     */
    where?: order_historyWhereInput
  }

  /**
   * order_history findRaw
   */
  export type order_historyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * order_history aggregateRaw
   */
  export type order_historyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * order_history without action
   */
  export type order_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_history
     */
    select?: order_historySelect<ExtArgs> | null
  }


  /**
   * Model answers
   */

  export type AggregateAnswers = {
    _count: AnswersCountAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  export type AnswersMinAggregateOutputType = {
    id: string | null
    userId: string | null
    questionId: string | null
    productFeedbackBrandId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pitchExitBrandId: string | null
  }

  export type AnswersMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    questionId: string | null
    productFeedbackBrandId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pitchExitBrandId: string | null
  }

  export type AnswersCountAggregateOutputType = {
    id: number
    userId: number
    questionId: number
    questionText: number
    answer: number
    productFeedbackBrandId: number
    createdAt: number
    updatedAt: number
    pitchExitBrandId: number
    _all: number
  }


  export type AnswersMinAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    productFeedbackBrandId?: true
    createdAt?: true
    updatedAt?: true
    pitchExitBrandId?: true
  }

  export type AnswersMaxAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    productFeedbackBrandId?: true
    createdAt?: true
    updatedAt?: true
    pitchExitBrandId?: true
  }

  export type AnswersCountAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    questionText?: true
    answer?: true
    productFeedbackBrandId?: true
    createdAt?: true
    updatedAt?: true
    pitchExitBrandId?: true
    _all?: true
  }

  export type AnswersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which answers to aggregate.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned answers
    **/
    _count?: true | AnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswersMaxAggregateInputType
  }

  export type GetAnswersAggregateType<T extends AnswersAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswers[P]>
      : GetScalarType<T[P], AggregateAnswers[P]>
  }




  export type answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
    orderBy?: answersOrderByWithAggregationInput | answersOrderByWithAggregationInput[]
    by: AnswersScalarFieldEnum[] | AnswersScalarFieldEnum
    having?: answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswersCountAggregateInputType | true
    _min?: AnswersMinAggregateInputType
    _max?: AnswersMaxAggregateInputType
  }

  export type AnswersGroupByOutputType = {
    id: string
    userId: string
    questionId: string | null
    questionText: JsonValue
    answer: JsonValue
    productFeedbackBrandId: string | null
    createdAt: Date
    updatedAt: Date
    pitchExitBrandId: string | null
    _count: AnswersCountAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  type GetAnswersGroupByPayload<T extends answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswersGroupByOutputType[P]>
            : GetScalarType<T[P], AnswersGroupByOutputType[P]>
        }
      >
    >


  export type answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    questionText?: boolean
    answer?: boolean
    productFeedbackBrandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pitchExitBrandId?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    question?: boolean | answers$questionArgs<ExtArgs>
    productFeedbackBrand?: boolean | answers$productFeedbackBrandArgs<ExtArgs>
    pitchExitBrand?: boolean | answers$pitchExitBrandArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>


  export type answersSelectScalar = {
    id?: boolean
    userId?: boolean
    questionId?: boolean
    questionText?: boolean
    answer?: boolean
    productFeedbackBrandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pitchExitBrandId?: boolean
  }

  export type answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    question?: boolean | answers$questionArgs<ExtArgs>
    productFeedbackBrand?: boolean | answers$productFeedbackBrandArgs<ExtArgs>
    pitchExitBrand?: boolean | answers$pitchExitBrandArgs<ExtArgs>
  }

  export type $answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "answers"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      question: Prisma.$questionsPayload<ExtArgs> | null
      productFeedbackBrand: Prisma.$brandsPayload<ExtArgs> | null
      pitchExitBrand: Prisma.$brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      questionId: string | null
      questionText: Prisma.JsonValue
      answer: Prisma.JsonValue
      productFeedbackBrandId: string | null
      createdAt: Date
      updatedAt: Date
      pitchExitBrandId: string | null
    }, ExtArgs["result"]["answers"]>
    composites: {}
  }

  type answersGetPayload<S extends boolean | null | undefined | answersDefaultArgs> = $Result.GetResult<Prisma.$answersPayload, S>

  type answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<answersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnswersCountAggregateInputType | true
    }

  export interface answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['answers'], meta: { name: 'answers' } }
    /**
     * Find zero or one Answers that matches the filter.
     * @param {answersFindUniqueArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends answersFindUniqueArgs>(args: SelectSubset<T, answersFindUniqueArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Answers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {answersFindUniqueOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends answersFindUniqueOrThrowArgs>(args: SelectSubset<T, answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindFirstArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends answersFindFirstArgs>(args?: SelectSubset<T, answersFindFirstArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindFirstOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends answersFindFirstOrThrowArgs>(args?: SelectSubset<T, answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answers.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answersWithIdOnly = await prisma.answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends answersFindManyArgs>(args?: SelectSubset<T, answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Answers.
     * @param {answersCreateArgs} args - Arguments to create a Answers.
     * @example
     * // Create one Answers
     * const Answers = await prisma.answers.create({
     *   data: {
     *     // ... data to create a Answers
     *   }
     * })
     * 
     */
    create<T extends answersCreateArgs>(args: SelectSubset<T, answersCreateArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Answers.
     * @param {answersCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answers = await prisma.answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends answersCreateManyArgs>(args?: SelectSubset<T, answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Answers.
     * @param {answersDeleteArgs} args - Arguments to delete one Answers.
     * @example
     * // Delete one Answers
     * const Answers = await prisma.answers.delete({
     *   where: {
     *     // ... filter to delete one Answers
     *   }
     * })
     * 
     */
    delete<T extends answersDeleteArgs>(args: SelectSubset<T, answersDeleteArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Answers.
     * @param {answersUpdateArgs} args - Arguments to update one Answers.
     * @example
     * // Update one Answers
     * const answers = await prisma.answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends answersUpdateArgs>(args: SelectSubset<T, answersUpdateArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Answers.
     * @param {answersDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends answersDeleteManyArgs>(args?: SelectSubset<T, answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends answersUpdateManyArgs>(args: SelectSubset<T, answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Answers.
     * @param {answersUpsertArgs} args - Arguments to update or create a Answers.
     * @example
     * // Update or create a Answers
     * const answers = await prisma.answers.upsert({
     *   create: {
     *     // ... data to create a Answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answers we want to update
     *   }
     * })
     */
    upsert<T extends answersUpsertArgs>(args: SelectSubset<T, answersUpsertArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Answers that matches the filter.
     * @param {answersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const answers = await prisma.answers.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: answersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Answers.
     * @param {answersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const answers = await prisma.answers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: answersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answers.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends answersCountArgs>(
      args?: Subset<T, answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswersAggregateArgs>(args: Subset<T, AnswersAggregateArgs>): Prisma.PrismaPromise<GetAnswersAggregateType<T>>

    /**
     * Group by Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: answersGroupByArgs['orderBy'] }
        : { orderBy?: answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the answers model
   */
  readonly fields: answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    question<T extends answers$questionArgs<ExtArgs> = {}>(args?: Subset<T, answers$questionArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    productFeedbackBrand<T extends answers$productFeedbackBrandArgs<ExtArgs> = {}>(args?: Subset<T, answers$productFeedbackBrandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pitchExitBrand<T extends answers$pitchExitBrandArgs<ExtArgs> = {}>(args?: Subset<T, answers$pitchExitBrandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the answers model
   */ 
  interface answersFieldRefs {
    readonly id: FieldRef<"answers", 'String'>
    readonly userId: FieldRef<"answers", 'String'>
    readonly questionId: FieldRef<"answers", 'String'>
    readonly questionText: FieldRef<"answers", 'Json'>
    readonly answer: FieldRef<"answers", 'Json'>
    readonly productFeedbackBrandId: FieldRef<"answers", 'String'>
    readonly createdAt: FieldRef<"answers", 'DateTime'>
    readonly updatedAt: FieldRef<"answers", 'DateTime'>
    readonly pitchExitBrandId: FieldRef<"answers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * answers findUnique
   */
  export type answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers findUniqueOrThrow
   */
  export type answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers findFirst
   */
  export type answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers findFirstOrThrow
   */
  export type answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers findMany
   */
  export type answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers create
   */
  export type answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The data needed to create a answers.
     */
    data: XOR<answersCreateInput, answersUncheckedCreateInput>
  }

  /**
   * answers createMany
   */
  export type answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many answers.
     */
    data: answersCreateManyInput | answersCreateManyInput[]
  }

  /**
   * answers update
   */
  export type answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The data needed to update a answers.
     */
    data: XOR<answersUpdateInput, answersUncheckedUpdateInput>
    /**
     * Choose, which answers to update.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers updateMany
   */
  export type answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update answers.
     */
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyInput>
    /**
     * Filter which answers to update
     */
    where?: answersWhereInput
  }

  /**
   * answers upsert
   */
  export type answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The filter to search for the answers to update in case it exists.
     */
    where: answersWhereUniqueInput
    /**
     * In case the answers found by the `where` argument doesn't exist, create a new answers with this data.
     */
    create: XOR<answersCreateInput, answersUncheckedCreateInput>
    /**
     * In case the answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<answersUpdateInput, answersUncheckedUpdateInput>
  }

  /**
   * answers delete
   */
  export type answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter which answers to delete.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers deleteMany
   */
  export type answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which answers to delete
     */
    where?: answersWhereInput
  }

  /**
   * answers findRaw
   */
  export type answersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * answers aggregateRaw
   */
  export type answersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * answers.question
   */
  export type answers$questionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
  }

  /**
   * answers.productFeedbackBrand
   */
  export type answers$productFeedbackBrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * answers.pitchExitBrand
   */
  export type answers$pitchExitBrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * answers without action
   */
  export type answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
  }


  /**
   * Model app_versions
   */

  export type AggregateApp_versions = {
    _count: App_versionsCountAggregateOutputType | null
    _min: App_versionsMinAggregateOutputType | null
    _max: App_versionsMaxAggregateOutputType | null
  }

  export type App_versionsMinAggregateOutputType = {
    id: string | null
    version: string | null
    critical: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type App_versionsMaxAggregateOutputType = {
    id: string | null
    version: string | null
    critical: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type App_versionsCountAggregateOutputType = {
    id: number
    version: number
    critical: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type App_versionsMinAggregateInputType = {
    id?: true
    version?: true
    critical?: true
    createdAt?: true
    updatedAt?: true
  }

  export type App_versionsMaxAggregateInputType = {
    id?: true
    version?: true
    critical?: true
    createdAt?: true
    updatedAt?: true
  }

  export type App_versionsCountAggregateInputType = {
    id?: true
    version?: true
    critical?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type App_versionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_versions to aggregate.
     */
    where?: app_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_versions to fetch.
     */
    orderBy?: app_versionsOrderByWithRelationInput | app_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_versions
    **/
    _count?: true | App_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_versionsMaxAggregateInputType
  }

  export type GetApp_versionsAggregateType<T extends App_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_versions[P]>
      : GetScalarType<T[P], AggregateApp_versions[P]>
  }




  export type app_versionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_versionsWhereInput
    orderBy?: app_versionsOrderByWithAggregationInput | app_versionsOrderByWithAggregationInput[]
    by: App_versionsScalarFieldEnum[] | App_versionsScalarFieldEnum
    having?: app_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_versionsCountAggregateInputType | true
    _min?: App_versionsMinAggregateInputType
    _max?: App_versionsMaxAggregateInputType
  }

  export type App_versionsGroupByOutputType = {
    id: string
    version: string
    critical: boolean
    createdAt: Date
    updatedAt: Date
    _count: App_versionsCountAggregateOutputType | null
    _min: App_versionsMinAggregateOutputType | null
    _max: App_versionsMaxAggregateOutputType | null
  }

  type GetApp_versionsGroupByPayload<T extends app_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], App_versionsGroupByOutputType[P]>
        }
      >
    >


  export type app_versionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    critical?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["app_versions"]>


  export type app_versionsSelectScalar = {
    id?: boolean
    version?: boolean
    critical?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $app_versionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_versions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      critical: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["app_versions"]>
    composites: {}
  }

  type app_versionsGetPayload<S extends boolean | null | undefined | app_versionsDefaultArgs> = $Result.GetResult<Prisma.$app_versionsPayload, S>

  type app_versionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_versionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: App_versionsCountAggregateInputType | true
    }

  export interface app_versionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_versions'], meta: { name: 'app_versions' } }
    /**
     * Find zero or one App_versions that matches the filter.
     * @param {app_versionsFindUniqueArgs} args - Arguments to find a App_versions
     * @example
     * // Get one App_versions
     * const app_versions = await prisma.app_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_versionsFindUniqueArgs>(args: SelectSubset<T, app_versionsFindUniqueArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one App_versions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {app_versionsFindUniqueOrThrowArgs} args - Arguments to find a App_versions
     * @example
     * // Get one App_versions
     * const app_versions = await prisma.app_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_versionsFindUniqueOrThrowArgs>(args: SelectSubset<T, app_versionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first App_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsFindFirstArgs} args - Arguments to find a App_versions
     * @example
     * // Get one App_versions
     * const app_versions = await prisma.app_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_versionsFindFirstArgs>(args?: SelectSubset<T, app_versionsFindFirstArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first App_versions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsFindFirstOrThrowArgs} args - Arguments to find a App_versions
     * @example
     * // Get one App_versions
     * const app_versions = await prisma.app_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_versionsFindFirstOrThrowArgs>(args?: SelectSubset<T, app_versionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more App_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_versions
     * const app_versions = await prisma.app_versions.findMany()
     * 
     * // Get first 10 App_versions
     * const app_versions = await prisma.app_versions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_versionsWithIdOnly = await prisma.app_versions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_versionsFindManyArgs>(args?: SelectSubset<T, app_versionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a App_versions.
     * @param {app_versionsCreateArgs} args - Arguments to create a App_versions.
     * @example
     * // Create one App_versions
     * const App_versions = await prisma.app_versions.create({
     *   data: {
     *     // ... data to create a App_versions
     *   }
     * })
     * 
     */
    create<T extends app_versionsCreateArgs>(args: SelectSubset<T, app_versionsCreateArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many App_versions.
     * @param {app_versionsCreateManyArgs} args - Arguments to create many App_versions.
     * @example
     * // Create many App_versions
     * const app_versions = await prisma.app_versions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_versionsCreateManyArgs>(args?: SelectSubset<T, app_versionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a App_versions.
     * @param {app_versionsDeleteArgs} args - Arguments to delete one App_versions.
     * @example
     * // Delete one App_versions
     * const App_versions = await prisma.app_versions.delete({
     *   where: {
     *     // ... filter to delete one App_versions
     *   }
     * })
     * 
     */
    delete<T extends app_versionsDeleteArgs>(args: SelectSubset<T, app_versionsDeleteArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one App_versions.
     * @param {app_versionsUpdateArgs} args - Arguments to update one App_versions.
     * @example
     * // Update one App_versions
     * const app_versions = await prisma.app_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_versionsUpdateArgs>(args: SelectSubset<T, app_versionsUpdateArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more App_versions.
     * @param {app_versionsDeleteManyArgs} args - Arguments to filter App_versions to delete.
     * @example
     * // Delete a few App_versions
     * const { count } = await prisma.app_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_versionsDeleteManyArgs>(args?: SelectSubset<T, app_versionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_versions
     * const app_versions = await prisma.app_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_versionsUpdateManyArgs>(args: SelectSubset<T, app_versionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_versions.
     * @param {app_versionsUpsertArgs} args - Arguments to update or create a App_versions.
     * @example
     * // Update or create a App_versions
     * const app_versions = await prisma.app_versions.upsert({
     *   create: {
     *     // ... data to create a App_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_versions we want to update
     *   }
     * })
     */
    upsert<T extends app_versionsUpsertArgs>(args: SelectSubset<T, app_versionsUpsertArgs<ExtArgs>>): Prisma__app_versionsClient<$Result.GetResult<Prisma.$app_versionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more App_versions that matches the filter.
     * @param {app_versionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const app_versions = await prisma.app_versions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: app_versionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a App_versions.
     * @param {app_versionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const app_versions = await prisma.app_versions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: app_versionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of App_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsCountArgs} args - Arguments to filter App_versions to count.
     * @example
     * // Count the number of App_versions
     * const count = await prisma.app_versions.count({
     *   where: {
     *     // ... the filter for the App_versions we want to count
     *   }
     * })
    **/
    count<T extends app_versionsCountArgs>(
      args?: Subset<T, app_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_versionsAggregateArgs>(args: Subset<T, App_versionsAggregateArgs>): Prisma.PrismaPromise<GetApp_versionsAggregateType<T>>

    /**
     * Group by App_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_versionsGroupByArgs['orderBy'] }
        : { orderBy?: app_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_versions model
   */
  readonly fields: app_versionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_versionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_versions model
   */ 
  interface app_versionsFieldRefs {
    readonly id: FieldRef<"app_versions", 'String'>
    readonly version: FieldRef<"app_versions", 'String'>
    readonly critical: FieldRef<"app_versions", 'Boolean'>
    readonly createdAt: FieldRef<"app_versions", 'DateTime'>
    readonly updatedAt: FieldRef<"app_versions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * app_versions findUnique
   */
  export type app_versionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where: app_versionsWhereUniqueInput
  }

  /**
   * app_versions findUniqueOrThrow
   */
  export type app_versionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where: app_versionsWhereUniqueInput
  }

  /**
   * app_versions findFirst
   */
  export type app_versionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where?: app_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_versions to fetch.
     */
    orderBy?: app_versionsOrderByWithRelationInput | app_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_versions.
     */
    cursor?: app_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_versions.
     */
    distinct?: App_versionsScalarFieldEnum | App_versionsScalarFieldEnum[]
  }

  /**
   * app_versions findFirstOrThrow
   */
  export type app_versionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where?: app_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_versions to fetch.
     */
    orderBy?: app_versionsOrderByWithRelationInput | app_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_versions.
     */
    cursor?: app_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_versions.
     */
    distinct?: App_versionsScalarFieldEnum | App_versionsScalarFieldEnum[]
  }

  /**
   * app_versions findMany
   */
  export type app_versionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter, which app_versions to fetch.
     */
    where?: app_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_versions to fetch.
     */
    orderBy?: app_versionsOrderByWithRelationInput | app_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_versions.
     */
    cursor?: app_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_versions.
     */
    skip?: number
    distinct?: App_versionsScalarFieldEnum | App_versionsScalarFieldEnum[]
  }

  /**
   * app_versions create
   */
  export type app_versionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * The data needed to create a app_versions.
     */
    data: XOR<app_versionsCreateInput, app_versionsUncheckedCreateInput>
  }

  /**
   * app_versions createMany
   */
  export type app_versionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_versions.
     */
    data: app_versionsCreateManyInput | app_versionsCreateManyInput[]
  }

  /**
   * app_versions update
   */
  export type app_versionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * The data needed to update a app_versions.
     */
    data: XOR<app_versionsUpdateInput, app_versionsUncheckedUpdateInput>
    /**
     * Choose, which app_versions to update.
     */
    where: app_versionsWhereUniqueInput
  }

  /**
   * app_versions updateMany
   */
  export type app_versionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_versions.
     */
    data: XOR<app_versionsUpdateManyMutationInput, app_versionsUncheckedUpdateManyInput>
    /**
     * Filter which app_versions to update
     */
    where?: app_versionsWhereInput
  }

  /**
   * app_versions upsert
   */
  export type app_versionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * The filter to search for the app_versions to update in case it exists.
     */
    where: app_versionsWhereUniqueInput
    /**
     * In case the app_versions found by the `where` argument doesn't exist, create a new app_versions with this data.
     */
    create: XOR<app_versionsCreateInput, app_versionsUncheckedCreateInput>
    /**
     * In case the app_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_versionsUpdateInput, app_versionsUncheckedUpdateInput>
  }

  /**
   * app_versions delete
   */
  export type app_versionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
    /**
     * Filter which app_versions to delete.
     */
    where: app_versionsWhereUniqueInput
  }

  /**
   * app_versions deleteMany
   */
  export type app_versionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_versions to delete
     */
    where?: app_versionsWhereInput
  }

  /**
   * app_versions findRaw
   */
  export type app_versionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * app_versions aggregateRaw
   */
  export type app_versionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * app_versions without action
   */
  export type app_versionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_versions
     */
    select?: app_versionsSelect<ExtArgs> | null
  }


  /**
   * Model benefits
   */

  export type AggregateBenefits = {
    _count: BenefitsCountAggregateOutputType | null
    _min: BenefitsMinAggregateOutputType | null
    _max: BenefitsMaxAggregateOutputType | null
  }

  export type BenefitsMinAggregateOutputType = {
    id: string | null
    title: string | null
    redeemLink: string | null
    levelId: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BenefitsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    redeemLink: string | null
    levelId: string | null
    code: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BenefitsCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    description: number
    logo: number
    image: number
    redeemLink: number
    levelId: number
    tags: number
    code: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BenefitsMinAggregateInputType = {
    id?: true
    title?: true
    redeemLink?: true
    levelId?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BenefitsMaxAggregateInputType = {
    id?: true
    title?: true
    redeemLink?: true
    levelId?: true
    code?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BenefitsCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    logo?: true
    image?: true
    redeemLink?: true
    levelId?: true
    tags?: true
    code?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BenefitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which benefits to aggregate.
     */
    where?: benefitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of benefits to fetch.
     */
    orderBy?: benefitsOrderByWithRelationInput | benefitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: benefitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned benefits
    **/
    _count?: true | BenefitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenefitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenefitsMaxAggregateInputType
  }

  export type GetBenefitsAggregateType<T extends BenefitsAggregateArgs> = {
        [P in keyof T & keyof AggregateBenefits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenefits[P]>
      : GetScalarType<T[P], AggregateBenefits[P]>
  }




  export type benefitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: benefitsWhereInput
    orderBy?: benefitsOrderByWithAggregationInput | benefitsOrderByWithAggregationInput[]
    by: BenefitsScalarFieldEnum[] | BenefitsScalarFieldEnum
    having?: benefitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenefitsCountAggregateInputType | true
    _min?: BenefitsMinAggregateInputType
    _max?: BenefitsMaxAggregateInputType
  }

  export type BenefitsGroupByOutputType = {
    id: string
    title: string
    subtitle: JsonValue
    description: JsonValue
    logo: JsonValue | null
    image: JsonValue | null
    redeemLink: string
    levelId: string | null
    tags: JsonValue[]
    code: string | null
    createdAt: Date
    updatedAt: Date
    _count: BenefitsCountAggregateOutputType | null
    _min: BenefitsMinAggregateOutputType | null
    _max: BenefitsMaxAggregateOutputType | null
  }

  type GetBenefitsGroupByPayload<T extends benefitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BenefitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenefitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenefitsGroupByOutputType[P]>
            : GetScalarType<T[P], BenefitsGroupByOutputType[P]>
        }
      >
    >


  export type benefitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    logo?: boolean
    image?: boolean
    redeemLink?: boolean
    levelId?: boolean
    tags?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | benefits$levelArgs<ExtArgs>
    linkVisits?: boolean | benefits$linkVisitsArgs<ExtArgs>
    _count?: boolean | BenefitsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["benefits"]>


  export type benefitsSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    logo?: boolean
    image?: boolean
    redeemLink?: boolean
    levelId?: boolean
    tags?: boolean
    code?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type benefitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | benefits$levelArgs<ExtArgs>
    linkVisits?: boolean | benefits$linkVisitsArgs<ExtArgs>
    _count?: boolean | BenefitsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $benefitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "benefits"
    objects: {
      level: Prisma.$levelsPayload<ExtArgs> | null
      linkVisits: Prisma.$link_visitsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: Prisma.JsonValue
      description: Prisma.JsonValue
      logo: Prisma.JsonValue | null
      image: Prisma.JsonValue | null
      redeemLink: string
      levelId: string | null
      tags: Prisma.JsonValue[]
      code: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["benefits"]>
    composites: {}
  }

  type benefitsGetPayload<S extends boolean | null | undefined | benefitsDefaultArgs> = $Result.GetResult<Prisma.$benefitsPayload, S>

  type benefitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<benefitsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BenefitsCountAggregateInputType | true
    }

  export interface benefitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['benefits'], meta: { name: 'benefits' } }
    /**
     * Find zero or one Benefits that matches the filter.
     * @param {benefitsFindUniqueArgs} args - Arguments to find a Benefits
     * @example
     * // Get one Benefits
     * const benefits = await prisma.benefits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends benefitsFindUniqueArgs>(args: SelectSubset<T, benefitsFindUniqueArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Benefits that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {benefitsFindUniqueOrThrowArgs} args - Arguments to find a Benefits
     * @example
     * // Get one Benefits
     * const benefits = await prisma.benefits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends benefitsFindUniqueOrThrowArgs>(args: SelectSubset<T, benefitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Benefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitsFindFirstArgs} args - Arguments to find a Benefits
     * @example
     * // Get one Benefits
     * const benefits = await prisma.benefits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends benefitsFindFirstArgs>(args?: SelectSubset<T, benefitsFindFirstArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Benefits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitsFindFirstOrThrowArgs} args - Arguments to find a Benefits
     * @example
     * // Get one Benefits
     * const benefits = await prisma.benefits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends benefitsFindFirstOrThrowArgs>(args?: SelectSubset<T, benefitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Benefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Benefits
     * const benefits = await prisma.benefits.findMany()
     * 
     * // Get first 10 Benefits
     * const benefits = await prisma.benefits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benefitsWithIdOnly = await prisma.benefits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends benefitsFindManyArgs>(args?: SelectSubset<T, benefitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Benefits.
     * @param {benefitsCreateArgs} args - Arguments to create a Benefits.
     * @example
     * // Create one Benefits
     * const Benefits = await prisma.benefits.create({
     *   data: {
     *     // ... data to create a Benefits
     *   }
     * })
     * 
     */
    create<T extends benefitsCreateArgs>(args: SelectSubset<T, benefitsCreateArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Benefits.
     * @param {benefitsCreateManyArgs} args - Arguments to create many Benefits.
     * @example
     * // Create many Benefits
     * const benefits = await prisma.benefits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends benefitsCreateManyArgs>(args?: SelectSubset<T, benefitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Benefits.
     * @param {benefitsDeleteArgs} args - Arguments to delete one Benefits.
     * @example
     * // Delete one Benefits
     * const Benefits = await prisma.benefits.delete({
     *   where: {
     *     // ... filter to delete one Benefits
     *   }
     * })
     * 
     */
    delete<T extends benefitsDeleteArgs>(args: SelectSubset<T, benefitsDeleteArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Benefits.
     * @param {benefitsUpdateArgs} args - Arguments to update one Benefits.
     * @example
     * // Update one Benefits
     * const benefits = await prisma.benefits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends benefitsUpdateArgs>(args: SelectSubset<T, benefitsUpdateArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Benefits.
     * @param {benefitsDeleteManyArgs} args - Arguments to filter Benefits to delete.
     * @example
     * // Delete a few Benefits
     * const { count } = await prisma.benefits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends benefitsDeleteManyArgs>(args?: SelectSubset<T, benefitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Benefits
     * const benefits = await prisma.benefits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends benefitsUpdateManyArgs>(args: SelectSubset<T, benefitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Benefits.
     * @param {benefitsUpsertArgs} args - Arguments to update or create a Benefits.
     * @example
     * // Update or create a Benefits
     * const benefits = await prisma.benefits.upsert({
     *   create: {
     *     // ... data to create a Benefits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Benefits we want to update
     *   }
     * })
     */
    upsert<T extends benefitsUpsertArgs>(args: SelectSubset<T, benefitsUpsertArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Benefits that matches the filter.
     * @param {benefitsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const benefits = await prisma.benefits.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: benefitsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Benefits.
     * @param {benefitsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const benefits = await prisma.benefits.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: benefitsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitsCountArgs} args - Arguments to filter Benefits to count.
     * @example
     * // Count the number of Benefits
     * const count = await prisma.benefits.count({
     *   where: {
     *     // ... the filter for the Benefits we want to count
     *   }
     * })
    **/
    count<T extends benefitsCountArgs>(
      args?: Subset<T, benefitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenefitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenefitsAggregateArgs>(args: Subset<T, BenefitsAggregateArgs>): Prisma.PrismaPromise<GetBenefitsAggregateType<T>>

    /**
     * Group by Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends benefitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: benefitsGroupByArgs['orderBy'] }
        : { orderBy?: benefitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, benefitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenefitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the benefits model
   */
  readonly fields: benefitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for benefits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__benefitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    level<T extends benefits$levelArgs<ExtArgs> = {}>(args?: Subset<T, benefits$levelArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    linkVisits<T extends benefits$linkVisitsArgs<ExtArgs> = {}>(args?: Subset<T, benefits$linkVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the benefits model
   */ 
  interface benefitsFieldRefs {
    readonly id: FieldRef<"benefits", 'String'>
    readonly title: FieldRef<"benefits", 'String'>
    readonly subtitle: FieldRef<"benefits", 'Json'>
    readonly description: FieldRef<"benefits", 'Json'>
    readonly logo: FieldRef<"benefits", 'Json'>
    readonly image: FieldRef<"benefits", 'Json'>
    readonly redeemLink: FieldRef<"benefits", 'String'>
    readonly levelId: FieldRef<"benefits", 'String'>
    readonly tags: FieldRef<"benefits", 'Json[]'>
    readonly code: FieldRef<"benefits", 'String'>
    readonly createdAt: FieldRef<"benefits", 'DateTime'>
    readonly updatedAt: FieldRef<"benefits", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * benefits findUnique
   */
  export type benefitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * Filter, which benefits to fetch.
     */
    where: benefitsWhereUniqueInput
  }

  /**
   * benefits findUniqueOrThrow
   */
  export type benefitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * Filter, which benefits to fetch.
     */
    where: benefitsWhereUniqueInput
  }

  /**
   * benefits findFirst
   */
  export type benefitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * Filter, which benefits to fetch.
     */
    where?: benefitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of benefits to fetch.
     */
    orderBy?: benefitsOrderByWithRelationInput | benefitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for benefits.
     */
    cursor?: benefitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of benefits.
     */
    distinct?: BenefitsScalarFieldEnum | BenefitsScalarFieldEnum[]
  }

  /**
   * benefits findFirstOrThrow
   */
  export type benefitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * Filter, which benefits to fetch.
     */
    where?: benefitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of benefits to fetch.
     */
    orderBy?: benefitsOrderByWithRelationInput | benefitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for benefits.
     */
    cursor?: benefitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of benefits.
     */
    distinct?: BenefitsScalarFieldEnum | BenefitsScalarFieldEnum[]
  }

  /**
   * benefits findMany
   */
  export type benefitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * Filter, which benefits to fetch.
     */
    where?: benefitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of benefits to fetch.
     */
    orderBy?: benefitsOrderByWithRelationInput | benefitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing benefits.
     */
    cursor?: benefitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` benefits.
     */
    skip?: number
    distinct?: BenefitsScalarFieldEnum | BenefitsScalarFieldEnum[]
  }

  /**
   * benefits create
   */
  export type benefitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * The data needed to create a benefits.
     */
    data: XOR<benefitsCreateInput, benefitsUncheckedCreateInput>
  }

  /**
   * benefits createMany
   */
  export type benefitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many benefits.
     */
    data: benefitsCreateManyInput | benefitsCreateManyInput[]
  }

  /**
   * benefits update
   */
  export type benefitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * The data needed to update a benefits.
     */
    data: XOR<benefitsUpdateInput, benefitsUncheckedUpdateInput>
    /**
     * Choose, which benefits to update.
     */
    where: benefitsWhereUniqueInput
  }

  /**
   * benefits updateMany
   */
  export type benefitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update benefits.
     */
    data: XOR<benefitsUpdateManyMutationInput, benefitsUncheckedUpdateManyInput>
    /**
     * Filter which benefits to update
     */
    where?: benefitsWhereInput
  }

  /**
   * benefits upsert
   */
  export type benefitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * The filter to search for the benefits to update in case it exists.
     */
    where: benefitsWhereUniqueInput
    /**
     * In case the benefits found by the `where` argument doesn't exist, create a new benefits with this data.
     */
    create: XOR<benefitsCreateInput, benefitsUncheckedCreateInput>
    /**
     * In case the benefits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<benefitsUpdateInput, benefitsUncheckedUpdateInput>
  }

  /**
   * benefits delete
   */
  export type benefitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    /**
     * Filter which benefits to delete.
     */
    where: benefitsWhereUniqueInput
  }

  /**
   * benefits deleteMany
   */
  export type benefitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which benefits to delete
     */
    where?: benefitsWhereInput
  }

  /**
   * benefits findRaw
   */
  export type benefitsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * benefits aggregateRaw
   */
  export type benefitsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * benefits.level
   */
  export type benefits$levelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    where?: levelsWhereInput
  }

  /**
   * benefits.linkVisits
   */
  export type benefits$linkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    where?: link_visitsWhereInput
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    cursor?: link_visitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * benefits without action
   */
  export type benefitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
  }


  /**
   * Model brands
   */

  export type AggregateBrands = {
    _count: BrandsCountAggregateOutputType | null
    _avg: BrandsAvgAggregateOutputType | null
    _sum: BrandsSumAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  export type BrandsAvgAggregateOutputType = {
    budgetInterval: number | null
    ledgeRating: number | null
  }

  export type BrandsSumAggregateOutputType = {
    budgetInterval: number | null
    ledgeRating: number | null
  }

  export type BrandsMinAggregateOutputType = {
    id: string | null
    name: string | null
    pitchVideo: string | null
    updatedAt: Date | null
    email: string | null
    managerEmail: string | null
    managerName: string | null
    managerPhone: string | null
    website: string | null
    categoryId: string | null
    teaser: string | null
    mainPhrase: string | null
    targetGender: $Enums.GenderPreference | null
    budgetInterval: number | null
    shopifyDomain: string | null
    shopifyKeyName: string | null
    ledgeRating: number | null
    showTeamPictureInRating: boolean | null
  }

  export type BrandsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    pitchVideo: string | null
    updatedAt: Date | null
    email: string | null
    managerEmail: string | null
    managerName: string | null
    managerPhone: string | null
    website: string | null
    categoryId: string | null
    teaser: string | null
    mainPhrase: string | null
    targetGender: $Enums.GenderPreference | null
    budgetInterval: number | null
    shopifyDomain: string | null
    shopifyKeyName: string | null
    ledgeRating: number | null
    showTeamPictureInRating: boolean | null
  }

  export type BrandsCountAggregateOutputType = {
    id: number
    description: number
    shortDescription: number
    name: number
    pitchVideo: number
    pitchCaptions: number
    pitchSections: number
    updatedAt: number
    brandLogo: number
    email: number
    managerEmail: number
    managerName: number
    managerPhone: number
    labels: number
    teamPicture: number
    website: number
    categoryId: number
    teaser: number
    mainPhrase: number
    founders: number
    image: number
    usersForYouIds: number
    usersForYouPoolIds: number
    usersNotInterestedBrandsIds: number
    images: number
    usersFeedback: number
    selectedFeedback: number
    targetGender: number
    budgetInterval: number
    shopifyDomain: number
    shopifyKeyName: number
    ledgeRating: number
    showTeamPictureInRating: number
    _all: number
  }


  export type BrandsAvgAggregateInputType = {
    budgetInterval?: true
    ledgeRating?: true
  }

  export type BrandsSumAggregateInputType = {
    budgetInterval?: true
    ledgeRating?: true
  }

  export type BrandsMinAggregateInputType = {
    id?: true
    name?: true
    pitchVideo?: true
    updatedAt?: true
    email?: true
    managerEmail?: true
    managerName?: true
    managerPhone?: true
    website?: true
    categoryId?: true
    teaser?: true
    mainPhrase?: true
    targetGender?: true
    budgetInterval?: true
    shopifyDomain?: true
    shopifyKeyName?: true
    ledgeRating?: true
    showTeamPictureInRating?: true
  }

  export type BrandsMaxAggregateInputType = {
    id?: true
    name?: true
    pitchVideo?: true
    updatedAt?: true
    email?: true
    managerEmail?: true
    managerName?: true
    managerPhone?: true
    website?: true
    categoryId?: true
    teaser?: true
    mainPhrase?: true
    targetGender?: true
    budgetInterval?: true
    shopifyDomain?: true
    shopifyKeyName?: true
    ledgeRating?: true
    showTeamPictureInRating?: true
  }

  export type BrandsCountAggregateInputType = {
    id?: true
    description?: true
    shortDescription?: true
    name?: true
    pitchVideo?: true
    pitchCaptions?: true
    pitchSections?: true
    updatedAt?: true
    brandLogo?: true
    email?: true
    managerEmail?: true
    managerName?: true
    managerPhone?: true
    labels?: true
    teamPicture?: true
    website?: true
    categoryId?: true
    teaser?: true
    mainPhrase?: true
    founders?: true
    image?: true
    usersForYouIds?: true
    usersForYouPoolIds?: true
    usersNotInterestedBrandsIds?: true
    images?: true
    usersFeedback?: true
    selectedFeedback?: true
    targetGender?: true
    budgetInterval?: true
    shopifyDomain?: true
    shopifyKeyName?: true
    ledgeRating?: true
    showTeamPictureInRating?: true
    _all?: true
  }

  export type BrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to aggregate.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brands
    **/
    _count?: true | BrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandsMaxAggregateInputType
  }

  export type GetBrandsAggregateType<T extends BrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrands[P]>
      : GetScalarType<T[P], AggregateBrands[P]>
  }




  export type brandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithAggregationInput | brandsOrderByWithAggregationInput[]
    by: BrandsScalarFieldEnum[] | BrandsScalarFieldEnum
    having?: brandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandsCountAggregateInputType | true
    _avg?: BrandsAvgAggregateInputType
    _sum?: BrandsSumAggregateInputType
    _min?: BrandsMinAggregateInputType
    _max?: BrandsMaxAggregateInputType
  }

  export type BrandsGroupByOutputType = {
    id: string
    description: JsonValue
    shortDescription: JsonValue | null
    name: string
    pitchVideo: string | null
    pitchCaptions: JsonValue | null
    pitchSections: JsonValue | null
    updatedAt: Date
    brandLogo: JsonValue | null
    email: string | null
    managerEmail: string | null
    managerName: string | null
    managerPhone: string | null
    labels: JsonValue[]
    teamPicture: JsonValue | null
    website: string | null
    categoryId: string | null
    teaser: string | null
    mainPhrase: string | null
    founders: JsonValue[]
    image: JsonValue | null
    usersForYouIds: string[]
    usersForYouPoolIds: string[]
    usersNotInterestedBrandsIds: string[]
    images: JsonValue[]
    usersFeedback: JsonValue | null
    selectedFeedback: JsonValue
    targetGender: $Enums.GenderPreference | null
    budgetInterval: number | null
    shopifyDomain: string | null
    shopifyKeyName: string | null
    ledgeRating: number
    showTeamPictureInRating: boolean | null
    _count: BrandsCountAggregateOutputType | null
    _avg: BrandsAvgAggregateOutputType | null
    _sum: BrandsSumAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  type GetBrandsGroupByPayload<T extends brandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandsGroupByOutputType[P]>
            : GetScalarType<T[P], BrandsGroupByOutputType[P]>
        }
      >
    >


  export type brandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    shortDescription?: boolean
    name?: boolean
    pitchVideo?: boolean
    pitchCaptions?: boolean
    pitchSections?: boolean
    updatedAt?: boolean
    brandLogo?: boolean
    email?: boolean
    managerEmail?: boolean
    managerName?: boolean
    managerPhone?: boolean
    labels?: boolean
    teamPicture?: boolean
    website?: boolean
    categoryId?: boolean
    teaser?: boolean
    mainPhrase?: boolean
    founders?: boolean
    image?: boolean
    usersForYouIds?: boolean
    usersForYouPoolIds?: boolean
    usersNotInterestedBrandsIds?: boolean
    images?: boolean
    usersFeedback?: boolean
    selectedFeedback?: boolean
    targetGender?: boolean
    budgetInterval?: boolean
    shopifyDomain?: boolean
    shopifyKeyName?: boolean
    ledgeRating?: boolean
    showTeamPictureInRating?: boolean
    pitchQuestions?: boolean | brands$pitchQuestionsArgs<ExtArgs>
    pitchViews?: boolean | brands$pitchViewsArgs<ExtArgs>
    products?: boolean | brands$productsArgs<ExtArgs>
    category?: boolean | brands$categoryArgs<ExtArgs>
    ratings?: boolean | brands$ratingsArgs<ExtArgs>
    usersForYou?: boolean | brands$usersForYouArgs<ExtArgs>
    usersForYouPool?: boolean | brands$usersForYouPoolArgs<ExtArgs>
    usersNotInterestedBrands?: boolean | brands$usersNotInterestedBrandsArgs<ExtArgs>
    linkVisits?: boolean | brands$linkVisitsArgs<ExtArgs>
    brandScreenTimes?: boolean | brands$brandScreenTimesArgs<ExtArgs>
    productionSubmissions?: boolean | brands$productionSubmissionsArgs<ExtArgs>
    owner?: boolean | brands$ownerArgs<ExtArgs>
    posts?: boolean | brands$postsArgs<ExtArgs>
    dealCodeGroups?: boolean | brands$dealCodeGroupsArgs<ExtArgs>
    unlockHistory?: boolean | brands$unlockHistoryArgs<ExtArgs>
    pitchExitBrandAnswers?: boolean | brands$pitchExitBrandAnswersArgs<ExtArgs>
    productFeedbackAnswers?: boolean | brands$productFeedbackAnswersArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>


  export type brandsSelectScalar = {
    id?: boolean
    description?: boolean
    shortDescription?: boolean
    name?: boolean
    pitchVideo?: boolean
    pitchCaptions?: boolean
    pitchSections?: boolean
    updatedAt?: boolean
    brandLogo?: boolean
    email?: boolean
    managerEmail?: boolean
    managerName?: boolean
    managerPhone?: boolean
    labels?: boolean
    teamPicture?: boolean
    website?: boolean
    categoryId?: boolean
    teaser?: boolean
    mainPhrase?: boolean
    founders?: boolean
    image?: boolean
    usersForYouIds?: boolean
    usersForYouPoolIds?: boolean
    usersNotInterestedBrandsIds?: boolean
    images?: boolean
    usersFeedback?: boolean
    selectedFeedback?: boolean
    targetGender?: boolean
    budgetInterval?: boolean
    shopifyDomain?: boolean
    shopifyKeyName?: boolean
    ledgeRating?: boolean
    showTeamPictureInRating?: boolean
  }

  export type brandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pitchQuestions?: boolean | brands$pitchQuestionsArgs<ExtArgs>
    pitchViews?: boolean | brands$pitchViewsArgs<ExtArgs>
    products?: boolean | brands$productsArgs<ExtArgs>
    category?: boolean | brands$categoryArgs<ExtArgs>
    ratings?: boolean | brands$ratingsArgs<ExtArgs>
    usersForYou?: boolean | brands$usersForYouArgs<ExtArgs>
    usersForYouPool?: boolean | brands$usersForYouPoolArgs<ExtArgs>
    usersNotInterestedBrands?: boolean | brands$usersNotInterestedBrandsArgs<ExtArgs>
    linkVisits?: boolean | brands$linkVisitsArgs<ExtArgs>
    brandScreenTimes?: boolean | brands$brandScreenTimesArgs<ExtArgs>
    productionSubmissions?: boolean | brands$productionSubmissionsArgs<ExtArgs>
    owner?: boolean | brands$ownerArgs<ExtArgs>
    posts?: boolean | brands$postsArgs<ExtArgs>
    dealCodeGroups?: boolean | brands$dealCodeGroupsArgs<ExtArgs>
    unlockHistory?: boolean | brands$unlockHistoryArgs<ExtArgs>
    pitchExitBrandAnswers?: boolean | brands$pitchExitBrandAnswersArgs<ExtArgs>
    productFeedbackAnswers?: boolean | brands$productFeedbackAnswersArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $brandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brands"
    objects: {
      pitchQuestions: Prisma.$questionsPayload<ExtArgs>[]
      pitchViews: Prisma.$pitch_viewsPayload<ExtArgs>[]
      products: Prisma.$productsPayload<ExtArgs>[]
      category: Prisma.$categoriesPayload<ExtArgs> | null
      ratings: Prisma.$ratingsPayload<ExtArgs>[]
      usersForYou: Prisma.$usersPayload<ExtArgs>[]
      usersForYouPool: Prisma.$usersPayload<ExtArgs>[]
      usersNotInterestedBrands: Prisma.$usersPayload<ExtArgs>[]
      linkVisits: Prisma.$link_visitsPayload<ExtArgs>[]
      brandScreenTimes: Prisma.$brand_screen_timesPayload<ExtArgs>[]
      productionSubmissions: Prisma.$production_submissionsPayload<ExtArgs>[]
      owner: Prisma.$usersPayload<ExtArgs> | null
      posts: Prisma.$postsPayload<ExtArgs>[]
      dealCodeGroups: Prisma.$deal_code_groupsPayload<ExtArgs>[]
      unlockHistory: Prisma.$unlocked_brands_historyPayload<ExtArgs>[]
      pitchExitBrandAnswers: Prisma.$answersPayload<ExtArgs>[]
      productFeedbackAnswers: Prisma.$answersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: Prisma.JsonValue
      shortDescription: Prisma.JsonValue | null
      name: string
      pitchVideo: string | null
      pitchCaptions: Prisma.JsonValue | null
      pitchSections: Prisma.JsonValue | null
      updatedAt: Date
      brandLogo: Prisma.JsonValue | null
      email: string | null
      managerEmail: string | null
      managerName: string | null
      managerPhone: string | null
      labels: Prisma.JsonValue[]
      teamPicture: Prisma.JsonValue | null
      website: string | null
      categoryId: string | null
      teaser: string | null
      mainPhrase: string | null
      founders: Prisma.JsonValue[]
      image: Prisma.JsonValue | null
      usersForYouIds: string[]
      usersForYouPoolIds: string[]
      usersNotInterestedBrandsIds: string[]
      images: Prisma.JsonValue[]
      usersFeedback: Prisma.JsonValue | null
      selectedFeedback: Prisma.JsonValue
      targetGender: $Enums.GenderPreference | null
      budgetInterval: number | null
      shopifyDomain: string | null
      shopifyKeyName: string | null
      ledgeRating: number
      showTeamPictureInRating: boolean | null
    }, ExtArgs["result"]["brands"]>
    composites: {}
  }

  type brandsGetPayload<S extends boolean | null | undefined | brandsDefaultArgs> = $Result.GetResult<Prisma.$brandsPayload, S>

  type brandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<brandsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandsCountAggregateInputType | true
    }

  export interface brandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brands'], meta: { name: 'brands' } }
    /**
     * Find zero or one Brands that matches the filter.
     * @param {brandsFindUniqueArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends brandsFindUniqueArgs>(args: SelectSubset<T, brandsFindUniqueArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Brands that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {brandsFindUniqueOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends brandsFindUniqueOrThrowArgs>(args: SelectSubset<T, brandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends brandsFindFirstArgs>(args?: SelectSubset<T, brandsFindFirstArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends brandsFindFirstOrThrowArgs>(args?: SelectSubset<T, brandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brands.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandsWithIdOnly = await prisma.brands.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends brandsFindManyArgs>(args?: SelectSubset<T, brandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Brands.
     * @param {brandsCreateArgs} args - Arguments to create a Brands.
     * @example
     * // Create one Brands
     * const Brands = await prisma.brands.create({
     *   data: {
     *     // ... data to create a Brands
     *   }
     * })
     * 
     */
    create<T extends brandsCreateArgs>(args: SelectSubset<T, brandsCreateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Brands.
     * @param {brandsCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends brandsCreateManyArgs>(args?: SelectSubset<T, brandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brands.
     * @param {brandsDeleteArgs} args - Arguments to delete one Brands.
     * @example
     * // Delete one Brands
     * const Brands = await prisma.brands.delete({
     *   where: {
     *     // ... filter to delete one Brands
     *   }
     * })
     * 
     */
    delete<T extends brandsDeleteArgs>(args: SelectSubset<T, brandsDeleteArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Brands.
     * @param {brandsUpdateArgs} args - Arguments to update one Brands.
     * @example
     * // Update one Brands
     * const brands = await prisma.brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends brandsUpdateArgs>(args: SelectSubset<T, brandsUpdateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {brandsDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends brandsDeleteManyArgs>(args?: SelectSubset<T, brandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends brandsUpdateManyArgs>(args: SelectSubset<T, brandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brands.
     * @param {brandsUpsertArgs} args - Arguments to update or create a Brands.
     * @example
     * // Update or create a Brands
     * const brands = await prisma.brands.upsert({
     *   create: {
     *     // ... data to create a Brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brands we want to update
     *   }
     * })
     */
    upsert<T extends brandsUpsertArgs>(args: SelectSubset<T, brandsUpsertArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * @param {brandsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const brands = await prisma.brands.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: brandsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Brands.
     * @param {brandsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const brands = await prisma.brands.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: brandsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brands.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends brandsCountArgs>(
      args?: Subset<T, brandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandsAggregateArgs>(args: Subset<T, BrandsAggregateArgs>): Prisma.PrismaPromise<GetBrandsAggregateType<T>>

    /**
     * Group by Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brandsGroupByArgs['orderBy'] }
        : { orderBy?: brandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brands model
   */
  readonly fields: brandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pitchQuestions<T extends brands$pitchQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, brands$pitchQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    pitchViews<T extends brands$pitchViewsArgs<ExtArgs> = {}>(args?: Subset<T, brands$pitchViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends brands$productsArgs<ExtArgs> = {}>(args?: Subset<T, brands$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany"> | Null>
    category<T extends brands$categoryArgs<ExtArgs> = {}>(args?: Subset<T, brands$categoryArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ratings<T extends brands$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, brands$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findMany"> | Null>
    usersForYou<T extends brands$usersForYouArgs<ExtArgs> = {}>(args?: Subset<T, brands$usersForYouArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    usersForYouPool<T extends brands$usersForYouPoolArgs<ExtArgs> = {}>(args?: Subset<T, brands$usersForYouPoolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    usersNotInterestedBrands<T extends brands$usersNotInterestedBrandsArgs<ExtArgs> = {}>(args?: Subset<T, brands$usersNotInterestedBrandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    linkVisits<T extends brands$linkVisitsArgs<ExtArgs> = {}>(args?: Subset<T, brands$linkVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findMany"> | Null>
    brandScreenTimes<T extends brands$brandScreenTimesArgs<ExtArgs> = {}>(args?: Subset<T, brands$brandScreenTimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "findMany"> | Null>
    productionSubmissions<T extends brands$productionSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, brands$productionSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findMany"> | Null>
    owner<T extends brands$ownerArgs<ExtArgs> = {}>(args?: Subset<T, brands$ownerArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    posts<T extends brands$postsArgs<ExtArgs> = {}>(args?: Subset<T, brands$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findMany"> | Null>
    dealCodeGroups<T extends brands$dealCodeGroupsArgs<ExtArgs> = {}>(args?: Subset<T, brands$dealCodeGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "findMany"> | Null>
    unlockHistory<T extends brands$unlockHistoryArgs<ExtArgs> = {}>(args?: Subset<T, brands$unlockHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "findMany"> | Null>
    pitchExitBrandAnswers<T extends brands$pitchExitBrandAnswersArgs<ExtArgs> = {}>(args?: Subset<T, brands$pitchExitBrandAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany"> | Null>
    productFeedbackAnswers<T extends brands$productFeedbackAnswersArgs<ExtArgs> = {}>(args?: Subset<T, brands$productFeedbackAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the brands model
   */ 
  interface brandsFieldRefs {
    readonly id: FieldRef<"brands", 'String'>
    readonly description: FieldRef<"brands", 'Json'>
    readonly shortDescription: FieldRef<"brands", 'Json'>
    readonly name: FieldRef<"brands", 'String'>
    readonly pitchVideo: FieldRef<"brands", 'String'>
    readonly pitchCaptions: FieldRef<"brands", 'Json'>
    readonly pitchSections: FieldRef<"brands", 'Json'>
    readonly updatedAt: FieldRef<"brands", 'DateTime'>
    readonly brandLogo: FieldRef<"brands", 'Json'>
    readonly email: FieldRef<"brands", 'String'>
    readonly managerEmail: FieldRef<"brands", 'String'>
    readonly managerName: FieldRef<"brands", 'String'>
    readonly managerPhone: FieldRef<"brands", 'String'>
    readonly labels: FieldRef<"brands", 'Json[]'>
    readonly teamPicture: FieldRef<"brands", 'Json'>
    readonly website: FieldRef<"brands", 'String'>
    readonly categoryId: FieldRef<"brands", 'String'>
    readonly teaser: FieldRef<"brands", 'String'>
    readonly mainPhrase: FieldRef<"brands", 'String'>
    readonly founders: FieldRef<"brands", 'Json[]'>
    readonly image: FieldRef<"brands", 'Json'>
    readonly usersForYouIds: FieldRef<"brands", 'String[]'>
    readonly usersForYouPoolIds: FieldRef<"brands", 'String[]'>
    readonly usersNotInterestedBrandsIds: FieldRef<"brands", 'String[]'>
    readonly images: FieldRef<"brands", 'Json[]'>
    readonly usersFeedback: FieldRef<"brands", 'Json'>
    readonly selectedFeedback: FieldRef<"brands", 'Json'>
    readonly targetGender: FieldRef<"brands", 'GenderPreference'>
    readonly budgetInterval: FieldRef<"brands", 'Int'>
    readonly shopifyDomain: FieldRef<"brands", 'String'>
    readonly shopifyKeyName: FieldRef<"brands", 'String'>
    readonly ledgeRating: FieldRef<"brands", 'Int'>
    readonly showTeamPictureInRating: FieldRef<"brands", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * brands findUnique
   */
  export type brandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findUniqueOrThrow
   */
  export type brandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findFirst
   */
  export type brandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findFirstOrThrow
   */
  export type brandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findMany
   */
  export type brandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands create
   */
  export type brandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to create a brands.
     */
    data: XOR<brandsCreateInput, brandsUncheckedCreateInput>
  }

  /**
   * brands createMany
   */
  export type brandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brands.
     */
    data: brandsCreateManyInput | brandsCreateManyInput[]
  }

  /**
   * brands update
   */
  export type brandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to update a brands.
     */
    data: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
    /**
     * Choose, which brands to update.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands updateMany
   */
  export type brandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brands.
     */
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandsWhereInput
  }

  /**
   * brands upsert
   */
  export type brandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The filter to search for the brands to update in case it exists.
     */
    where: brandsWhereUniqueInput
    /**
     * In case the brands found by the `where` argument doesn't exist, create a new brands with this data.
     */
    create: XOR<brandsCreateInput, brandsUncheckedCreateInput>
    /**
     * In case the brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
  }

  /**
   * brands delete
   */
  export type brandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter which brands to delete.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands deleteMany
   */
  export type brandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to delete
     */
    where?: brandsWhereInput
  }

  /**
   * brands findRaw
   */
  export type brandsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * brands aggregateRaw
   */
  export type brandsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * brands.pitchQuestions
   */
  export type brands$pitchQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * brands.pitchViews
   */
  export type brands$pitchViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    where?: pitch_viewsWhereInput
    orderBy?: pitch_viewsOrderByWithRelationInput | pitch_viewsOrderByWithRelationInput[]
    cursor?: pitch_viewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pitch_viewsScalarFieldEnum | Pitch_viewsScalarFieldEnum[]
  }

  /**
   * brands.products
   */
  export type brands$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * brands.category
   */
  export type brands$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * brands.ratings
   */
  export type brands$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    where?: ratingsWhereInput
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    cursor?: ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * brands.usersForYou
   */
  export type brands$usersForYouArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * brands.usersForYouPool
   */
  export type brands$usersForYouPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * brands.usersNotInterestedBrands
   */
  export type brands$usersNotInterestedBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * brands.linkVisits
   */
  export type brands$linkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    where?: link_visitsWhereInput
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    cursor?: link_visitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * brands.brandScreenTimes
   */
  export type brands$brandScreenTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    where?: brand_screen_timesWhereInput
    orderBy?: brand_screen_timesOrderByWithRelationInput | brand_screen_timesOrderByWithRelationInput[]
    cursor?: brand_screen_timesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Brand_screen_timesScalarFieldEnum | Brand_screen_timesScalarFieldEnum[]
  }

  /**
   * brands.productionSubmissions
   */
  export type brands$productionSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    where?: production_submissionsWhereInput
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    cursor?: production_submissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * brands.owner
   */
  export type brands$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * brands.posts
   */
  export type brands$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    where?: postsWhereInput
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    cursor?: postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * brands.dealCodeGroups
   */
  export type brands$dealCodeGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    where?: deal_code_groupsWhereInput
    orderBy?: deal_code_groupsOrderByWithRelationInput | deal_code_groupsOrderByWithRelationInput[]
    cursor?: deal_code_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Deal_code_groupsScalarFieldEnum | Deal_code_groupsScalarFieldEnum[]
  }

  /**
   * brands.unlockHistory
   */
  export type brands$unlockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    where?: unlocked_brands_historyWhereInput
    orderBy?: unlocked_brands_historyOrderByWithRelationInput | unlocked_brands_historyOrderByWithRelationInput[]
    cursor?: unlocked_brands_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlocked_brands_historyScalarFieldEnum | Unlocked_brands_historyScalarFieldEnum[]
  }

  /**
   * brands.pitchExitBrandAnswers
   */
  export type brands$pitchExitBrandAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    where?: answersWhereInput
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    cursor?: answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * brands.productFeedbackAnswers
   */
  export type brands$productFeedbackAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    where?: answersWhereInput
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    cursor?: answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * brands without action
   */
  export type brandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
  }


  /**
   * Model unlocked_brands_history
   */

  export type AggregateUnlocked_brands_history = {
    _count: Unlocked_brands_historyCountAggregateOutputType | null
    _min: Unlocked_brands_historyMinAggregateOutputType | null
    _max: Unlocked_brands_historyMaxAggregateOutputType | null
  }

  export type Unlocked_brands_historyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    brandId: string | null
    createdAt: Date | null
  }

  export type Unlocked_brands_historyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    brandId: string | null
    createdAt: Date | null
  }

  export type Unlocked_brands_historyCountAggregateOutputType = {
    id: number
    userId: number
    brandId: number
    createdAt: number
    _all: number
  }


  export type Unlocked_brands_historyMinAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
  }

  export type Unlocked_brands_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
  }

  export type Unlocked_brands_historyCountAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
    _all?: true
  }

  export type Unlocked_brands_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unlocked_brands_history to aggregate.
     */
    where?: unlocked_brands_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unlocked_brands_histories to fetch.
     */
    orderBy?: unlocked_brands_historyOrderByWithRelationInput | unlocked_brands_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: unlocked_brands_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unlocked_brands_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unlocked_brands_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned unlocked_brands_histories
    **/
    _count?: true | Unlocked_brands_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Unlocked_brands_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Unlocked_brands_historyMaxAggregateInputType
  }

  export type GetUnlocked_brands_historyAggregateType<T extends Unlocked_brands_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateUnlocked_brands_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnlocked_brands_history[P]>
      : GetScalarType<T[P], AggregateUnlocked_brands_history[P]>
  }




  export type unlocked_brands_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: unlocked_brands_historyWhereInput
    orderBy?: unlocked_brands_historyOrderByWithAggregationInput | unlocked_brands_historyOrderByWithAggregationInput[]
    by: Unlocked_brands_historyScalarFieldEnum[] | Unlocked_brands_historyScalarFieldEnum
    having?: unlocked_brands_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Unlocked_brands_historyCountAggregateInputType | true
    _min?: Unlocked_brands_historyMinAggregateInputType
    _max?: Unlocked_brands_historyMaxAggregateInputType
  }

  export type Unlocked_brands_historyGroupByOutputType = {
    id: string
    userId: string
    brandId: string | null
    createdAt: Date
    _count: Unlocked_brands_historyCountAggregateOutputType | null
    _min: Unlocked_brands_historyMinAggregateOutputType | null
    _max: Unlocked_brands_historyMaxAggregateOutputType | null
  }

  type GetUnlocked_brands_historyGroupByPayload<T extends unlocked_brands_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Unlocked_brands_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Unlocked_brands_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Unlocked_brands_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Unlocked_brands_historyGroupByOutputType[P]>
        }
      >
    >


  export type unlocked_brands_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    brand?: boolean | unlocked_brands_history$brandArgs<ExtArgs>
  }, ExtArgs["result"]["unlocked_brands_history"]>


  export type unlocked_brands_historySelectScalar = {
    id?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
  }

  export type unlocked_brands_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    brand?: boolean | unlocked_brands_history$brandArgs<ExtArgs>
  }

  export type $unlocked_brands_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "unlocked_brands_history"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      brand: Prisma.$brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      brandId: string | null
      createdAt: Date
    }, ExtArgs["result"]["unlocked_brands_history"]>
    composites: {}
  }

  type unlocked_brands_historyGetPayload<S extends boolean | null | undefined | unlocked_brands_historyDefaultArgs> = $Result.GetResult<Prisma.$unlocked_brands_historyPayload, S>

  type unlocked_brands_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<unlocked_brands_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Unlocked_brands_historyCountAggregateInputType | true
    }

  export interface unlocked_brands_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['unlocked_brands_history'], meta: { name: 'unlocked_brands_history' } }
    /**
     * Find zero or one Unlocked_brands_history that matches the filter.
     * @param {unlocked_brands_historyFindUniqueArgs} args - Arguments to find a Unlocked_brands_history
     * @example
     * // Get one Unlocked_brands_history
     * const unlocked_brands_history = await prisma.unlocked_brands_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends unlocked_brands_historyFindUniqueArgs>(args: SelectSubset<T, unlocked_brands_historyFindUniqueArgs<ExtArgs>>): Prisma__unlocked_brands_historyClient<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unlocked_brands_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {unlocked_brands_historyFindUniqueOrThrowArgs} args - Arguments to find a Unlocked_brands_history
     * @example
     * // Get one Unlocked_brands_history
     * const unlocked_brands_history = await prisma.unlocked_brands_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends unlocked_brands_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, unlocked_brands_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__unlocked_brands_historyClient<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unlocked_brands_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unlocked_brands_historyFindFirstArgs} args - Arguments to find a Unlocked_brands_history
     * @example
     * // Get one Unlocked_brands_history
     * const unlocked_brands_history = await prisma.unlocked_brands_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends unlocked_brands_historyFindFirstArgs>(args?: SelectSubset<T, unlocked_brands_historyFindFirstArgs<ExtArgs>>): Prisma__unlocked_brands_historyClient<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unlocked_brands_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unlocked_brands_historyFindFirstOrThrowArgs} args - Arguments to find a Unlocked_brands_history
     * @example
     * // Get one Unlocked_brands_history
     * const unlocked_brands_history = await prisma.unlocked_brands_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends unlocked_brands_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, unlocked_brands_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__unlocked_brands_historyClient<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Unlocked_brands_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unlocked_brands_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unlocked_brands_histories
     * const unlocked_brands_histories = await prisma.unlocked_brands_history.findMany()
     * 
     * // Get first 10 Unlocked_brands_histories
     * const unlocked_brands_histories = await prisma.unlocked_brands_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unlocked_brands_historyWithIdOnly = await prisma.unlocked_brands_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends unlocked_brands_historyFindManyArgs>(args?: SelectSubset<T, unlocked_brands_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unlocked_brands_history.
     * @param {unlocked_brands_historyCreateArgs} args - Arguments to create a Unlocked_brands_history.
     * @example
     * // Create one Unlocked_brands_history
     * const Unlocked_brands_history = await prisma.unlocked_brands_history.create({
     *   data: {
     *     // ... data to create a Unlocked_brands_history
     *   }
     * })
     * 
     */
    create<T extends unlocked_brands_historyCreateArgs>(args: SelectSubset<T, unlocked_brands_historyCreateArgs<ExtArgs>>): Prisma__unlocked_brands_historyClient<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Unlocked_brands_histories.
     * @param {unlocked_brands_historyCreateManyArgs} args - Arguments to create many Unlocked_brands_histories.
     * @example
     * // Create many Unlocked_brands_histories
     * const unlocked_brands_history = await prisma.unlocked_brands_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends unlocked_brands_historyCreateManyArgs>(args?: SelectSubset<T, unlocked_brands_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unlocked_brands_history.
     * @param {unlocked_brands_historyDeleteArgs} args - Arguments to delete one Unlocked_brands_history.
     * @example
     * // Delete one Unlocked_brands_history
     * const Unlocked_brands_history = await prisma.unlocked_brands_history.delete({
     *   where: {
     *     // ... filter to delete one Unlocked_brands_history
     *   }
     * })
     * 
     */
    delete<T extends unlocked_brands_historyDeleteArgs>(args: SelectSubset<T, unlocked_brands_historyDeleteArgs<ExtArgs>>): Prisma__unlocked_brands_historyClient<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unlocked_brands_history.
     * @param {unlocked_brands_historyUpdateArgs} args - Arguments to update one Unlocked_brands_history.
     * @example
     * // Update one Unlocked_brands_history
     * const unlocked_brands_history = await prisma.unlocked_brands_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends unlocked_brands_historyUpdateArgs>(args: SelectSubset<T, unlocked_brands_historyUpdateArgs<ExtArgs>>): Prisma__unlocked_brands_historyClient<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Unlocked_brands_histories.
     * @param {unlocked_brands_historyDeleteManyArgs} args - Arguments to filter Unlocked_brands_histories to delete.
     * @example
     * // Delete a few Unlocked_brands_histories
     * const { count } = await prisma.unlocked_brands_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends unlocked_brands_historyDeleteManyArgs>(args?: SelectSubset<T, unlocked_brands_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unlocked_brands_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unlocked_brands_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unlocked_brands_histories
     * const unlocked_brands_history = await prisma.unlocked_brands_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends unlocked_brands_historyUpdateManyArgs>(args: SelectSubset<T, unlocked_brands_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unlocked_brands_history.
     * @param {unlocked_brands_historyUpsertArgs} args - Arguments to update or create a Unlocked_brands_history.
     * @example
     * // Update or create a Unlocked_brands_history
     * const unlocked_brands_history = await prisma.unlocked_brands_history.upsert({
     *   create: {
     *     // ... data to create a Unlocked_brands_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unlocked_brands_history we want to update
     *   }
     * })
     */
    upsert<T extends unlocked_brands_historyUpsertArgs>(args: SelectSubset<T, unlocked_brands_historyUpsertArgs<ExtArgs>>): Prisma__unlocked_brands_historyClient<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Unlocked_brands_histories that matches the filter.
     * @param {unlocked_brands_historyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const unlocked_brands_history = await prisma.unlocked_brands_history.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: unlocked_brands_historyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Unlocked_brands_history.
     * @param {unlocked_brands_historyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const unlocked_brands_history = await prisma.unlocked_brands_history.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: unlocked_brands_historyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Unlocked_brands_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unlocked_brands_historyCountArgs} args - Arguments to filter Unlocked_brands_histories to count.
     * @example
     * // Count the number of Unlocked_brands_histories
     * const count = await prisma.unlocked_brands_history.count({
     *   where: {
     *     // ... the filter for the Unlocked_brands_histories we want to count
     *   }
     * })
    **/
    count<T extends unlocked_brands_historyCountArgs>(
      args?: Subset<T, unlocked_brands_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Unlocked_brands_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unlocked_brands_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unlocked_brands_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Unlocked_brands_historyAggregateArgs>(args: Subset<T, Unlocked_brands_historyAggregateArgs>): Prisma.PrismaPromise<GetUnlocked_brands_historyAggregateType<T>>

    /**
     * Group by Unlocked_brands_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unlocked_brands_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends unlocked_brands_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: unlocked_brands_historyGroupByArgs['orderBy'] }
        : { orderBy?: unlocked_brands_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, unlocked_brands_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnlocked_brands_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the unlocked_brands_history model
   */
  readonly fields: unlocked_brands_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for unlocked_brands_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__unlocked_brands_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    brand<T extends unlocked_brands_history$brandArgs<ExtArgs> = {}>(args?: Subset<T, unlocked_brands_history$brandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the unlocked_brands_history model
   */ 
  interface unlocked_brands_historyFieldRefs {
    readonly id: FieldRef<"unlocked_brands_history", 'String'>
    readonly userId: FieldRef<"unlocked_brands_history", 'String'>
    readonly brandId: FieldRef<"unlocked_brands_history", 'String'>
    readonly createdAt: FieldRef<"unlocked_brands_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * unlocked_brands_history findUnique
   */
  export type unlocked_brands_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * Filter, which unlocked_brands_history to fetch.
     */
    where: unlocked_brands_historyWhereUniqueInput
  }

  /**
   * unlocked_brands_history findUniqueOrThrow
   */
  export type unlocked_brands_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * Filter, which unlocked_brands_history to fetch.
     */
    where: unlocked_brands_historyWhereUniqueInput
  }

  /**
   * unlocked_brands_history findFirst
   */
  export type unlocked_brands_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * Filter, which unlocked_brands_history to fetch.
     */
    where?: unlocked_brands_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unlocked_brands_histories to fetch.
     */
    orderBy?: unlocked_brands_historyOrderByWithRelationInput | unlocked_brands_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unlocked_brands_histories.
     */
    cursor?: unlocked_brands_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unlocked_brands_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unlocked_brands_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unlocked_brands_histories.
     */
    distinct?: Unlocked_brands_historyScalarFieldEnum | Unlocked_brands_historyScalarFieldEnum[]
  }

  /**
   * unlocked_brands_history findFirstOrThrow
   */
  export type unlocked_brands_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * Filter, which unlocked_brands_history to fetch.
     */
    where?: unlocked_brands_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unlocked_brands_histories to fetch.
     */
    orderBy?: unlocked_brands_historyOrderByWithRelationInput | unlocked_brands_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unlocked_brands_histories.
     */
    cursor?: unlocked_brands_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unlocked_brands_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unlocked_brands_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unlocked_brands_histories.
     */
    distinct?: Unlocked_brands_historyScalarFieldEnum | Unlocked_brands_historyScalarFieldEnum[]
  }

  /**
   * unlocked_brands_history findMany
   */
  export type unlocked_brands_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * Filter, which unlocked_brands_histories to fetch.
     */
    where?: unlocked_brands_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unlocked_brands_histories to fetch.
     */
    orderBy?: unlocked_brands_historyOrderByWithRelationInput | unlocked_brands_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing unlocked_brands_histories.
     */
    cursor?: unlocked_brands_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unlocked_brands_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unlocked_brands_histories.
     */
    skip?: number
    distinct?: Unlocked_brands_historyScalarFieldEnum | Unlocked_brands_historyScalarFieldEnum[]
  }

  /**
   * unlocked_brands_history create
   */
  export type unlocked_brands_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a unlocked_brands_history.
     */
    data: XOR<unlocked_brands_historyCreateInput, unlocked_brands_historyUncheckedCreateInput>
  }

  /**
   * unlocked_brands_history createMany
   */
  export type unlocked_brands_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many unlocked_brands_histories.
     */
    data: unlocked_brands_historyCreateManyInput | unlocked_brands_historyCreateManyInput[]
  }

  /**
   * unlocked_brands_history update
   */
  export type unlocked_brands_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a unlocked_brands_history.
     */
    data: XOR<unlocked_brands_historyUpdateInput, unlocked_brands_historyUncheckedUpdateInput>
    /**
     * Choose, which unlocked_brands_history to update.
     */
    where: unlocked_brands_historyWhereUniqueInput
  }

  /**
   * unlocked_brands_history updateMany
   */
  export type unlocked_brands_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update unlocked_brands_histories.
     */
    data: XOR<unlocked_brands_historyUpdateManyMutationInput, unlocked_brands_historyUncheckedUpdateManyInput>
    /**
     * Filter which unlocked_brands_histories to update
     */
    where?: unlocked_brands_historyWhereInput
  }

  /**
   * unlocked_brands_history upsert
   */
  export type unlocked_brands_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the unlocked_brands_history to update in case it exists.
     */
    where: unlocked_brands_historyWhereUniqueInput
    /**
     * In case the unlocked_brands_history found by the `where` argument doesn't exist, create a new unlocked_brands_history with this data.
     */
    create: XOR<unlocked_brands_historyCreateInput, unlocked_brands_historyUncheckedCreateInput>
    /**
     * In case the unlocked_brands_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<unlocked_brands_historyUpdateInput, unlocked_brands_historyUncheckedUpdateInput>
  }

  /**
   * unlocked_brands_history delete
   */
  export type unlocked_brands_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    /**
     * Filter which unlocked_brands_history to delete.
     */
    where: unlocked_brands_historyWhereUniqueInput
  }

  /**
   * unlocked_brands_history deleteMany
   */
  export type unlocked_brands_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which unlocked_brands_histories to delete
     */
    where?: unlocked_brands_historyWhereInput
  }

  /**
   * unlocked_brands_history findRaw
   */
  export type unlocked_brands_historyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * unlocked_brands_history aggregateRaw
   */
  export type unlocked_brands_historyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * unlocked_brands_history.brand
   */
  export type unlocked_brands_history$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * unlocked_brands_history without action
   */
  export type unlocked_brands_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
  }


  /**
   * Model brand_screen_times
   */

  export type AggregateBrand_screen_times = {
    _count: Brand_screen_timesCountAggregateOutputType | null
    _avg: Brand_screen_timesAvgAggregateOutputType | null
    _sum: Brand_screen_timesSumAggregateOutputType | null
    _min: Brand_screen_timesMinAggregateOutputType | null
    _max: Brand_screen_timesMaxAggregateOutputType | null
  }

  export type Brand_screen_timesAvgAggregateOutputType = {
    time: number | null
  }

  export type Brand_screen_timesSumAggregateOutputType = {
    time: number | null
  }

  export type Brand_screen_timesMinAggregateOutputType = {
    id: string | null
    time: number | null
    userId: string | null
    brandId: string | null
    createdAt: Date | null
  }

  export type Brand_screen_timesMaxAggregateOutputType = {
    id: string | null
    time: number | null
    userId: string | null
    brandId: string | null
    createdAt: Date | null
  }

  export type Brand_screen_timesCountAggregateOutputType = {
    id: number
    time: number
    userId: number
    brandId: number
    createdAt: number
    _all: number
  }


  export type Brand_screen_timesAvgAggregateInputType = {
    time?: true
  }

  export type Brand_screen_timesSumAggregateInputType = {
    time?: true
  }

  export type Brand_screen_timesMinAggregateInputType = {
    id?: true
    time?: true
    userId?: true
    brandId?: true
    createdAt?: true
  }

  export type Brand_screen_timesMaxAggregateInputType = {
    id?: true
    time?: true
    userId?: true
    brandId?: true
    createdAt?: true
  }

  export type Brand_screen_timesCountAggregateInputType = {
    id?: true
    time?: true
    userId?: true
    brandId?: true
    createdAt?: true
    _all?: true
  }

  export type Brand_screen_timesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brand_screen_times to aggregate.
     */
    where?: brand_screen_timesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brand_screen_times to fetch.
     */
    orderBy?: brand_screen_timesOrderByWithRelationInput | brand_screen_timesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brand_screen_timesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brand_screen_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brand_screen_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brand_screen_times
    **/
    _count?: true | Brand_screen_timesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Brand_screen_timesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Brand_screen_timesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Brand_screen_timesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Brand_screen_timesMaxAggregateInputType
  }

  export type GetBrand_screen_timesAggregateType<T extends Brand_screen_timesAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand_screen_times]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand_screen_times[P]>
      : GetScalarType<T[P], AggregateBrand_screen_times[P]>
  }




  export type brand_screen_timesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brand_screen_timesWhereInput
    orderBy?: brand_screen_timesOrderByWithAggregationInput | brand_screen_timesOrderByWithAggregationInput[]
    by: Brand_screen_timesScalarFieldEnum[] | Brand_screen_timesScalarFieldEnum
    having?: brand_screen_timesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Brand_screen_timesCountAggregateInputType | true
    _avg?: Brand_screen_timesAvgAggregateInputType
    _sum?: Brand_screen_timesSumAggregateInputType
    _min?: Brand_screen_timesMinAggregateInputType
    _max?: Brand_screen_timesMaxAggregateInputType
  }

  export type Brand_screen_timesGroupByOutputType = {
    id: string
    time: number
    userId: string
    brandId: string | null
    createdAt: Date
    _count: Brand_screen_timesCountAggregateOutputType | null
    _avg: Brand_screen_timesAvgAggregateOutputType | null
    _sum: Brand_screen_timesSumAggregateOutputType | null
    _min: Brand_screen_timesMinAggregateOutputType | null
    _max: Brand_screen_timesMaxAggregateOutputType | null
  }

  type GetBrand_screen_timesGroupByPayload<T extends brand_screen_timesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Brand_screen_timesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Brand_screen_timesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Brand_screen_timesGroupByOutputType[P]>
            : GetScalarType<T[P], Brand_screen_timesGroupByOutputType[P]>
        }
      >
    >


  export type brand_screen_timesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    time?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    brand?: boolean | brand_screen_times$brandArgs<ExtArgs>
  }, ExtArgs["result"]["brand_screen_times"]>


  export type brand_screen_timesSelectScalar = {
    id?: boolean
    time?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
  }

  export type brand_screen_timesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    brand?: boolean | brand_screen_times$brandArgs<ExtArgs>
  }

  export type $brand_screen_timesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brand_screen_times"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      brand: Prisma.$brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      time: number
      userId: string
      brandId: string | null
      createdAt: Date
    }, ExtArgs["result"]["brand_screen_times"]>
    composites: {}
  }

  type brand_screen_timesGetPayload<S extends boolean | null | undefined | brand_screen_timesDefaultArgs> = $Result.GetResult<Prisma.$brand_screen_timesPayload, S>

  type brand_screen_timesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<brand_screen_timesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Brand_screen_timesCountAggregateInputType | true
    }

  export interface brand_screen_timesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brand_screen_times'], meta: { name: 'brand_screen_times' } }
    /**
     * Find zero or one Brand_screen_times that matches the filter.
     * @param {brand_screen_timesFindUniqueArgs} args - Arguments to find a Brand_screen_times
     * @example
     * // Get one Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends brand_screen_timesFindUniqueArgs>(args: SelectSubset<T, brand_screen_timesFindUniqueArgs<ExtArgs>>): Prisma__brand_screen_timesClient<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Brand_screen_times that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {brand_screen_timesFindUniqueOrThrowArgs} args - Arguments to find a Brand_screen_times
     * @example
     * // Get one Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends brand_screen_timesFindUniqueOrThrowArgs>(args: SelectSubset<T, brand_screen_timesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__brand_screen_timesClient<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Brand_screen_times that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brand_screen_timesFindFirstArgs} args - Arguments to find a Brand_screen_times
     * @example
     * // Get one Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends brand_screen_timesFindFirstArgs>(args?: SelectSubset<T, brand_screen_timesFindFirstArgs<ExtArgs>>): Prisma__brand_screen_timesClient<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Brand_screen_times that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brand_screen_timesFindFirstOrThrowArgs} args - Arguments to find a Brand_screen_times
     * @example
     * // Get one Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends brand_screen_timesFindFirstOrThrowArgs>(args?: SelectSubset<T, brand_screen_timesFindFirstOrThrowArgs<ExtArgs>>): Prisma__brand_screen_timesClient<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Brand_screen_times that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brand_screen_timesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.findMany()
     * 
     * // Get first 10 Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brand_screen_timesWithIdOnly = await prisma.brand_screen_times.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends brand_screen_timesFindManyArgs>(args?: SelectSubset<T, brand_screen_timesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Brand_screen_times.
     * @param {brand_screen_timesCreateArgs} args - Arguments to create a Brand_screen_times.
     * @example
     * // Create one Brand_screen_times
     * const Brand_screen_times = await prisma.brand_screen_times.create({
     *   data: {
     *     // ... data to create a Brand_screen_times
     *   }
     * })
     * 
     */
    create<T extends brand_screen_timesCreateArgs>(args: SelectSubset<T, brand_screen_timesCreateArgs<ExtArgs>>): Prisma__brand_screen_timesClient<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Brand_screen_times.
     * @param {brand_screen_timesCreateManyArgs} args - Arguments to create many Brand_screen_times.
     * @example
     * // Create many Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends brand_screen_timesCreateManyArgs>(args?: SelectSubset<T, brand_screen_timesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brand_screen_times.
     * @param {brand_screen_timesDeleteArgs} args - Arguments to delete one Brand_screen_times.
     * @example
     * // Delete one Brand_screen_times
     * const Brand_screen_times = await prisma.brand_screen_times.delete({
     *   where: {
     *     // ... filter to delete one Brand_screen_times
     *   }
     * })
     * 
     */
    delete<T extends brand_screen_timesDeleteArgs>(args: SelectSubset<T, brand_screen_timesDeleteArgs<ExtArgs>>): Prisma__brand_screen_timesClient<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Brand_screen_times.
     * @param {brand_screen_timesUpdateArgs} args - Arguments to update one Brand_screen_times.
     * @example
     * // Update one Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends brand_screen_timesUpdateArgs>(args: SelectSubset<T, brand_screen_timesUpdateArgs<ExtArgs>>): Prisma__brand_screen_timesClient<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Brand_screen_times.
     * @param {brand_screen_timesDeleteManyArgs} args - Arguments to filter Brand_screen_times to delete.
     * @example
     * // Delete a few Brand_screen_times
     * const { count } = await prisma.brand_screen_times.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends brand_screen_timesDeleteManyArgs>(args?: SelectSubset<T, brand_screen_timesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brand_screen_times.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brand_screen_timesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends brand_screen_timesUpdateManyArgs>(args: SelectSubset<T, brand_screen_timesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brand_screen_times.
     * @param {brand_screen_timesUpsertArgs} args - Arguments to update or create a Brand_screen_times.
     * @example
     * // Update or create a Brand_screen_times
     * const brand_screen_times = await prisma.brand_screen_times.upsert({
     *   create: {
     *     // ... data to create a Brand_screen_times
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand_screen_times we want to update
     *   }
     * })
     */
    upsert<T extends brand_screen_timesUpsertArgs>(args: SelectSubset<T, brand_screen_timesUpsertArgs<ExtArgs>>): Prisma__brand_screen_timesClient<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Brand_screen_times that matches the filter.
     * @param {brand_screen_timesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const brand_screen_times = await prisma.brand_screen_times.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: brand_screen_timesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Brand_screen_times.
     * @param {brand_screen_timesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const brand_screen_times = await prisma.brand_screen_times.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: brand_screen_timesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Brand_screen_times.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brand_screen_timesCountArgs} args - Arguments to filter Brand_screen_times to count.
     * @example
     * // Count the number of Brand_screen_times
     * const count = await prisma.brand_screen_times.count({
     *   where: {
     *     // ... the filter for the Brand_screen_times we want to count
     *   }
     * })
    **/
    count<T extends brand_screen_timesCountArgs>(
      args?: Subset<T, brand_screen_timesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Brand_screen_timesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand_screen_times.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Brand_screen_timesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Brand_screen_timesAggregateArgs>(args: Subset<T, Brand_screen_timesAggregateArgs>): Prisma.PrismaPromise<GetBrand_screen_timesAggregateType<T>>

    /**
     * Group by Brand_screen_times.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brand_screen_timesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brand_screen_timesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brand_screen_timesGroupByArgs['orderBy'] }
        : { orderBy?: brand_screen_timesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brand_screen_timesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrand_screen_timesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brand_screen_times model
   */
  readonly fields: brand_screen_timesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brand_screen_times.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brand_screen_timesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    brand<T extends brand_screen_times$brandArgs<ExtArgs> = {}>(args?: Subset<T, brand_screen_times$brandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the brand_screen_times model
   */ 
  interface brand_screen_timesFieldRefs {
    readonly id: FieldRef<"brand_screen_times", 'String'>
    readonly time: FieldRef<"brand_screen_times", 'Int'>
    readonly userId: FieldRef<"brand_screen_times", 'String'>
    readonly brandId: FieldRef<"brand_screen_times", 'String'>
    readonly createdAt: FieldRef<"brand_screen_times", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * brand_screen_times findUnique
   */
  export type brand_screen_timesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * Filter, which brand_screen_times to fetch.
     */
    where: brand_screen_timesWhereUniqueInput
  }

  /**
   * brand_screen_times findUniqueOrThrow
   */
  export type brand_screen_timesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * Filter, which brand_screen_times to fetch.
     */
    where: brand_screen_timesWhereUniqueInput
  }

  /**
   * brand_screen_times findFirst
   */
  export type brand_screen_timesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * Filter, which brand_screen_times to fetch.
     */
    where?: brand_screen_timesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brand_screen_times to fetch.
     */
    orderBy?: brand_screen_timesOrderByWithRelationInput | brand_screen_timesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brand_screen_times.
     */
    cursor?: brand_screen_timesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brand_screen_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brand_screen_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brand_screen_times.
     */
    distinct?: Brand_screen_timesScalarFieldEnum | Brand_screen_timesScalarFieldEnum[]
  }

  /**
   * brand_screen_times findFirstOrThrow
   */
  export type brand_screen_timesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * Filter, which brand_screen_times to fetch.
     */
    where?: brand_screen_timesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brand_screen_times to fetch.
     */
    orderBy?: brand_screen_timesOrderByWithRelationInput | brand_screen_timesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brand_screen_times.
     */
    cursor?: brand_screen_timesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brand_screen_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brand_screen_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brand_screen_times.
     */
    distinct?: Brand_screen_timesScalarFieldEnum | Brand_screen_timesScalarFieldEnum[]
  }

  /**
   * brand_screen_times findMany
   */
  export type brand_screen_timesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * Filter, which brand_screen_times to fetch.
     */
    where?: brand_screen_timesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brand_screen_times to fetch.
     */
    orderBy?: brand_screen_timesOrderByWithRelationInput | brand_screen_timesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brand_screen_times.
     */
    cursor?: brand_screen_timesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brand_screen_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brand_screen_times.
     */
    skip?: number
    distinct?: Brand_screen_timesScalarFieldEnum | Brand_screen_timesScalarFieldEnum[]
  }

  /**
   * brand_screen_times create
   */
  export type brand_screen_timesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * The data needed to create a brand_screen_times.
     */
    data: XOR<brand_screen_timesCreateInput, brand_screen_timesUncheckedCreateInput>
  }

  /**
   * brand_screen_times createMany
   */
  export type brand_screen_timesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brand_screen_times.
     */
    data: brand_screen_timesCreateManyInput | brand_screen_timesCreateManyInput[]
  }

  /**
   * brand_screen_times update
   */
  export type brand_screen_timesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * The data needed to update a brand_screen_times.
     */
    data: XOR<brand_screen_timesUpdateInput, brand_screen_timesUncheckedUpdateInput>
    /**
     * Choose, which brand_screen_times to update.
     */
    where: brand_screen_timesWhereUniqueInput
  }

  /**
   * brand_screen_times updateMany
   */
  export type brand_screen_timesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brand_screen_times.
     */
    data: XOR<brand_screen_timesUpdateManyMutationInput, brand_screen_timesUncheckedUpdateManyInput>
    /**
     * Filter which brand_screen_times to update
     */
    where?: brand_screen_timesWhereInput
  }

  /**
   * brand_screen_times upsert
   */
  export type brand_screen_timesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * The filter to search for the brand_screen_times to update in case it exists.
     */
    where: brand_screen_timesWhereUniqueInput
    /**
     * In case the brand_screen_times found by the `where` argument doesn't exist, create a new brand_screen_times with this data.
     */
    create: XOR<brand_screen_timesCreateInput, brand_screen_timesUncheckedCreateInput>
    /**
     * In case the brand_screen_times was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brand_screen_timesUpdateInput, brand_screen_timesUncheckedUpdateInput>
  }

  /**
   * brand_screen_times delete
   */
  export type brand_screen_timesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    /**
     * Filter which brand_screen_times to delete.
     */
    where: brand_screen_timesWhereUniqueInput
  }

  /**
   * brand_screen_times deleteMany
   */
  export type brand_screen_timesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brand_screen_times to delete
     */
    where?: brand_screen_timesWhereInput
  }

  /**
   * brand_screen_times findRaw
   */
  export type brand_screen_timesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * brand_screen_times aggregateRaw
   */
  export type brand_screen_timesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * brand_screen_times.brand
   */
  export type brand_screen_times$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * brand_screen_times without action
   */
  export type brand_screen_timesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoriesMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: string
    name: JsonValue
    image: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brands?: boolean | categories$brandsArgs<ExtArgs>
    userChoices?: boolean | categories$userChoicesArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>


  export type categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | categories$brandsArgs<ExtArgs>
    userChoices?: boolean | categories$userChoicesArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      brands: Prisma.$brandsPayload<ExtArgs>[]
      userChoices: Prisma.$category_choicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: Prisma.JsonValue
      image: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {categoriesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const categories = await prisma.categories.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: categoriesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Categories.
     * @param {categoriesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const categories = await prisma.categories.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: categoriesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brands<T extends categories$brandsArgs<ExtArgs> = {}>(args?: Subset<T, categories$brandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany"> | Null>
    userChoices<T extends categories$userChoicesArgs<ExtArgs> = {}>(args?: Subset<T, categories$userChoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */ 
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'String'>
    readonly name: FieldRef<"categories", 'Json'>
    readonly image: FieldRef<"categories", 'Json'>
    readonly createdAt: FieldRef<"categories", 'DateTime'>
    readonly updatedAt: FieldRef<"categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
  }

  /**
   * categories findRaw
   */
  export type categoriesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * categories aggregateRaw
   */
  export type categoriesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * categories.brands
   */
  export type categories$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    cursor?: brandsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * categories.userChoices
   */
  export type categories$userChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    where?: category_choicesWhereInput
    orderBy?: category_choicesOrderByWithRelationInput | category_choicesOrderByWithRelationInput[]
    cursor?: category_choicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Category_choicesScalarFieldEnum | Category_choicesScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model category_choices
   */

  export type AggregateCategory_choices = {
    _count: Category_choicesCountAggregateOutputType | null
    _min: Category_choicesMinAggregateOutputType | null
    _max: Category_choicesMaxAggregateOutputType | null
  }

  export type Category_choicesMinAggregateOutputType = {
    id: string | null
    like: boolean | null
    categoryId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Category_choicesMaxAggregateOutputType = {
    id: string | null
    like: boolean | null
    categoryId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Category_choicesCountAggregateOutputType = {
    id: number
    like: number
    categoryId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Category_choicesMinAggregateInputType = {
    id?: true
    like?: true
    categoryId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Category_choicesMaxAggregateInputType = {
    id?: true
    like?: true
    categoryId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Category_choicesCountAggregateInputType = {
    id?: true
    like?: true
    categoryId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Category_choicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_choices to aggregate.
     */
    where?: category_choicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_choices to fetch.
     */
    orderBy?: category_choicesOrderByWithRelationInput | category_choicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: category_choicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned category_choices
    **/
    _count?: true | Category_choicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Category_choicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Category_choicesMaxAggregateInputType
  }

  export type GetCategory_choicesAggregateType<T extends Category_choicesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory_choices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory_choices[P]>
      : GetScalarType<T[P], AggregateCategory_choices[P]>
  }




  export type category_choicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: category_choicesWhereInput
    orderBy?: category_choicesOrderByWithAggregationInput | category_choicesOrderByWithAggregationInput[]
    by: Category_choicesScalarFieldEnum[] | Category_choicesScalarFieldEnum
    having?: category_choicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Category_choicesCountAggregateInputType | true
    _min?: Category_choicesMinAggregateInputType
    _max?: Category_choicesMaxAggregateInputType
  }

  export type Category_choicesGroupByOutputType = {
    id: string
    like: boolean
    categoryId: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: Category_choicesCountAggregateOutputType | null
    _min: Category_choicesMinAggregateOutputType | null
    _max: Category_choicesMaxAggregateOutputType | null
  }

  type GetCategory_choicesGroupByPayload<T extends category_choicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Category_choicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Category_choicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Category_choicesGroupByOutputType[P]>
            : GetScalarType<T[P], Category_choicesGroupByOutputType[P]>
        }
      >
    >


  export type category_choicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    like?: boolean
    categoryId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | categoriesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category_choices"]>


  export type category_choicesSelectScalar = {
    id?: boolean
    like?: boolean
    categoryId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type category_choicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | categoriesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $category_choicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category_choices"
    objects: {
      category: Prisma.$categoriesPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      like: boolean
      categoryId: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category_choices"]>
    composites: {}
  }

  type category_choicesGetPayload<S extends boolean | null | undefined | category_choicesDefaultArgs> = $Result.GetResult<Prisma.$category_choicesPayload, S>

  type category_choicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<category_choicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Category_choicesCountAggregateInputType | true
    }

  export interface category_choicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category_choices'], meta: { name: 'category_choices' } }
    /**
     * Find zero or one Category_choices that matches the filter.
     * @param {category_choicesFindUniqueArgs} args - Arguments to find a Category_choices
     * @example
     * // Get one Category_choices
     * const category_choices = await prisma.category_choices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends category_choicesFindUniqueArgs>(args: SelectSubset<T, category_choicesFindUniqueArgs<ExtArgs>>): Prisma__category_choicesClient<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category_choices that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {category_choicesFindUniqueOrThrowArgs} args - Arguments to find a Category_choices
     * @example
     * // Get one Category_choices
     * const category_choices = await prisma.category_choices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends category_choicesFindUniqueOrThrowArgs>(args: SelectSubset<T, category_choicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__category_choicesClient<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category_choices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_choicesFindFirstArgs} args - Arguments to find a Category_choices
     * @example
     * // Get one Category_choices
     * const category_choices = await prisma.category_choices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends category_choicesFindFirstArgs>(args?: SelectSubset<T, category_choicesFindFirstArgs<ExtArgs>>): Prisma__category_choicesClient<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category_choices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_choicesFindFirstOrThrowArgs} args - Arguments to find a Category_choices
     * @example
     * // Get one Category_choices
     * const category_choices = await prisma.category_choices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends category_choicesFindFirstOrThrowArgs>(args?: SelectSubset<T, category_choicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__category_choicesClient<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Category_choices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_choicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Category_choices
     * const category_choices = await prisma.category_choices.findMany()
     * 
     * // Get first 10 Category_choices
     * const category_choices = await prisma.category_choices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const category_choicesWithIdOnly = await prisma.category_choices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends category_choicesFindManyArgs>(args?: SelectSubset<T, category_choicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category_choices.
     * @param {category_choicesCreateArgs} args - Arguments to create a Category_choices.
     * @example
     * // Create one Category_choices
     * const Category_choices = await prisma.category_choices.create({
     *   data: {
     *     // ... data to create a Category_choices
     *   }
     * })
     * 
     */
    create<T extends category_choicesCreateArgs>(args: SelectSubset<T, category_choicesCreateArgs<ExtArgs>>): Prisma__category_choicesClient<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Category_choices.
     * @param {category_choicesCreateManyArgs} args - Arguments to create many Category_choices.
     * @example
     * // Create many Category_choices
     * const category_choices = await prisma.category_choices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends category_choicesCreateManyArgs>(args?: SelectSubset<T, category_choicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category_choices.
     * @param {category_choicesDeleteArgs} args - Arguments to delete one Category_choices.
     * @example
     * // Delete one Category_choices
     * const Category_choices = await prisma.category_choices.delete({
     *   where: {
     *     // ... filter to delete one Category_choices
     *   }
     * })
     * 
     */
    delete<T extends category_choicesDeleteArgs>(args: SelectSubset<T, category_choicesDeleteArgs<ExtArgs>>): Prisma__category_choicesClient<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category_choices.
     * @param {category_choicesUpdateArgs} args - Arguments to update one Category_choices.
     * @example
     * // Update one Category_choices
     * const category_choices = await prisma.category_choices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends category_choicesUpdateArgs>(args: SelectSubset<T, category_choicesUpdateArgs<ExtArgs>>): Prisma__category_choicesClient<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Category_choices.
     * @param {category_choicesDeleteManyArgs} args - Arguments to filter Category_choices to delete.
     * @example
     * // Delete a few Category_choices
     * const { count } = await prisma.category_choices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends category_choicesDeleteManyArgs>(args?: SelectSubset<T, category_choicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Category_choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_choicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Category_choices
     * const category_choices = await prisma.category_choices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends category_choicesUpdateManyArgs>(args: SelectSubset<T, category_choicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category_choices.
     * @param {category_choicesUpsertArgs} args - Arguments to update or create a Category_choices.
     * @example
     * // Update or create a Category_choices
     * const category_choices = await prisma.category_choices.upsert({
     *   create: {
     *     // ... data to create a Category_choices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category_choices we want to update
     *   }
     * })
     */
    upsert<T extends category_choicesUpsertArgs>(args: SelectSubset<T, category_choicesUpsertArgs<ExtArgs>>): Prisma__category_choicesClient<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Category_choices that matches the filter.
     * @param {category_choicesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category_choices = await prisma.category_choices.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: category_choicesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category_choices.
     * @param {category_choicesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category_choices = await prisma.category_choices.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: category_choicesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Category_choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_choicesCountArgs} args - Arguments to filter Category_choices to count.
     * @example
     * // Count the number of Category_choices
     * const count = await prisma.category_choices.count({
     *   where: {
     *     // ... the filter for the Category_choices we want to count
     *   }
     * })
    **/
    count<T extends category_choicesCountArgs>(
      args?: Subset<T, category_choicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Category_choicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category_choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Category_choicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Category_choicesAggregateArgs>(args: Subset<T, Category_choicesAggregateArgs>): Prisma.PrismaPromise<GetCategory_choicesAggregateType<T>>

    /**
     * Group by Category_choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_choicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends category_choicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: category_choicesGroupByArgs['orderBy'] }
        : { orderBy?: category_choicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, category_choicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategory_choicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category_choices model
   */
  readonly fields: category_choicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category_choices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__category_choicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriesDefaultArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category_choices model
   */ 
  interface category_choicesFieldRefs {
    readonly id: FieldRef<"category_choices", 'String'>
    readonly like: FieldRef<"category_choices", 'Boolean'>
    readonly categoryId: FieldRef<"category_choices", 'String'>
    readonly userId: FieldRef<"category_choices", 'String'>
    readonly createdAt: FieldRef<"category_choices", 'DateTime'>
    readonly updatedAt: FieldRef<"category_choices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * category_choices findUnique
   */
  export type category_choicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * Filter, which category_choices to fetch.
     */
    where: category_choicesWhereUniqueInput
  }

  /**
   * category_choices findUniqueOrThrow
   */
  export type category_choicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * Filter, which category_choices to fetch.
     */
    where: category_choicesWhereUniqueInput
  }

  /**
   * category_choices findFirst
   */
  export type category_choicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * Filter, which category_choices to fetch.
     */
    where?: category_choicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_choices to fetch.
     */
    orderBy?: category_choicesOrderByWithRelationInput | category_choicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_choices.
     */
    cursor?: category_choicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_choices.
     */
    distinct?: Category_choicesScalarFieldEnum | Category_choicesScalarFieldEnum[]
  }

  /**
   * category_choices findFirstOrThrow
   */
  export type category_choicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * Filter, which category_choices to fetch.
     */
    where?: category_choicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_choices to fetch.
     */
    orderBy?: category_choicesOrderByWithRelationInput | category_choicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_choices.
     */
    cursor?: category_choicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_choices.
     */
    distinct?: Category_choicesScalarFieldEnum | Category_choicesScalarFieldEnum[]
  }

  /**
   * category_choices findMany
   */
  export type category_choicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * Filter, which category_choices to fetch.
     */
    where?: category_choicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_choices to fetch.
     */
    orderBy?: category_choicesOrderByWithRelationInput | category_choicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing category_choices.
     */
    cursor?: category_choicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_choices.
     */
    skip?: number
    distinct?: Category_choicesScalarFieldEnum | Category_choicesScalarFieldEnum[]
  }

  /**
   * category_choices create
   */
  export type category_choicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * The data needed to create a category_choices.
     */
    data: XOR<category_choicesCreateInput, category_choicesUncheckedCreateInput>
  }

  /**
   * category_choices createMany
   */
  export type category_choicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many category_choices.
     */
    data: category_choicesCreateManyInput | category_choicesCreateManyInput[]
  }

  /**
   * category_choices update
   */
  export type category_choicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * The data needed to update a category_choices.
     */
    data: XOR<category_choicesUpdateInput, category_choicesUncheckedUpdateInput>
    /**
     * Choose, which category_choices to update.
     */
    where: category_choicesWhereUniqueInput
  }

  /**
   * category_choices updateMany
   */
  export type category_choicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update category_choices.
     */
    data: XOR<category_choicesUpdateManyMutationInput, category_choicesUncheckedUpdateManyInput>
    /**
     * Filter which category_choices to update
     */
    where?: category_choicesWhereInput
  }

  /**
   * category_choices upsert
   */
  export type category_choicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * The filter to search for the category_choices to update in case it exists.
     */
    where: category_choicesWhereUniqueInput
    /**
     * In case the category_choices found by the `where` argument doesn't exist, create a new category_choices with this data.
     */
    create: XOR<category_choicesCreateInput, category_choicesUncheckedCreateInput>
    /**
     * In case the category_choices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<category_choicesUpdateInput, category_choicesUncheckedUpdateInput>
  }

  /**
   * category_choices delete
   */
  export type category_choicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    /**
     * Filter which category_choices to delete.
     */
    where: category_choicesWhereUniqueInput
  }

  /**
   * category_choices deleteMany
   */
  export type category_choicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category_choices to delete
     */
    where?: category_choicesWhereInput
  }

  /**
   * category_choices findRaw
   */
  export type category_choicesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * category_choices aggregateRaw
   */
  export type category_choicesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * category_choices without action
   */
  export type category_choicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
  }


  /**
   * Model foundersReachedLeaderboard
   */

  export type AggregateFoundersReachedLeaderboard = {
    _count: FoundersReachedLeaderboardCountAggregateOutputType | null
    _avg: FoundersReachedLeaderboardAvgAggregateOutputType | null
    _sum: FoundersReachedLeaderboardSumAggregateOutputType | null
    _min: FoundersReachedLeaderboardMinAggregateOutputType | null
    _max: FoundersReachedLeaderboardMaxAggregateOutputType | null
  }

  export type FoundersReachedLeaderboardAvgAggregateOutputType = {
    amount: number | null
  }

  export type FoundersReachedLeaderboardSumAggregateOutputType = {
    amount: number | null
  }

  export type FoundersReachedLeaderboardMinAggregateOutputType = {
    id: string | null
    amount: number | null
  }

  export type FoundersReachedLeaderboardMaxAggregateOutputType = {
    id: string | null
    amount: number | null
  }

  export type FoundersReachedLeaderboardCountAggregateOutputType = {
    id: number
    amount: number
    _all: number
  }


  export type FoundersReachedLeaderboardAvgAggregateInputType = {
    amount?: true
  }

  export type FoundersReachedLeaderboardSumAggregateInputType = {
    amount?: true
  }

  export type FoundersReachedLeaderboardMinAggregateInputType = {
    id?: true
    amount?: true
  }

  export type FoundersReachedLeaderboardMaxAggregateInputType = {
    id?: true
    amount?: true
  }

  export type FoundersReachedLeaderboardCountAggregateInputType = {
    id?: true
    amount?: true
    _all?: true
  }

  export type FoundersReachedLeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which foundersReachedLeaderboard to aggregate.
     */
    where?: foundersReachedLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foundersReachedLeaderboards to fetch.
     */
    orderBy?: foundersReachedLeaderboardOrderByWithRelationInput | foundersReachedLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: foundersReachedLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foundersReachedLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foundersReachedLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned foundersReachedLeaderboards
    **/
    _count?: true | FoundersReachedLeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoundersReachedLeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoundersReachedLeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoundersReachedLeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoundersReachedLeaderboardMaxAggregateInputType
  }

  export type GetFoundersReachedLeaderboardAggregateType<T extends FoundersReachedLeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateFoundersReachedLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoundersReachedLeaderboard[P]>
      : GetScalarType<T[P], AggregateFoundersReachedLeaderboard[P]>
  }




  export type foundersReachedLeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: foundersReachedLeaderboardWhereInput
    orderBy?: foundersReachedLeaderboardOrderByWithAggregationInput | foundersReachedLeaderboardOrderByWithAggregationInput[]
    by: FoundersReachedLeaderboardScalarFieldEnum[] | FoundersReachedLeaderboardScalarFieldEnum
    having?: foundersReachedLeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoundersReachedLeaderboardCountAggregateInputType | true
    _avg?: FoundersReachedLeaderboardAvgAggregateInputType
    _sum?: FoundersReachedLeaderboardSumAggregateInputType
    _min?: FoundersReachedLeaderboardMinAggregateInputType
    _max?: FoundersReachedLeaderboardMaxAggregateInputType
  }

  export type FoundersReachedLeaderboardGroupByOutputType = {
    id: string
    amount: number
    _count: FoundersReachedLeaderboardCountAggregateOutputType | null
    _avg: FoundersReachedLeaderboardAvgAggregateOutputType | null
    _sum: FoundersReachedLeaderboardSumAggregateOutputType | null
    _min: FoundersReachedLeaderboardMinAggregateOutputType | null
    _max: FoundersReachedLeaderboardMaxAggregateOutputType | null
  }

  type GetFoundersReachedLeaderboardGroupByPayload<T extends foundersReachedLeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoundersReachedLeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoundersReachedLeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoundersReachedLeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], FoundersReachedLeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type foundersReachedLeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    users?: boolean | foundersReachedLeaderboard$usersArgs<ExtArgs>
    _count?: boolean | FoundersReachedLeaderboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foundersReachedLeaderboard"]>


  export type foundersReachedLeaderboardSelectScalar = {
    id?: boolean
    amount?: boolean
  }

  export type foundersReachedLeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | foundersReachedLeaderboard$usersArgs<ExtArgs>
    _count?: boolean | FoundersReachedLeaderboardCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $foundersReachedLeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "foundersReachedLeaderboard"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
    }, ExtArgs["result"]["foundersReachedLeaderboard"]>
    composites: {}
  }

  type foundersReachedLeaderboardGetPayload<S extends boolean | null | undefined | foundersReachedLeaderboardDefaultArgs> = $Result.GetResult<Prisma.$foundersReachedLeaderboardPayload, S>

  type foundersReachedLeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<foundersReachedLeaderboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoundersReachedLeaderboardCountAggregateInputType | true
    }

  export interface foundersReachedLeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['foundersReachedLeaderboard'], meta: { name: 'foundersReachedLeaderboard' } }
    /**
     * Find zero or one FoundersReachedLeaderboard that matches the filter.
     * @param {foundersReachedLeaderboardFindUniqueArgs} args - Arguments to find a FoundersReachedLeaderboard
     * @example
     * // Get one FoundersReachedLeaderboard
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends foundersReachedLeaderboardFindUniqueArgs>(args: SelectSubset<T, foundersReachedLeaderboardFindUniqueArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FoundersReachedLeaderboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {foundersReachedLeaderboardFindUniqueOrThrowArgs} args - Arguments to find a FoundersReachedLeaderboard
     * @example
     * // Get one FoundersReachedLeaderboard
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends foundersReachedLeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, foundersReachedLeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FoundersReachedLeaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foundersReachedLeaderboardFindFirstArgs} args - Arguments to find a FoundersReachedLeaderboard
     * @example
     * // Get one FoundersReachedLeaderboard
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends foundersReachedLeaderboardFindFirstArgs>(args?: SelectSubset<T, foundersReachedLeaderboardFindFirstArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FoundersReachedLeaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foundersReachedLeaderboardFindFirstOrThrowArgs} args - Arguments to find a FoundersReachedLeaderboard
     * @example
     * // Get one FoundersReachedLeaderboard
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends foundersReachedLeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, foundersReachedLeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FoundersReachedLeaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foundersReachedLeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoundersReachedLeaderboards
     * const foundersReachedLeaderboards = await prisma.foundersReachedLeaderboard.findMany()
     * 
     * // Get first 10 FoundersReachedLeaderboards
     * const foundersReachedLeaderboards = await prisma.foundersReachedLeaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foundersReachedLeaderboardWithIdOnly = await prisma.foundersReachedLeaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends foundersReachedLeaderboardFindManyArgs>(args?: SelectSubset<T, foundersReachedLeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FoundersReachedLeaderboard.
     * @param {foundersReachedLeaderboardCreateArgs} args - Arguments to create a FoundersReachedLeaderboard.
     * @example
     * // Create one FoundersReachedLeaderboard
     * const FoundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.create({
     *   data: {
     *     // ... data to create a FoundersReachedLeaderboard
     *   }
     * })
     * 
     */
    create<T extends foundersReachedLeaderboardCreateArgs>(args: SelectSubset<T, foundersReachedLeaderboardCreateArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FoundersReachedLeaderboards.
     * @param {foundersReachedLeaderboardCreateManyArgs} args - Arguments to create many FoundersReachedLeaderboards.
     * @example
     * // Create many FoundersReachedLeaderboards
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends foundersReachedLeaderboardCreateManyArgs>(args?: SelectSubset<T, foundersReachedLeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoundersReachedLeaderboard.
     * @param {foundersReachedLeaderboardDeleteArgs} args - Arguments to delete one FoundersReachedLeaderboard.
     * @example
     * // Delete one FoundersReachedLeaderboard
     * const FoundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.delete({
     *   where: {
     *     // ... filter to delete one FoundersReachedLeaderboard
     *   }
     * })
     * 
     */
    delete<T extends foundersReachedLeaderboardDeleteArgs>(args: SelectSubset<T, foundersReachedLeaderboardDeleteArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FoundersReachedLeaderboard.
     * @param {foundersReachedLeaderboardUpdateArgs} args - Arguments to update one FoundersReachedLeaderboard.
     * @example
     * // Update one FoundersReachedLeaderboard
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends foundersReachedLeaderboardUpdateArgs>(args: SelectSubset<T, foundersReachedLeaderboardUpdateArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FoundersReachedLeaderboards.
     * @param {foundersReachedLeaderboardDeleteManyArgs} args - Arguments to filter FoundersReachedLeaderboards to delete.
     * @example
     * // Delete a few FoundersReachedLeaderboards
     * const { count } = await prisma.foundersReachedLeaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends foundersReachedLeaderboardDeleteManyArgs>(args?: SelectSubset<T, foundersReachedLeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoundersReachedLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foundersReachedLeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoundersReachedLeaderboards
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends foundersReachedLeaderboardUpdateManyArgs>(args: SelectSubset<T, foundersReachedLeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoundersReachedLeaderboard.
     * @param {foundersReachedLeaderboardUpsertArgs} args - Arguments to update or create a FoundersReachedLeaderboard.
     * @example
     * // Update or create a FoundersReachedLeaderboard
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.upsert({
     *   create: {
     *     // ... data to create a FoundersReachedLeaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoundersReachedLeaderboard we want to update
     *   }
     * })
     */
    upsert<T extends foundersReachedLeaderboardUpsertArgs>(args: SelectSubset<T, foundersReachedLeaderboardUpsertArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more FoundersReachedLeaderboards that matches the filter.
     * @param {foundersReachedLeaderboardFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: foundersReachedLeaderboardFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FoundersReachedLeaderboard.
     * @param {foundersReachedLeaderboardAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const foundersReachedLeaderboard = await prisma.foundersReachedLeaderboard.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: foundersReachedLeaderboardAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FoundersReachedLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foundersReachedLeaderboardCountArgs} args - Arguments to filter FoundersReachedLeaderboards to count.
     * @example
     * // Count the number of FoundersReachedLeaderboards
     * const count = await prisma.foundersReachedLeaderboard.count({
     *   where: {
     *     // ... the filter for the FoundersReachedLeaderboards we want to count
     *   }
     * })
    **/
    count<T extends foundersReachedLeaderboardCountArgs>(
      args?: Subset<T, foundersReachedLeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoundersReachedLeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoundersReachedLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoundersReachedLeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoundersReachedLeaderboardAggregateArgs>(args: Subset<T, FoundersReachedLeaderboardAggregateArgs>): Prisma.PrismaPromise<GetFoundersReachedLeaderboardAggregateType<T>>

    /**
     * Group by FoundersReachedLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foundersReachedLeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends foundersReachedLeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: foundersReachedLeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: foundersReachedLeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, foundersReachedLeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoundersReachedLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the foundersReachedLeaderboard model
   */
  readonly fields: foundersReachedLeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for foundersReachedLeaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__foundersReachedLeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends foundersReachedLeaderboard$usersArgs<ExtArgs> = {}>(args?: Subset<T, foundersReachedLeaderboard$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the foundersReachedLeaderboard model
   */ 
  interface foundersReachedLeaderboardFieldRefs {
    readonly id: FieldRef<"foundersReachedLeaderboard", 'String'>
    readonly amount: FieldRef<"foundersReachedLeaderboard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * foundersReachedLeaderboard findUnique
   */
  export type foundersReachedLeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which foundersReachedLeaderboard to fetch.
     */
    where: foundersReachedLeaderboardWhereUniqueInput
  }

  /**
   * foundersReachedLeaderboard findUniqueOrThrow
   */
  export type foundersReachedLeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which foundersReachedLeaderboard to fetch.
     */
    where: foundersReachedLeaderboardWhereUniqueInput
  }

  /**
   * foundersReachedLeaderboard findFirst
   */
  export type foundersReachedLeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which foundersReachedLeaderboard to fetch.
     */
    where?: foundersReachedLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foundersReachedLeaderboards to fetch.
     */
    orderBy?: foundersReachedLeaderboardOrderByWithRelationInput | foundersReachedLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for foundersReachedLeaderboards.
     */
    cursor?: foundersReachedLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foundersReachedLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foundersReachedLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of foundersReachedLeaderboards.
     */
    distinct?: FoundersReachedLeaderboardScalarFieldEnum | FoundersReachedLeaderboardScalarFieldEnum[]
  }

  /**
   * foundersReachedLeaderboard findFirstOrThrow
   */
  export type foundersReachedLeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which foundersReachedLeaderboard to fetch.
     */
    where?: foundersReachedLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foundersReachedLeaderboards to fetch.
     */
    orderBy?: foundersReachedLeaderboardOrderByWithRelationInput | foundersReachedLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for foundersReachedLeaderboards.
     */
    cursor?: foundersReachedLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foundersReachedLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foundersReachedLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of foundersReachedLeaderboards.
     */
    distinct?: FoundersReachedLeaderboardScalarFieldEnum | FoundersReachedLeaderboardScalarFieldEnum[]
  }

  /**
   * foundersReachedLeaderboard findMany
   */
  export type foundersReachedLeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which foundersReachedLeaderboards to fetch.
     */
    where?: foundersReachedLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foundersReachedLeaderboards to fetch.
     */
    orderBy?: foundersReachedLeaderboardOrderByWithRelationInput | foundersReachedLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing foundersReachedLeaderboards.
     */
    cursor?: foundersReachedLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foundersReachedLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foundersReachedLeaderboards.
     */
    skip?: number
    distinct?: FoundersReachedLeaderboardScalarFieldEnum | FoundersReachedLeaderboardScalarFieldEnum[]
  }

  /**
   * foundersReachedLeaderboard create
   */
  export type foundersReachedLeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a foundersReachedLeaderboard.
     */
    data: XOR<foundersReachedLeaderboardCreateInput, foundersReachedLeaderboardUncheckedCreateInput>
  }

  /**
   * foundersReachedLeaderboard createMany
   */
  export type foundersReachedLeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many foundersReachedLeaderboards.
     */
    data: foundersReachedLeaderboardCreateManyInput | foundersReachedLeaderboardCreateManyInput[]
  }

  /**
   * foundersReachedLeaderboard update
   */
  export type foundersReachedLeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a foundersReachedLeaderboard.
     */
    data: XOR<foundersReachedLeaderboardUpdateInput, foundersReachedLeaderboardUncheckedUpdateInput>
    /**
     * Choose, which foundersReachedLeaderboard to update.
     */
    where: foundersReachedLeaderboardWhereUniqueInput
  }

  /**
   * foundersReachedLeaderboard updateMany
   */
  export type foundersReachedLeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update foundersReachedLeaderboards.
     */
    data: XOR<foundersReachedLeaderboardUpdateManyMutationInput, foundersReachedLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which foundersReachedLeaderboards to update
     */
    where?: foundersReachedLeaderboardWhereInput
  }

  /**
   * foundersReachedLeaderboard upsert
   */
  export type foundersReachedLeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the foundersReachedLeaderboard to update in case it exists.
     */
    where: foundersReachedLeaderboardWhereUniqueInput
    /**
     * In case the foundersReachedLeaderboard found by the `where` argument doesn't exist, create a new foundersReachedLeaderboard with this data.
     */
    create: XOR<foundersReachedLeaderboardCreateInput, foundersReachedLeaderboardUncheckedCreateInput>
    /**
     * In case the foundersReachedLeaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<foundersReachedLeaderboardUpdateInput, foundersReachedLeaderboardUncheckedUpdateInput>
  }

  /**
   * foundersReachedLeaderboard delete
   */
  export type foundersReachedLeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    /**
     * Filter which foundersReachedLeaderboard to delete.
     */
    where: foundersReachedLeaderboardWhereUniqueInput
  }

  /**
   * foundersReachedLeaderboard deleteMany
   */
  export type foundersReachedLeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which foundersReachedLeaderboards to delete
     */
    where?: foundersReachedLeaderboardWhereInput
  }

  /**
   * foundersReachedLeaderboard findRaw
   */
  export type foundersReachedLeaderboardFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * foundersReachedLeaderboard aggregateRaw
   */
  export type foundersReachedLeaderboardAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * foundersReachedLeaderboard.users
   */
  export type foundersReachedLeaderboard$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * foundersReachedLeaderboard without action
   */
  export type foundersReachedLeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model link_visits
   */

  export type AggregateLink_visits = {
    _count: Link_visitsCountAggregateOutputType | null
    _min: Link_visitsMinAggregateOutputType | null
    _max: Link_visitsMaxAggregateOutputType | null
  }

  export type Link_visitsMinAggregateOutputType = {
    id: string | null
    url: string | null
    userId: string | null
    brandId: string | null
    productId: string | null
    benefitId: string | null
    createdAt: Date | null
  }

  export type Link_visitsMaxAggregateOutputType = {
    id: string | null
    url: string | null
    userId: string | null
    brandId: string | null
    productId: string | null
    benefitId: string | null
    createdAt: Date | null
  }

  export type Link_visitsCountAggregateOutputType = {
    id: number
    url: number
    userId: number
    brandId: number
    productId: number
    benefitId: number
    createdAt: number
    _all: number
  }


  export type Link_visitsMinAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    brandId?: true
    productId?: true
    benefitId?: true
    createdAt?: true
  }

  export type Link_visitsMaxAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    brandId?: true
    productId?: true
    benefitId?: true
    createdAt?: true
  }

  export type Link_visitsCountAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    brandId?: true
    productId?: true
    benefitId?: true
    createdAt?: true
    _all?: true
  }

  export type Link_visitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which link_visits to aggregate.
     */
    where?: link_visitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of link_visits to fetch.
     */
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: link_visitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` link_visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` link_visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned link_visits
    **/
    _count?: true | Link_visitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Link_visitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Link_visitsMaxAggregateInputType
  }

  export type GetLink_visitsAggregateType<T extends Link_visitsAggregateArgs> = {
        [P in keyof T & keyof AggregateLink_visits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLink_visits[P]>
      : GetScalarType<T[P], AggregateLink_visits[P]>
  }




  export type link_visitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: link_visitsWhereInput
    orderBy?: link_visitsOrderByWithAggregationInput | link_visitsOrderByWithAggregationInput[]
    by: Link_visitsScalarFieldEnum[] | Link_visitsScalarFieldEnum
    having?: link_visitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Link_visitsCountAggregateInputType | true
    _min?: Link_visitsMinAggregateInputType
    _max?: Link_visitsMaxAggregateInputType
  }

  export type Link_visitsGroupByOutputType = {
    id: string
    url: string
    userId: string
    brandId: string | null
    productId: string | null
    benefitId: string | null
    createdAt: Date
    _count: Link_visitsCountAggregateOutputType | null
    _min: Link_visitsMinAggregateOutputType | null
    _max: Link_visitsMaxAggregateOutputType | null
  }

  type GetLink_visitsGroupByPayload<T extends link_visitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Link_visitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Link_visitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Link_visitsGroupByOutputType[P]>
            : GetScalarType<T[P], Link_visitsGroupByOutputType[P]>
        }
      >
    >


  export type link_visitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    userId?: boolean
    brandId?: boolean
    productId?: boolean
    benefitId?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    brand?: boolean | link_visits$brandArgs<ExtArgs>
    product?: boolean | link_visits$productArgs<ExtArgs>
    benefit?: boolean | link_visits$benefitArgs<ExtArgs>
  }, ExtArgs["result"]["link_visits"]>


  export type link_visitsSelectScalar = {
    id?: boolean
    url?: boolean
    userId?: boolean
    brandId?: boolean
    productId?: boolean
    benefitId?: boolean
    createdAt?: boolean
  }

  export type link_visitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    brand?: boolean | link_visits$brandArgs<ExtArgs>
    product?: boolean | link_visits$productArgs<ExtArgs>
    benefit?: boolean | link_visits$benefitArgs<ExtArgs>
  }

  export type $link_visitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "link_visits"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      brand: Prisma.$brandsPayload<ExtArgs> | null
      product: Prisma.$productsPayload<ExtArgs> | null
      benefit: Prisma.$benefitsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      userId: string
      brandId: string | null
      productId: string | null
      benefitId: string | null
      createdAt: Date
    }, ExtArgs["result"]["link_visits"]>
    composites: {}
  }

  type link_visitsGetPayload<S extends boolean | null | undefined | link_visitsDefaultArgs> = $Result.GetResult<Prisma.$link_visitsPayload, S>

  type link_visitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<link_visitsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Link_visitsCountAggregateInputType | true
    }

  export interface link_visitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['link_visits'], meta: { name: 'link_visits' } }
    /**
     * Find zero or one Link_visits that matches the filter.
     * @param {link_visitsFindUniqueArgs} args - Arguments to find a Link_visits
     * @example
     * // Get one Link_visits
     * const link_visits = await prisma.link_visits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends link_visitsFindUniqueArgs>(args: SelectSubset<T, link_visitsFindUniqueArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Link_visits that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {link_visitsFindUniqueOrThrowArgs} args - Arguments to find a Link_visits
     * @example
     * // Get one Link_visits
     * const link_visits = await prisma.link_visits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends link_visitsFindUniqueOrThrowArgs>(args: SelectSubset<T, link_visitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Link_visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsFindFirstArgs} args - Arguments to find a Link_visits
     * @example
     * // Get one Link_visits
     * const link_visits = await prisma.link_visits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends link_visitsFindFirstArgs>(args?: SelectSubset<T, link_visitsFindFirstArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Link_visits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsFindFirstOrThrowArgs} args - Arguments to find a Link_visits
     * @example
     * // Get one Link_visits
     * const link_visits = await prisma.link_visits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends link_visitsFindFirstOrThrowArgs>(args?: SelectSubset<T, link_visitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Link_visits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Link_visits
     * const link_visits = await prisma.link_visits.findMany()
     * 
     * // Get first 10 Link_visits
     * const link_visits = await prisma.link_visits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const link_visitsWithIdOnly = await prisma.link_visits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends link_visitsFindManyArgs>(args?: SelectSubset<T, link_visitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Link_visits.
     * @param {link_visitsCreateArgs} args - Arguments to create a Link_visits.
     * @example
     * // Create one Link_visits
     * const Link_visits = await prisma.link_visits.create({
     *   data: {
     *     // ... data to create a Link_visits
     *   }
     * })
     * 
     */
    create<T extends link_visitsCreateArgs>(args: SelectSubset<T, link_visitsCreateArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Link_visits.
     * @param {link_visitsCreateManyArgs} args - Arguments to create many Link_visits.
     * @example
     * // Create many Link_visits
     * const link_visits = await prisma.link_visits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends link_visitsCreateManyArgs>(args?: SelectSubset<T, link_visitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Link_visits.
     * @param {link_visitsDeleteArgs} args - Arguments to delete one Link_visits.
     * @example
     * // Delete one Link_visits
     * const Link_visits = await prisma.link_visits.delete({
     *   where: {
     *     // ... filter to delete one Link_visits
     *   }
     * })
     * 
     */
    delete<T extends link_visitsDeleteArgs>(args: SelectSubset<T, link_visitsDeleteArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Link_visits.
     * @param {link_visitsUpdateArgs} args - Arguments to update one Link_visits.
     * @example
     * // Update one Link_visits
     * const link_visits = await prisma.link_visits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends link_visitsUpdateArgs>(args: SelectSubset<T, link_visitsUpdateArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Link_visits.
     * @param {link_visitsDeleteManyArgs} args - Arguments to filter Link_visits to delete.
     * @example
     * // Delete a few Link_visits
     * const { count } = await prisma.link_visits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends link_visitsDeleteManyArgs>(args?: SelectSubset<T, link_visitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Link_visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Link_visits
     * const link_visits = await prisma.link_visits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends link_visitsUpdateManyArgs>(args: SelectSubset<T, link_visitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Link_visits.
     * @param {link_visitsUpsertArgs} args - Arguments to update or create a Link_visits.
     * @example
     * // Update or create a Link_visits
     * const link_visits = await prisma.link_visits.upsert({
     *   create: {
     *     // ... data to create a Link_visits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Link_visits we want to update
     *   }
     * })
     */
    upsert<T extends link_visitsUpsertArgs>(args: SelectSubset<T, link_visitsUpsertArgs<ExtArgs>>): Prisma__link_visitsClient<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Link_visits that matches the filter.
     * @param {link_visitsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const link_visits = await prisma.link_visits.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: link_visitsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Link_visits.
     * @param {link_visitsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const link_visits = await prisma.link_visits.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: link_visitsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Link_visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsCountArgs} args - Arguments to filter Link_visits to count.
     * @example
     * // Count the number of Link_visits
     * const count = await prisma.link_visits.count({
     *   where: {
     *     // ... the filter for the Link_visits we want to count
     *   }
     * })
    **/
    count<T extends link_visitsCountArgs>(
      args?: Subset<T, link_visitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Link_visitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Link_visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Link_visitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Link_visitsAggregateArgs>(args: Subset<T, Link_visitsAggregateArgs>): Prisma.PrismaPromise<GetLink_visitsAggregateType<T>>

    /**
     * Group by Link_visits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {link_visitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends link_visitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: link_visitsGroupByArgs['orderBy'] }
        : { orderBy?: link_visitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, link_visitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLink_visitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the link_visits model
   */
  readonly fields: link_visitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for link_visits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__link_visitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    brand<T extends link_visits$brandArgs<ExtArgs> = {}>(args?: Subset<T, link_visits$brandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product<T extends link_visits$productArgs<ExtArgs> = {}>(args?: Subset<T, link_visits$productArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    benefit<T extends link_visits$benefitArgs<ExtArgs> = {}>(args?: Subset<T, link_visits$benefitArgs<ExtArgs>>): Prisma__benefitsClient<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the link_visits model
   */ 
  interface link_visitsFieldRefs {
    readonly id: FieldRef<"link_visits", 'String'>
    readonly url: FieldRef<"link_visits", 'String'>
    readonly userId: FieldRef<"link_visits", 'String'>
    readonly brandId: FieldRef<"link_visits", 'String'>
    readonly productId: FieldRef<"link_visits", 'String'>
    readonly benefitId: FieldRef<"link_visits", 'String'>
    readonly createdAt: FieldRef<"link_visits", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * link_visits findUnique
   */
  export type link_visitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where: link_visitsWhereUniqueInput
  }

  /**
   * link_visits findUniqueOrThrow
   */
  export type link_visitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where: link_visitsWhereUniqueInput
  }

  /**
   * link_visits findFirst
   */
  export type link_visitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where?: link_visitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of link_visits to fetch.
     */
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for link_visits.
     */
    cursor?: link_visitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` link_visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` link_visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of link_visits.
     */
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * link_visits findFirstOrThrow
   */
  export type link_visitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where?: link_visitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of link_visits to fetch.
     */
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for link_visits.
     */
    cursor?: link_visitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` link_visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` link_visits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of link_visits.
     */
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * link_visits findMany
   */
  export type link_visitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter, which link_visits to fetch.
     */
    where?: link_visitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of link_visits to fetch.
     */
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing link_visits.
     */
    cursor?: link_visitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` link_visits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` link_visits.
     */
    skip?: number
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * link_visits create
   */
  export type link_visitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * The data needed to create a link_visits.
     */
    data: XOR<link_visitsCreateInput, link_visitsUncheckedCreateInput>
  }

  /**
   * link_visits createMany
   */
  export type link_visitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many link_visits.
     */
    data: link_visitsCreateManyInput | link_visitsCreateManyInput[]
  }

  /**
   * link_visits update
   */
  export type link_visitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * The data needed to update a link_visits.
     */
    data: XOR<link_visitsUpdateInput, link_visitsUncheckedUpdateInput>
    /**
     * Choose, which link_visits to update.
     */
    where: link_visitsWhereUniqueInput
  }

  /**
   * link_visits updateMany
   */
  export type link_visitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update link_visits.
     */
    data: XOR<link_visitsUpdateManyMutationInput, link_visitsUncheckedUpdateManyInput>
    /**
     * Filter which link_visits to update
     */
    where?: link_visitsWhereInput
  }

  /**
   * link_visits upsert
   */
  export type link_visitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * The filter to search for the link_visits to update in case it exists.
     */
    where: link_visitsWhereUniqueInput
    /**
     * In case the link_visits found by the `where` argument doesn't exist, create a new link_visits with this data.
     */
    create: XOR<link_visitsCreateInput, link_visitsUncheckedCreateInput>
    /**
     * In case the link_visits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<link_visitsUpdateInput, link_visitsUncheckedUpdateInput>
  }

  /**
   * link_visits delete
   */
  export type link_visitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    /**
     * Filter which link_visits to delete.
     */
    where: link_visitsWhereUniqueInput
  }

  /**
   * link_visits deleteMany
   */
  export type link_visitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which link_visits to delete
     */
    where?: link_visitsWhereInput
  }

  /**
   * link_visits findRaw
   */
  export type link_visitsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * link_visits aggregateRaw
   */
  export type link_visitsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * link_visits.brand
   */
  export type link_visits$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * link_visits.product
   */
  export type link_visits$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * link_visits.benefit
   */
  export type link_visits$benefitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    where?: benefitsWhereInput
  }

  /**
   * link_visits without action
   */
  export type link_visitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
  }


  /**
   * Model pitch_views
   */

  export type AggregatePitch_views = {
    _count: Pitch_viewsCountAggregateOutputType | null
    _min: Pitch_viewsMinAggregateOutputType | null
    _max: Pitch_viewsMaxAggregateOutputType | null
  }

  export type Pitch_viewsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    brandId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pitch_viewsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    brandId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pitch_viewsCountAggregateOutputType = {
    id: number
    userId: number
    brandId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Pitch_viewsMinAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pitch_viewsMaxAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pitch_viewsCountAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Pitch_viewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pitch_views to aggregate.
     */
    where?: pitch_viewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pitch_views to fetch.
     */
    orderBy?: pitch_viewsOrderByWithRelationInput | pitch_viewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pitch_viewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pitch_views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pitch_views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pitch_views
    **/
    _count?: true | Pitch_viewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pitch_viewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pitch_viewsMaxAggregateInputType
  }

  export type GetPitch_viewsAggregateType<T extends Pitch_viewsAggregateArgs> = {
        [P in keyof T & keyof AggregatePitch_views]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePitch_views[P]>
      : GetScalarType<T[P], AggregatePitch_views[P]>
  }




  export type pitch_viewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pitch_viewsWhereInput
    orderBy?: pitch_viewsOrderByWithAggregationInput | pitch_viewsOrderByWithAggregationInput[]
    by: Pitch_viewsScalarFieldEnum[] | Pitch_viewsScalarFieldEnum
    having?: pitch_viewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pitch_viewsCountAggregateInputType | true
    _min?: Pitch_viewsMinAggregateInputType
    _max?: Pitch_viewsMaxAggregateInputType
  }

  export type Pitch_viewsGroupByOutputType = {
    id: string
    userId: string
    brandId: string | null
    createdAt: Date
    updatedAt: Date
    _count: Pitch_viewsCountAggregateOutputType | null
    _min: Pitch_viewsMinAggregateOutputType | null
    _max: Pitch_viewsMaxAggregateOutputType | null
  }

  type GetPitch_viewsGroupByPayload<T extends pitch_viewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pitch_viewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pitch_viewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pitch_viewsGroupByOutputType[P]>
            : GetScalarType<T[P], Pitch_viewsGroupByOutputType[P]>
        }
      >
    >


  export type pitch_viewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    brand?: boolean | pitch_views$brandArgs<ExtArgs>
  }, ExtArgs["result"]["pitch_views"]>


  export type pitch_viewsSelectScalar = {
    id?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type pitch_viewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    brand?: boolean | pitch_views$brandArgs<ExtArgs>
  }

  export type $pitch_viewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pitch_views"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      brand: Prisma.$brandsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      brandId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pitch_views"]>
    composites: {}
  }

  type pitch_viewsGetPayload<S extends boolean | null | undefined | pitch_viewsDefaultArgs> = $Result.GetResult<Prisma.$pitch_viewsPayload, S>

  type pitch_viewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pitch_viewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pitch_viewsCountAggregateInputType | true
    }

  export interface pitch_viewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pitch_views'], meta: { name: 'pitch_views' } }
    /**
     * Find zero or one Pitch_views that matches the filter.
     * @param {pitch_viewsFindUniqueArgs} args - Arguments to find a Pitch_views
     * @example
     * // Get one Pitch_views
     * const pitch_views = await prisma.pitch_views.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pitch_viewsFindUniqueArgs>(args: SelectSubset<T, pitch_viewsFindUniqueArgs<ExtArgs>>): Prisma__pitch_viewsClient<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pitch_views that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pitch_viewsFindUniqueOrThrowArgs} args - Arguments to find a Pitch_views
     * @example
     * // Get one Pitch_views
     * const pitch_views = await prisma.pitch_views.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pitch_viewsFindUniqueOrThrowArgs>(args: SelectSubset<T, pitch_viewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pitch_viewsClient<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pitch_views that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pitch_viewsFindFirstArgs} args - Arguments to find a Pitch_views
     * @example
     * // Get one Pitch_views
     * const pitch_views = await prisma.pitch_views.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pitch_viewsFindFirstArgs>(args?: SelectSubset<T, pitch_viewsFindFirstArgs<ExtArgs>>): Prisma__pitch_viewsClient<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pitch_views that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pitch_viewsFindFirstOrThrowArgs} args - Arguments to find a Pitch_views
     * @example
     * // Get one Pitch_views
     * const pitch_views = await prisma.pitch_views.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pitch_viewsFindFirstOrThrowArgs>(args?: SelectSubset<T, pitch_viewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__pitch_viewsClient<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pitch_views that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pitch_viewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pitch_views
     * const pitch_views = await prisma.pitch_views.findMany()
     * 
     * // Get first 10 Pitch_views
     * const pitch_views = await prisma.pitch_views.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pitch_viewsWithIdOnly = await prisma.pitch_views.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pitch_viewsFindManyArgs>(args?: SelectSubset<T, pitch_viewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pitch_views.
     * @param {pitch_viewsCreateArgs} args - Arguments to create a Pitch_views.
     * @example
     * // Create one Pitch_views
     * const Pitch_views = await prisma.pitch_views.create({
     *   data: {
     *     // ... data to create a Pitch_views
     *   }
     * })
     * 
     */
    create<T extends pitch_viewsCreateArgs>(args: SelectSubset<T, pitch_viewsCreateArgs<ExtArgs>>): Prisma__pitch_viewsClient<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pitch_views.
     * @param {pitch_viewsCreateManyArgs} args - Arguments to create many Pitch_views.
     * @example
     * // Create many Pitch_views
     * const pitch_views = await prisma.pitch_views.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pitch_viewsCreateManyArgs>(args?: SelectSubset<T, pitch_viewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pitch_views.
     * @param {pitch_viewsDeleteArgs} args - Arguments to delete one Pitch_views.
     * @example
     * // Delete one Pitch_views
     * const Pitch_views = await prisma.pitch_views.delete({
     *   where: {
     *     // ... filter to delete one Pitch_views
     *   }
     * })
     * 
     */
    delete<T extends pitch_viewsDeleteArgs>(args: SelectSubset<T, pitch_viewsDeleteArgs<ExtArgs>>): Prisma__pitch_viewsClient<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pitch_views.
     * @param {pitch_viewsUpdateArgs} args - Arguments to update one Pitch_views.
     * @example
     * // Update one Pitch_views
     * const pitch_views = await prisma.pitch_views.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pitch_viewsUpdateArgs>(args: SelectSubset<T, pitch_viewsUpdateArgs<ExtArgs>>): Prisma__pitch_viewsClient<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pitch_views.
     * @param {pitch_viewsDeleteManyArgs} args - Arguments to filter Pitch_views to delete.
     * @example
     * // Delete a few Pitch_views
     * const { count } = await prisma.pitch_views.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pitch_viewsDeleteManyArgs>(args?: SelectSubset<T, pitch_viewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pitch_views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pitch_viewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pitch_views
     * const pitch_views = await prisma.pitch_views.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pitch_viewsUpdateManyArgs>(args: SelectSubset<T, pitch_viewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pitch_views.
     * @param {pitch_viewsUpsertArgs} args - Arguments to update or create a Pitch_views.
     * @example
     * // Update or create a Pitch_views
     * const pitch_views = await prisma.pitch_views.upsert({
     *   create: {
     *     // ... data to create a Pitch_views
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pitch_views we want to update
     *   }
     * })
     */
    upsert<T extends pitch_viewsUpsertArgs>(args: SelectSubset<T, pitch_viewsUpsertArgs<ExtArgs>>): Prisma__pitch_viewsClient<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Pitch_views that matches the filter.
     * @param {pitch_viewsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pitch_views = await prisma.pitch_views.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: pitch_viewsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Pitch_views.
     * @param {pitch_viewsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pitch_views = await prisma.pitch_views.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: pitch_viewsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Pitch_views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pitch_viewsCountArgs} args - Arguments to filter Pitch_views to count.
     * @example
     * // Count the number of Pitch_views
     * const count = await prisma.pitch_views.count({
     *   where: {
     *     // ... the filter for the Pitch_views we want to count
     *   }
     * })
    **/
    count<T extends pitch_viewsCountArgs>(
      args?: Subset<T, pitch_viewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pitch_viewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pitch_views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pitch_viewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pitch_viewsAggregateArgs>(args: Subset<T, Pitch_viewsAggregateArgs>): Prisma.PrismaPromise<GetPitch_viewsAggregateType<T>>

    /**
     * Group by Pitch_views.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pitch_viewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pitch_viewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pitch_viewsGroupByArgs['orderBy'] }
        : { orderBy?: pitch_viewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pitch_viewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPitch_viewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pitch_views model
   */
  readonly fields: pitch_viewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pitch_views.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pitch_viewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    brand<T extends pitch_views$brandArgs<ExtArgs> = {}>(args?: Subset<T, pitch_views$brandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pitch_views model
   */ 
  interface pitch_viewsFieldRefs {
    readonly id: FieldRef<"pitch_views", 'String'>
    readonly userId: FieldRef<"pitch_views", 'String'>
    readonly brandId: FieldRef<"pitch_views", 'String'>
    readonly createdAt: FieldRef<"pitch_views", 'DateTime'>
    readonly updatedAt: FieldRef<"pitch_views", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pitch_views findUnique
   */
  export type pitch_viewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * Filter, which pitch_views to fetch.
     */
    where: pitch_viewsWhereUniqueInput
  }

  /**
   * pitch_views findUniqueOrThrow
   */
  export type pitch_viewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * Filter, which pitch_views to fetch.
     */
    where: pitch_viewsWhereUniqueInput
  }

  /**
   * pitch_views findFirst
   */
  export type pitch_viewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * Filter, which pitch_views to fetch.
     */
    where?: pitch_viewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pitch_views to fetch.
     */
    orderBy?: pitch_viewsOrderByWithRelationInput | pitch_viewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pitch_views.
     */
    cursor?: pitch_viewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pitch_views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pitch_views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pitch_views.
     */
    distinct?: Pitch_viewsScalarFieldEnum | Pitch_viewsScalarFieldEnum[]
  }

  /**
   * pitch_views findFirstOrThrow
   */
  export type pitch_viewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * Filter, which pitch_views to fetch.
     */
    where?: pitch_viewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pitch_views to fetch.
     */
    orderBy?: pitch_viewsOrderByWithRelationInput | pitch_viewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pitch_views.
     */
    cursor?: pitch_viewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pitch_views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pitch_views.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pitch_views.
     */
    distinct?: Pitch_viewsScalarFieldEnum | Pitch_viewsScalarFieldEnum[]
  }

  /**
   * pitch_views findMany
   */
  export type pitch_viewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * Filter, which pitch_views to fetch.
     */
    where?: pitch_viewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pitch_views to fetch.
     */
    orderBy?: pitch_viewsOrderByWithRelationInput | pitch_viewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pitch_views.
     */
    cursor?: pitch_viewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pitch_views from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pitch_views.
     */
    skip?: number
    distinct?: Pitch_viewsScalarFieldEnum | Pitch_viewsScalarFieldEnum[]
  }

  /**
   * pitch_views create
   */
  export type pitch_viewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * The data needed to create a pitch_views.
     */
    data: XOR<pitch_viewsCreateInput, pitch_viewsUncheckedCreateInput>
  }

  /**
   * pitch_views createMany
   */
  export type pitch_viewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pitch_views.
     */
    data: pitch_viewsCreateManyInput | pitch_viewsCreateManyInput[]
  }

  /**
   * pitch_views update
   */
  export type pitch_viewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * The data needed to update a pitch_views.
     */
    data: XOR<pitch_viewsUpdateInput, pitch_viewsUncheckedUpdateInput>
    /**
     * Choose, which pitch_views to update.
     */
    where: pitch_viewsWhereUniqueInput
  }

  /**
   * pitch_views updateMany
   */
  export type pitch_viewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pitch_views.
     */
    data: XOR<pitch_viewsUpdateManyMutationInput, pitch_viewsUncheckedUpdateManyInput>
    /**
     * Filter which pitch_views to update
     */
    where?: pitch_viewsWhereInput
  }

  /**
   * pitch_views upsert
   */
  export type pitch_viewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * The filter to search for the pitch_views to update in case it exists.
     */
    where: pitch_viewsWhereUniqueInput
    /**
     * In case the pitch_views found by the `where` argument doesn't exist, create a new pitch_views with this data.
     */
    create: XOR<pitch_viewsCreateInput, pitch_viewsUncheckedCreateInput>
    /**
     * In case the pitch_views was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pitch_viewsUpdateInput, pitch_viewsUncheckedUpdateInput>
  }

  /**
   * pitch_views delete
   */
  export type pitch_viewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    /**
     * Filter which pitch_views to delete.
     */
    where: pitch_viewsWhereUniqueInput
  }

  /**
   * pitch_views deleteMany
   */
  export type pitch_viewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pitch_views to delete
     */
    where?: pitch_viewsWhereInput
  }

  /**
   * pitch_views findRaw
   */
  export type pitch_viewsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * pitch_views aggregateRaw
   */
  export type pitch_viewsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * pitch_views.brand
   */
  export type pitch_views$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * pitch_views without action
   */
  export type pitch_viewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
  }


  /**
   * Model posts
   */

  export type AggregatePosts = {
    _count: PostsCountAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  export type PostsMinAggregateOutputType = {
    id: string | null
    title: string | null
    author: string | null
    content: string | null
    video: string | null
    brandId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    author: string | null
    content: string | null
    video: string | null
    brandId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostsCountAggregateOutputType = {
    id: number
    title: number
    author: number
    content: number
    video: number
    image: number
    brandId: number
    userLikesIds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostsMinAggregateInputType = {
    id?: true
    title?: true
    author?: true
    content?: true
    video?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostsMaxAggregateInputType = {
    id?: true
    title?: true
    author?: true
    content?: true
    video?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostsCountAggregateInputType = {
    id?: true
    title?: true
    author?: true
    content?: true
    video?: true
    image?: true
    brandId?: true
    userLikesIds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which posts to aggregate.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned posts
    **/
    _count?: true | PostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsMaxAggregateInputType
  }

  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {
        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosts[P]>
      : GetScalarType<T[P], AggregatePosts[P]>
  }




  export type postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
    orderBy?: postsOrderByWithAggregationInput | postsOrderByWithAggregationInput[]
    by: PostsScalarFieldEnum[] | PostsScalarFieldEnum
    having?: postsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsCountAggregateInputType | true
    _min?: PostsMinAggregateInputType
    _max?: PostsMaxAggregateInputType
  }

  export type PostsGroupByOutputType = {
    id: string
    title: string
    author: string | null
    content: string | null
    video: string | null
    image: JsonValue | null
    brandId: string | null
    userLikesIds: string[]
    createdAt: Date
    updatedAt: Date
    _count: PostsCountAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  type GetPostsGroupByPayload<T extends postsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsGroupByOutputType[P]>
            : GetScalarType<T[P], PostsGroupByOutputType[P]>
        }
      >
    >


  export type postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    content?: boolean
    video?: boolean
    image?: boolean
    brandId?: boolean
    userLikesIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | posts$brandArgs<ExtArgs>
    userLikes?: boolean | posts$userLikesArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>


  export type postsSelectScalar = {
    id?: boolean
    title?: boolean
    author?: boolean
    content?: boolean
    video?: boolean
    image?: boolean
    brandId?: boolean
    userLikesIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | posts$brandArgs<ExtArgs>
    userLikes?: boolean | posts$userLikesArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "posts"
    objects: {
      brand: Prisma.$brandsPayload<ExtArgs> | null
      userLikes: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      author: string | null
      content: string | null
      video: string | null
      image: Prisma.JsonValue | null
      brandId: string | null
      userLikesIds: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["posts"]>
    composites: {}
  }

  type postsGetPayload<S extends boolean | null | undefined | postsDefaultArgs> = $Result.GetResult<Prisma.$postsPayload, S>

  type postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<postsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostsCountAggregateInputType | true
    }

  export interface postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['posts'], meta: { name: 'posts' } }
    /**
     * Find zero or one Posts that matches the filter.
     * @param {postsFindUniqueArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends postsFindUniqueArgs>(args: SelectSubset<T, postsFindUniqueArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Posts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {postsFindUniqueOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends postsFindUniqueOrThrowArgs>(args: SelectSubset<T, postsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindFirstArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends postsFindFirstArgs>(args?: SelectSubset<T, postsFindFirstArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindFirstOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends postsFindFirstOrThrowArgs>(args?: SelectSubset<T, postsFindFirstOrThrowArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.posts.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postsWithIdOnly = await prisma.posts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends postsFindManyArgs>(args?: SelectSubset<T, postsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Posts.
     * @param {postsCreateArgs} args - Arguments to create a Posts.
     * @example
     * // Create one Posts
     * const Posts = await prisma.posts.create({
     *   data: {
     *     // ... data to create a Posts
     *   }
     * })
     * 
     */
    create<T extends postsCreateArgs>(args: SelectSubset<T, postsCreateArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {postsCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends postsCreateManyArgs>(args?: SelectSubset<T, postsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Posts.
     * @param {postsDeleteArgs} args - Arguments to delete one Posts.
     * @example
     * // Delete one Posts
     * const Posts = await prisma.posts.delete({
     *   where: {
     *     // ... filter to delete one Posts
     *   }
     * })
     * 
     */
    delete<T extends postsDeleteArgs>(args: SelectSubset<T, postsDeleteArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Posts.
     * @param {postsUpdateArgs} args - Arguments to update one Posts.
     * @example
     * // Update one Posts
     * const posts = await prisma.posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends postsUpdateArgs>(args: SelectSubset<T, postsUpdateArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {postsDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends postsDeleteManyArgs>(args?: SelectSubset<T, postsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends postsUpdateManyArgs>(args: SelectSubset<T, postsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Posts.
     * @param {postsUpsertArgs} args - Arguments to update or create a Posts.
     * @example
     * // Update or create a Posts
     * const posts = await prisma.posts.upsert({
     *   create: {
     *     // ... data to create a Posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Posts we want to update
     *   }
     * })
     */
    upsert<T extends postsUpsertArgs>(args: SelectSubset<T, postsUpsertArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * @param {postsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const posts = await prisma.posts.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: postsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Posts.
     * @param {postsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const posts = await prisma.posts.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: postsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.posts.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends postsCountArgs>(
      args?: Subset<T, postsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): Prisma.PrismaPromise<GetPostsAggregateType<T>>

    /**
     * Group by Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends postsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: postsGroupByArgs['orderBy'] }
        : { orderBy?: postsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the posts model
   */
  readonly fields: postsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends posts$brandArgs<ExtArgs> = {}>(args?: Subset<T, posts$brandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    userLikes<T extends posts$userLikesArgs<ExtArgs> = {}>(args?: Subset<T, posts$userLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the posts model
   */ 
  interface postsFieldRefs {
    readonly id: FieldRef<"posts", 'String'>
    readonly title: FieldRef<"posts", 'String'>
    readonly author: FieldRef<"posts", 'String'>
    readonly content: FieldRef<"posts", 'String'>
    readonly video: FieldRef<"posts", 'String'>
    readonly image: FieldRef<"posts", 'Json'>
    readonly brandId: FieldRef<"posts", 'String'>
    readonly userLikesIds: FieldRef<"posts", 'String[]'>
    readonly createdAt: FieldRef<"posts", 'DateTime'>
    readonly updatedAt: FieldRef<"posts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * posts findUnique
   */
  export type postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where: postsWhereUniqueInput
  }

  /**
   * posts findUniqueOrThrow
   */
  export type postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where: postsWhereUniqueInput
  }

  /**
   * posts findFirst
   */
  export type postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * posts findFirstOrThrow
   */
  export type postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * posts findMany
   */
  export type postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * posts create
   */
  export type postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The data needed to create a posts.
     */
    data: XOR<postsCreateInput, postsUncheckedCreateInput>
  }

  /**
   * posts createMany
   */
  export type postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many posts.
     */
    data: postsCreateManyInput | postsCreateManyInput[]
  }

  /**
   * posts update
   */
  export type postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The data needed to update a posts.
     */
    data: XOR<postsUpdateInput, postsUncheckedUpdateInput>
    /**
     * Choose, which posts to update.
     */
    where: postsWhereUniqueInput
  }

  /**
   * posts updateMany
   */
  export type postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update posts.
     */
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyInput>
    /**
     * Filter which posts to update
     */
    where?: postsWhereInput
  }

  /**
   * posts upsert
   */
  export type postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The filter to search for the posts to update in case it exists.
     */
    where: postsWhereUniqueInput
    /**
     * In case the posts found by the `where` argument doesn't exist, create a new posts with this data.
     */
    create: XOR<postsCreateInput, postsUncheckedCreateInput>
    /**
     * In case the posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<postsUpdateInput, postsUncheckedUpdateInput>
  }

  /**
   * posts delete
   */
  export type postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter which posts to delete.
     */
    where: postsWhereUniqueInput
  }

  /**
   * posts deleteMany
   */
  export type postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which posts to delete
     */
    where?: postsWhereInput
  }

  /**
   * posts findRaw
   */
  export type postsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * posts aggregateRaw
   */
  export type postsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * posts.brand
   */
  export type posts$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * posts.userLikes
   */
  export type posts$userLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * posts without action
   */
  export type postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
  }


  /**
   * Model production_submissions
   */

  export type AggregateProduction_submissions = {
    _count: Production_submissionsCountAggregateOutputType | null
    _min: Production_submissionsMinAggregateOutputType | null
    _max: Production_submissionsMaxAggregateOutputType | null
  }

  export type Production_submissionsMinAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    brandId: string | null
    userId: string | null
  }

  export type Production_submissionsMaxAggregateOutputType = {
    id: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    brandId: string | null
    userId: string | null
  }

  export type Production_submissionsCountAggregateOutputType = {
    id: number
    overlays: number
    videos: number
    status: number
    createdAt: number
    updatedAt: number
    brandId: number
    userId: number
    _all: number
  }


  export type Production_submissionsMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    brandId?: true
    userId?: true
  }

  export type Production_submissionsMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    brandId?: true
    userId?: true
  }

  export type Production_submissionsCountAggregateInputType = {
    id?: true
    overlays?: true
    videos?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    brandId?: true
    userId?: true
    _all?: true
  }

  export type Production_submissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which production_submissions to aggregate.
     */
    where?: production_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_submissions to fetch.
     */
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: production_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned production_submissions
    **/
    _count?: true | Production_submissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Production_submissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Production_submissionsMaxAggregateInputType
  }

  export type GetProduction_submissionsAggregateType<T extends Production_submissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateProduction_submissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduction_submissions[P]>
      : GetScalarType<T[P], AggregateProduction_submissions[P]>
  }




  export type production_submissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: production_submissionsWhereInput
    orderBy?: production_submissionsOrderByWithAggregationInput | production_submissionsOrderByWithAggregationInput[]
    by: Production_submissionsScalarFieldEnum[] | Production_submissionsScalarFieldEnum
    having?: production_submissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Production_submissionsCountAggregateInputType | true
    _min?: Production_submissionsMinAggregateInputType
    _max?: Production_submissionsMaxAggregateInputType
  }

  export type Production_submissionsGroupByOutputType = {
    id: string
    overlays: JsonValue[]
    videos: JsonValue[]
    status: string
    createdAt: Date
    updatedAt: Date
    brandId: string
    userId: string
    _count: Production_submissionsCountAggregateOutputType | null
    _min: Production_submissionsMinAggregateOutputType | null
    _max: Production_submissionsMaxAggregateOutputType | null
  }

  type GetProduction_submissionsGroupByPayload<T extends production_submissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Production_submissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Production_submissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Production_submissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Production_submissionsGroupByOutputType[P]>
        }
      >
    >


  export type production_submissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    overlays?: boolean
    videos?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brandId?: boolean
    userId?: boolean
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["production_submissions"]>


  export type production_submissionsSelectScalar = {
    id?: boolean
    overlays?: boolean
    videos?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brandId?: boolean
    userId?: boolean
  }

  export type production_submissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $production_submissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "production_submissions"
    objects: {
      brand: Prisma.$brandsPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      overlays: Prisma.JsonValue[]
      videos: Prisma.JsonValue[]
      status: string
      createdAt: Date
      updatedAt: Date
      brandId: string
      userId: string
    }, ExtArgs["result"]["production_submissions"]>
    composites: {}
  }

  type production_submissionsGetPayload<S extends boolean | null | undefined | production_submissionsDefaultArgs> = $Result.GetResult<Prisma.$production_submissionsPayload, S>

  type production_submissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<production_submissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Production_submissionsCountAggregateInputType | true
    }

  export interface production_submissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['production_submissions'], meta: { name: 'production_submissions' } }
    /**
     * Find zero or one Production_submissions that matches the filter.
     * @param {production_submissionsFindUniqueArgs} args - Arguments to find a Production_submissions
     * @example
     * // Get one Production_submissions
     * const production_submissions = await prisma.production_submissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends production_submissionsFindUniqueArgs>(args: SelectSubset<T, production_submissionsFindUniqueArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Production_submissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {production_submissionsFindUniqueOrThrowArgs} args - Arguments to find a Production_submissions
     * @example
     * // Get one Production_submissions
     * const production_submissions = await prisma.production_submissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends production_submissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, production_submissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Production_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsFindFirstArgs} args - Arguments to find a Production_submissions
     * @example
     * // Get one Production_submissions
     * const production_submissions = await prisma.production_submissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends production_submissionsFindFirstArgs>(args?: SelectSubset<T, production_submissionsFindFirstArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Production_submissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsFindFirstOrThrowArgs} args - Arguments to find a Production_submissions
     * @example
     * // Get one Production_submissions
     * const production_submissions = await prisma.production_submissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends production_submissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, production_submissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Production_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Production_submissions
     * const production_submissions = await prisma.production_submissions.findMany()
     * 
     * // Get first 10 Production_submissions
     * const production_submissions = await prisma.production_submissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const production_submissionsWithIdOnly = await prisma.production_submissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends production_submissionsFindManyArgs>(args?: SelectSubset<T, production_submissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Production_submissions.
     * @param {production_submissionsCreateArgs} args - Arguments to create a Production_submissions.
     * @example
     * // Create one Production_submissions
     * const Production_submissions = await prisma.production_submissions.create({
     *   data: {
     *     // ... data to create a Production_submissions
     *   }
     * })
     * 
     */
    create<T extends production_submissionsCreateArgs>(args: SelectSubset<T, production_submissionsCreateArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Production_submissions.
     * @param {production_submissionsCreateManyArgs} args - Arguments to create many Production_submissions.
     * @example
     * // Create many Production_submissions
     * const production_submissions = await prisma.production_submissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends production_submissionsCreateManyArgs>(args?: SelectSubset<T, production_submissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Production_submissions.
     * @param {production_submissionsDeleteArgs} args - Arguments to delete one Production_submissions.
     * @example
     * // Delete one Production_submissions
     * const Production_submissions = await prisma.production_submissions.delete({
     *   where: {
     *     // ... filter to delete one Production_submissions
     *   }
     * })
     * 
     */
    delete<T extends production_submissionsDeleteArgs>(args: SelectSubset<T, production_submissionsDeleteArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Production_submissions.
     * @param {production_submissionsUpdateArgs} args - Arguments to update one Production_submissions.
     * @example
     * // Update one Production_submissions
     * const production_submissions = await prisma.production_submissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends production_submissionsUpdateArgs>(args: SelectSubset<T, production_submissionsUpdateArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Production_submissions.
     * @param {production_submissionsDeleteManyArgs} args - Arguments to filter Production_submissions to delete.
     * @example
     * // Delete a few Production_submissions
     * const { count } = await prisma.production_submissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends production_submissionsDeleteManyArgs>(args?: SelectSubset<T, production_submissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Production_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Production_submissions
     * const production_submissions = await prisma.production_submissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends production_submissionsUpdateManyArgs>(args: SelectSubset<T, production_submissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Production_submissions.
     * @param {production_submissionsUpsertArgs} args - Arguments to update or create a Production_submissions.
     * @example
     * // Update or create a Production_submissions
     * const production_submissions = await prisma.production_submissions.upsert({
     *   create: {
     *     // ... data to create a Production_submissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Production_submissions we want to update
     *   }
     * })
     */
    upsert<T extends production_submissionsUpsertArgs>(args: SelectSubset<T, production_submissionsUpsertArgs<ExtArgs>>): Prisma__production_submissionsClient<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Production_submissions that matches the filter.
     * @param {production_submissionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const production_submissions = await prisma.production_submissions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: production_submissionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Production_submissions.
     * @param {production_submissionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const production_submissions = await prisma.production_submissions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: production_submissionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Production_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsCountArgs} args - Arguments to filter Production_submissions to count.
     * @example
     * // Count the number of Production_submissions
     * const count = await prisma.production_submissions.count({
     *   where: {
     *     // ... the filter for the Production_submissions we want to count
     *   }
     * })
    **/
    count<T extends production_submissionsCountArgs>(
      args?: Subset<T, production_submissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Production_submissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Production_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Production_submissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Production_submissionsAggregateArgs>(args: Subset<T, Production_submissionsAggregateArgs>): Prisma.PrismaPromise<GetProduction_submissionsAggregateType<T>>

    /**
     * Group by Production_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {production_submissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends production_submissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: production_submissionsGroupByArgs['orderBy'] }
        : { orderBy?: production_submissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, production_submissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduction_submissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the production_submissions model
   */
  readonly fields: production_submissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for production_submissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__production_submissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the production_submissions model
   */ 
  interface production_submissionsFieldRefs {
    readonly id: FieldRef<"production_submissions", 'String'>
    readonly overlays: FieldRef<"production_submissions", 'Json[]'>
    readonly videos: FieldRef<"production_submissions", 'Json[]'>
    readonly status: FieldRef<"production_submissions", 'String'>
    readonly createdAt: FieldRef<"production_submissions", 'DateTime'>
    readonly updatedAt: FieldRef<"production_submissions", 'DateTime'>
    readonly brandId: FieldRef<"production_submissions", 'String'>
    readonly userId: FieldRef<"production_submissions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * production_submissions findUnique
   */
  export type production_submissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where: production_submissionsWhereUniqueInput
  }

  /**
   * production_submissions findUniqueOrThrow
   */
  export type production_submissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where: production_submissionsWhereUniqueInput
  }

  /**
   * production_submissions findFirst
   */
  export type production_submissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where?: production_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_submissions to fetch.
     */
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for production_submissions.
     */
    cursor?: production_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of production_submissions.
     */
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * production_submissions findFirstOrThrow
   */
  export type production_submissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where?: production_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_submissions to fetch.
     */
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for production_submissions.
     */
    cursor?: production_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of production_submissions.
     */
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * production_submissions findMany
   */
  export type production_submissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter, which production_submissions to fetch.
     */
    where?: production_submissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of production_submissions to fetch.
     */
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing production_submissions.
     */
    cursor?: production_submissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` production_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` production_submissions.
     */
    skip?: number
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * production_submissions create
   */
  export type production_submissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a production_submissions.
     */
    data: XOR<production_submissionsCreateInput, production_submissionsUncheckedCreateInput>
  }

  /**
   * production_submissions createMany
   */
  export type production_submissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many production_submissions.
     */
    data: production_submissionsCreateManyInput | production_submissionsCreateManyInput[]
  }

  /**
   * production_submissions update
   */
  export type production_submissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a production_submissions.
     */
    data: XOR<production_submissionsUpdateInput, production_submissionsUncheckedUpdateInput>
    /**
     * Choose, which production_submissions to update.
     */
    where: production_submissionsWhereUniqueInput
  }

  /**
   * production_submissions updateMany
   */
  export type production_submissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update production_submissions.
     */
    data: XOR<production_submissionsUpdateManyMutationInput, production_submissionsUncheckedUpdateManyInput>
    /**
     * Filter which production_submissions to update
     */
    where?: production_submissionsWhereInput
  }

  /**
   * production_submissions upsert
   */
  export type production_submissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the production_submissions to update in case it exists.
     */
    where: production_submissionsWhereUniqueInput
    /**
     * In case the production_submissions found by the `where` argument doesn't exist, create a new production_submissions with this data.
     */
    create: XOR<production_submissionsCreateInput, production_submissionsUncheckedCreateInput>
    /**
     * In case the production_submissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<production_submissionsUpdateInput, production_submissionsUncheckedUpdateInput>
  }

  /**
   * production_submissions delete
   */
  export type production_submissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    /**
     * Filter which production_submissions to delete.
     */
    where: production_submissionsWhereUniqueInput
  }

  /**
   * production_submissions deleteMany
   */
  export type production_submissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which production_submissions to delete
     */
    where?: production_submissionsWhereInput
  }

  /**
   * production_submissions findRaw
   */
  export type production_submissionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * production_submissions aggregateRaw
   */
  export type production_submissionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * production_submissions without action
   */
  export type production_submissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsMinAggregateOutputType = {
    id: string | null
    regularPrice: string | null
    deal: string | null
    dealPrice: string | null
    purchaseUrl: string | null
    brandId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uniqueDeal: boolean | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: string | null
    regularPrice: string | null
    deal: string | null
    dealPrice: string | null
    purchaseUrl: string | null
    brandId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    uniqueDeal: boolean | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    description: number
    images: number
    regularPrice: number
    deal: number
    dealPrice: number
    purchaseUrl: number
    brandId: number
    name: number
    createdAt: number
    updatedAt: number
    uniqueDeal: number
    _all: number
  }


  export type ProductsMinAggregateInputType = {
    id?: true
    regularPrice?: true
    deal?: true
    dealPrice?: true
    purchaseUrl?: true
    brandId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    uniqueDeal?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    regularPrice?: true
    deal?: true
    dealPrice?: true
    purchaseUrl?: true
    brandId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    uniqueDeal?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    description?: true
    images?: true
    regularPrice?: true
    deal?: true
    dealPrice?: true
    purchaseUrl?: true
    brandId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    uniqueDeal?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: string
    description: JsonValue | null
    images: JsonValue[]
    regularPrice: string | null
    deal: string | null
    dealPrice: string | null
    purchaseUrl: string | null
    brandId: string
    name: string
    createdAt: Date
    updatedAt: Date
    uniqueDeal: boolean | null
    _count: ProductsCountAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    images?: boolean
    regularPrice?: boolean
    deal?: boolean
    dealPrice?: boolean
    purchaseUrl?: boolean
    brandId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueDeal?: boolean
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    linkVisits?: boolean | products$linkVisitsArgs<ExtArgs>
    ratings?: boolean | products$ratingsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>


  export type productsSelectScalar = {
    id?: boolean
    description?: boolean
    images?: boolean
    regularPrice?: boolean
    deal?: boolean
    dealPrice?: boolean
    purchaseUrl?: boolean
    brandId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueDeal?: boolean
  }

  export type productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    linkVisits?: boolean | products$linkVisitsArgs<ExtArgs>
    ratings?: boolean | products$ratingsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {
      brand: Prisma.$brandsPayload<ExtArgs>
      linkVisits: Prisma.$link_visitsPayload<ExtArgs>[]
      ratings: Prisma.$ratingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: Prisma.JsonValue | null
      images: Prisma.JsonValue[]
      regularPrice: string | null
      deal: string | null
      dealPrice: string | null
      purchaseUrl: string | null
      brandId: string
      name: string
      createdAt: Date
      updatedAt: Date
      uniqueDeal: boolean | null
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * @param {productsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const products = await prisma.products.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: productsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Products.
     * @param {productsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const products = await prisma.products.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: productsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    linkVisits<T extends products$linkVisitsArgs<ExtArgs> = {}>(args?: Subset<T, products$linkVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends products$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, products$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */ 
  interface productsFieldRefs {
    readonly id: FieldRef<"products", 'String'>
    readonly description: FieldRef<"products", 'Json'>
    readonly images: FieldRef<"products", 'Json[]'>
    readonly regularPrice: FieldRef<"products", 'String'>
    readonly deal: FieldRef<"products", 'String'>
    readonly dealPrice: FieldRef<"products", 'String'>
    readonly purchaseUrl: FieldRef<"products", 'String'>
    readonly brandId: FieldRef<"products", 'String'>
    readonly name: FieldRef<"products", 'String'>
    readonly createdAt: FieldRef<"products", 'DateTime'>
    readonly updatedAt: FieldRef<"products", 'DateTime'>
    readonly uniqueDeal: FieldRef<"products", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
  }

  /**
   * products findRaw
   */
  export type productsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * products aggregateRaw
   */
  export type productsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * products.linkVisits
   */
  export type products$linkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    where?: link_visitsWhereInput
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    cursor?: link_visitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * products.ratings
   */
  export type products$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    where?: ratingsWhereInput
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    cursor?: ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
  }


  /**
   * Model push_notifications
   */

  export type AggregatePush_notifications = {
    _count: Push_notificationsCountAggregateOutputType | null
    _avg: Push_notificationsAvgAggregateOutputType | null
    _sum: Push_notificationsSumAggregateOutputType | null
    _min: Push_notificationsMinAggregateOutputType | null
    _max: Push_notificationsMaxAggregateOutputType | null
  }

  export type Push_notificationsAvgAggregateOutputType = {
    minDaysInactive: number | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
  }

  export type Push_notificationsSumAggregateOutputType = {
    minDaysInactive: number | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
  }

  export type Push_notificationsMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationType | null
    minDaysInactive: number | null
    oneTimeOnly: boolean | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
  }

  export type Push_notificationsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationType | null
    minDaysInactive: number | null
    oneTimeOnly: boolean | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
  }

  export type Push_notificationsCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    minDaysInactive: number
    oneTimeOnly: number
    sendAfterInactiveDays: number
    repeatAfterDays: number
    daysAfterActivation: number
    daysBeforeExpiry: number
    _all: number
  }


  export type Push_notificationsAvgAggregateInputType = {
    minDaysInactive?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
  }

  export type Push_notificationsSumAggregateInputType = {
    minDaysInactive?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
  }

  export type Push_notificationsMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    minDaysInactive?: true
    oneTimeOnly?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
  }

  export type Push_notificationsMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    minDaysInactive?: true
    oneTimeOnly?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
  }

  export type Push_notificationsCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    minDaysInactive?: true
    oneTimeOnly?: true
    sendAfterInactiveDays?: true
    repeatAfterDays?: true
    daysAfterActivation?: true
    daysBeforeExpiry?: true
    _all?: true
  }

  export type Push_notificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notifications to aggregate.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned push_notifications
    **/
    _count?: true | Push_notificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Push_notificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Push_notificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Push_notificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Push_notificationsMaxAggregateInputType
  }

  export type GetPush_notificationsAggregateType<T extends Push_notificationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePush_notifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePush_notifications[P]>
      : GetScalarType<T[P], AggregatePush_notifications[P]>
  }




  export type push_notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: push_notificationsWhereInput
    orderBy?: push_notificationsOrderByWithAggregationInput | push_notificationsOrderByWithAggregationInput[]
    by: Push_notificationsScalarFieldEnum[] | Push_notificationsScalarFieldEnum
    having?: push_notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Push_notificationsCountAggregateInputType | true
    _avg?: Push_notificationsAvgAggregateInputType
    _sum?: Push_notificationsSumAggregateInputType
    _min?: Push_notificationsMinAggregateInputType
    _max?: Push_notificationsMaxAggregateInputType
  }

  export type Push_notificationsGroupByOutputType = {
    id: string
    title: string | null
    content: string
    type: $Enums.NotificationType | null
    minDaysInactive: number | null
    oneTimeOnly: boolean | null
    sendAfterInactiveDays: number | null
    repeatAfterDays: number | null
    daysAfterActivation: number | null
    daysBeforeExpiry: number | null
    _count: Push_notificationsCountAggregateOutputType | null
    _avg: Push_notificationsAvgAggregateOutputType | null
    _sum: Push_notificationsSumAggregateOutputType | null
    _min: Push_notificationsMinAggregateOutputType | null
    _max: Push_notificationsMaxAggregateOutputType | null
  }

  type GetPush_notificationsGroupByPayload<T extends push_notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Push_notificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Push_notificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Push_notificationsGroupByOutputType[P]>
            : GetScalarType<T[P], Push_notificationsGroupByOutputType[P]>
        }
      >
    >


  export type push_notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    minDaysInactive?: boolean
    oneTimeOnly?: boolean
    sendAfterInactiveDays?: boolean
    repeatAfterDays?: boolean
    daysAfterActivation?: boolean
    daysBeforeExpiry?: boolean
  }, ExtArgs["result"]["push_notifications"]>


  export type push_notificationsSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    minDaysInactive?: boolean
    oneTimeOnly?: boolean
    sendAfterInactiveDays?: boolean
    repeatAfterDays?: boolean
    daysAfterActivation?: boolean
    daysBeforeExpiry?: boolean
  }


  export type $push_notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "push_notifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      content: string
      type: $Enums.NotificationType | null
      minDaysInactive: number | null
      oneTimeOnly: boolean | null
      sendAfterInactiveDays: number | null
      repeatAfterDays: number | null
      daysAfterActivation: number | null
      daysBeforeExpiry: number | null
    }, ExtArgs["result"]["push_notifications"]>
    composites: {}
  }

  type push_notificationsGetPayload<S extends boolean | null | undefined | push_notificationsDefaultArgs> = $Result.GetResult<Prisma.$push_notificationsPayload, S>

  type push_notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<push_notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Push_notificationsCountAggregateInputType | true
    }

  export interface push_notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['push_notifications'], meta: { name: 'push_notifications' } }
    /**
     * Find zero or one Push_notifications that matches the filter.
     * @param {push_notificationsFindUniqueArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends push_notificationsFindUniqueArgs>(args: SelectSubset<T, push_notificationsFindUniqueArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Push_notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {push_notificationsFindUniqueOrThrowArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends push_notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, push_notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Push_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindFirstArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends push_notificationsFindFirstArgs>(args?: SelectSubset<T, push_notificationsFindFirstArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Push_notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindFirstOrThrowArgs} args - Arguments to find a Push_notifications
     * @example
     * // Get one Push_notifications
     * const push_notifications = await prisma.push_notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends push_notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, push_notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Push_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Push_notifications
     * const push_notifications = await prisma.push_notifications.findMany()
     * 
     * // Get first 10 Push_notifications
     * const push_notifications = await prisma.push_notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const push_notificationsWithIdOnly = await prisma.push_notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends push_notificationsFindManyArgs>(args?: SelectSubset<T, push_notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Push_notifications.
     * @param {push_notificationsCreateArgs} args - Arguments to create a Push_notifications.
     * @example
     * // Create one Push_notifications
     * const Push_notifications = await prisma.push_notifications.create({
     *   data: {
     *     // ... data to create a Push_notifications
     *   }
     * })
     * 
     */
    create<T extends push_notificationsCreateArgs>(args: SelectSubset<T, push_notificationsCreateArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Push_notifications.
     * @param {push_notificationsCreateManyArgs} args - Arguments to create many Push_notifications.
     * @example
     * // Create many Push_notifications
     * const push_notifications = await prisma.push_notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends push_notificationsCreateManyArgs>(args?: SelectSubset<T, push_notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Push_notifications.
     * @param {push_notificationsDeleteArgs} args - Arguments to delete one Push_notifications.
     * @example
     * // Delete one Push_notifications
     * const Push_notifications = await prisma.push_notifications.delete({
     *   where: {
     *     // ... filter to delete one Push_notifications
     *   }
     * })
     * 
     */
    delete<T extends push_notificationsDeleteArgs>(args: SelectSubset<T, push_notificationsDeleteArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Push_notifications.
     * @param {push_notificationsUpdateArgs} args - Arguments to update one Push_notifications.
     * @example
     * // Update one Push_notifications
     * const push_notifications = await prisma.push_notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends push_notificationsUpdateArgs>(args: SelectSubset<T, push_notificationsUpdateArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Push_notifications.
     * @param {push_notificationsDeleteManyArgs} args - Arguments to filter Push_notifications to delete.
     * @example
     * // Delete a few Push_notifications
     * const { count } = await prisma.push_notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends push_notificationsDeleteManyArgs>(args?: SelectSubset<T, push_notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Push_notifications
     * const push_notifications = await prisma.push_notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends push_notificationsUpdateManyArgs>(args: SelectSubset<T, push_notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Push_notifications.
     * @param {push_notificationsUpsertArgs} args - Arguments to update or create a Push_notifications.
     * @example
     * // Update or create a Push_notifications
     * const push_notifications = await prisma.push_notifications.upsert({
     *   create: {
     *     // ... data to create a Push_notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Push_notifications we want to update
     *   }
     * })
     */
    upsert<T extends push_notificationsUpsertArgs>(args: SelectSubset<T, push_notificationsUpsertArgs<ExtArgs>>): Prisma__push_notificationsClient<$Result.GetResult<Prisma.$push_notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Push_notifications that matches the filter.
     * @param {push_notificationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const push_notifications = await prisma.push_notifications.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: push_notificationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Push_notifications.
     * @param {push_notificationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const push_notifications = await prisma.push_notifications.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: push_notificationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsCountArgs} args - Arguments to filter Push_notifications to count.
     * @example
     * // Count the number of Push_notifications
     * const count = await prisma.push_notifications.count({
     *   where: {
     *     // ... the filter for the Push_notifications we want to count
     *   }
     * })
    **/
    count<T extends push_notificationsCountArgs>(
      args?: Subset<T, push_notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Push_notificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Push_notificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Push_notificationsAggregateArgs>(args: Subset<T, Push_notificationsAggregateArgs>): Prisma.PrismaPromise<GetPush_notificationsAggregateType<T>>

    /**
     * Group by Push_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends push_notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: push_notificationsGroupByArgs['orderBy'] }
        : { orderBy?: push_notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, push_notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPush_notificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the push_notifications model
   */
  readonly fields: push_notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for push_notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__push_notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the push_notifications model
   */ 
  interface push_notificationsFieldRefs {
    readonly id: FieldRef<"push_notifications", 'String'>
    readonly title: FieldRef<"push_notifications", 'String'>
    readonly content: FieldRef<"push_notifications", 'String'>
    readonly type: FieldRef<"push_notifications", 'NotificationType'>
    readonly minDaysInactive: FieldRef<"push_notifications", 'Int'>
    readonly oneTimeOnly: FieldRef<"push_notifications", 'Boolean'>
    readonly sendAfterInactiveDays: FieldRef<"push_notifications", 'Int'>
    readonly repeatAfterDays: FieldRef<"push_notifications", 'Int'>
    readonly daysAfterActivation: FieldRef<"push_notifications", 'Int'>
    readonly daysBeforeExpiry: FieldRef<"push_notifications", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * push_notifications findUnique
   */
  export type push_notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where: push_notificationsWhereUniqueInput
  }

  /**
   * push_notifications findUniqueOrThrow
   */
  export type push_notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where: push_notificationsWhereUniqueInput
  }

  /**
   * push_notifications findFirst
   */
  export type push_notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notifications.
     */
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }

  /**
   * push_notifications findFirstOrThrow
   */
  export type push_notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notifications.
     */
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }

  /**
   * push_notifications findMany
   */
  export type push_notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter, which push_notifications to fetch.
     */
    where?: push_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notifications to fetch.
     */
    orderBy?: push_notificationsOrderByWithRelationInput | push_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing push_notifications.
     */
    cursor?: push_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notifications.
     */
    skip?: number
    distinct?: Push_notificationsScalarFieldEnum | Push_notificationsScalarFieldEnum[]
  }

  /**
   * push_notifications create
   */
  export type push_notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * The data needed to create a push_notifications.
     */
    data: XOR<push_notificationsCreateInput, push_notificationsUncheckedCreateInput>
  }

  /**
   * push_notifications createMany
   */
  export type push_notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many push_notifications.
     */
    data: push_notificationsCreateManyInput | push_notificationsCreateManyInput[]
  }

  /**
   * push_notifications update
   */
  export type push_notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * The data needed to update a push_notifications.
     */
    data: XOR<push_notificationsUpdateInput, push_notificationsUncheckedUpdateInput>
    /**
     * Choose, which push_notifications to update.
     */
    where: push_notificationsWhereUniqueInput
  }

  /**
   * push_notifications updateMany
   */
  export type push_notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update push_notifications.
     */
    data: XOR<push_notificationsUpdateManyMutationInput, push_notificationsUncheckedUpdateManyInput>
    /**
     * Filter which push_notifications to update
     */
    where?: push_notificationsWhereInput
  }

  /**
   * push_notifications upsert
   */
  export type push_notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * The filter to search for the push_notifications to update in case it exists.
     */
    where: push_notificationsWhereUniqueInput
    /**
     * In case the push_notifications found by the `where` argument doesn't exist, create a new push_notifications with this data.
     */
    create: XOR<push_notificationsCreateInput, push_notificationsUncheckedCreateInput>
    /**
     * In case the push_notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<push_notificationsUpdateInput, push_notificationsUncheckedUpdateInput>
  }

  /**
   * push_notifications delete
   */
  export type push_notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
    /**
     * Filter which push_notifications to delete.
     */
    where: push_notificationsWhereUniqueInput
  }

  /**
   * push_notifications deleteMany
   */
  export type push_notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notifications to delete
     */
    where?: push_notificationsWhereInput
  }

  /**
   * push_notifications findRaw
   */
  export type push_notificationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * push_notifications aggregateRaw
   */
  export type push_notificationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * push_notifications without action
   */
  export type push_notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notifications
     */
    select?: push_notificationsSelect<ExtArgs> | null
  }


  /**
   * Model push_notification_history
   */

  export type AggregatePush_notification_history = {
    _count: Push_notification_historyCountAggregateOutputType | null
    _min: Push_notification_historyMinAggregateOutputType | null
    _max: Push_notification_historyMaxAggregateOutputType | null
  }

  export type Push_notification_historyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    entityId: string | null
    content: string | null
    title: string | null
    sentAt: Date | null
  }

  export type Push_notification_historyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    entityId: string | null
    content: string | null
    title: string | null
    sentAt: Date | null
  }

  export type Push_notification_historyCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    entityId: number
    content: number
    title: number
    sentAt: number
    _all: number
  }


  export type Push_notification_historyMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityId?: true
    content?: true
    title?: true
    sentAt?: true
  }

  export type Push_notification_historyMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityId?: true
    content?: true
    title?: true
    sentAt?: true
  }

  export type Push_notification_historyCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    entityId?: true
    content?: true
    title?: true
    sentAt?: true
    _all?: true
  }

  export type Push_notification_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notification_history to aggregate.
     */
    where?: push_notification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notification_histories to fetch.
     */
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: push_notification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned push_notification_histories
    **/
    _count?: true | Push_notification_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Push_notification_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Push_notification_historyMaxAggregateInputType
  }

  export type GetPush_notification_historyAggregateType<T extends Push_notification_historyAggregateArgs> = {
        [P in keyof T & keyof AggregatePush_notification_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePush_notification_history[P]>
      : GetScalarType<T[P], AggregatePush_notification_history[P]>
  }




  export type push_notification_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: push_notification_historyWhereInput
    orderBy?: push_notification_historyOrderByWithAggregationInput | push_notification_historyOrderByWithAggregationInput[]
    by: Push_notification_historyScalarFieldEnum[] | Push_notification_historyScalarFieldEnum
    having?: push_notification_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Push_notification_historyCountAggregateInputType | true
    _min?: Push_notification_historyMinAggregateInputType
    _max?: Push_notification_historyMaxAggregateInputType
  }

  export type Push_notification_historyGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType | null
    entityId: string | null
    content: string
    title: string
    sentAt: Date
    _count: Push_notification_historyCountAggregateOutputType | null
    _min: Push_notification_historyMinAggregateOutputType | null
    _max: Push_notification_historyMaxAggregateOutputType | null
  }

  type GetPush_notification_historyGroupByPayload<T extends push_notification_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Push_notification_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Push_notification_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Push_notification_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Push_notification_historyGroupByOutputType[P]>
        }
      >
    >


  export type push_notification_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    entityId?: boolean
    content?: boolean
    title?: boolean
    sentAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["push_notification_history"]>


  export type push_notification_historySelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    entityId?: boolean
    content?: boolean
    title?: boolean
    sentAt?: boolean
  }

  export type push_notification_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $push_notification_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "push_notification_history"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType | null
      entityId: string | null
      content: string
      title: string
      sentAt: Date
    }, ExtArgs["result"]["push_notification_history"]>
    composites: {}
  }

  type push_notification_historyGetPayload<S extends boolean | null | undefined | push_notification_historyDefaultArgs> = $Result.GetResult<Prisma.$push_notification_historyPayload, S>

  type push_notification_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<push_notification_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Push_notification_historyCountAggregateInputType | true
    }

  export interface push_notification_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['push_notification_history'], meta: { name: 'push_notification_history' } }
    /**
     * Find zero or one Push_notification_history that matches the filter.
     * @param {push_notification_historyFindUniqueArgs} args - Arguments to find a Push_notification_history
     * @example
     * // Get one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends push_notification_historyFindUniqueArgs>(args: SelectSubset<T, push_notification_historyFindUniqueArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Push_notification_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {push_notification_historyFindUniqueOrThrowArgs} args - Arguments to find a Push_notification_history
     * @example
     * // Get one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends push_notification_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, push_notification_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Push_notification_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyFindFirstArgs} args - Arguments to find a Push_notification_history
     * @example
     * // Get one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends push_notification_historyFindFirstArgs>(args?: SelectSubset<T, push_notification_historyFindFirstArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Push_notification_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyFindFirstOrThrowArgs} args - Arguments to find a Push_notification_history
     * @example
     * // Get one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends push_notification_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, push_notification_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Push_notification_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Push_notification_histories
     * const push_notification_histories = await prisma.push_notification_history.findMany()
     * 
     * // Get first 10 Push_notification_histories
     * const push_notification_histories = await prisma.push_notification_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const push_notification_historyWithIdOnly = await prisma.push_notification_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends push_notification_historyFindManyArgs>(args?: SelectSubset<T, push_notification_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Push_notification_history.
     * @param {push_notification_historyCreateArgs} args - Arguments to create a Push_notification_history.
     * @example
     * // Create one Push_notification_history
     * const Push_notification_history = await prisma.push_notification_history.create({
     *   data: {
     *     // ... data to create a Push_notification_history
     *   }
     * })
     * 
     */
    create<T extends push_notification_historyCreateArgs>(args: SelectSubset<T, push_notification_historyCreateArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Push_notification_histories.
     * @param {push_notification_historyCreateManyArgs} args - Arguments to create many Push_notification_histories.
     * @example
     * // Create many Push_notification_histories
     * const push_notification_history = await prisma.push_notification_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends push_notification_historyCreateManyArgs>(args?: SelectSubset<T, push_notification_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Push_notification_history.
     * @param {push_notification_historyDeleteArgs} args - Arguments to delete one Push_notification_history.
     * @example
     * // Delete one Push_notification_history
     * const Push_notification_history = await prisma.push_notification_history.delete({
     *   where: {
     *     // ... filter to delete one Push_notification_history
     *   }
     * })
     * 
     */
    delete<T extends push_notification_historyDeleteArgs>(args: SelectSubset<T, push_notification_historyDeleteArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Push_notification_history.
     * @param {push_notification_historyUpdateArgs} args - Arguments to update one Push_notification_history.
     * @example
     * // Update one Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends push_notification_historyUpdateArgs>(args: SelectSubset<T, push_notification_historyUpdateArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Push_notification_histories.
     * @param {push_notification_historyDeleteManyArgs} args - Arguments to filter Push_notification_histories to delete.
     * @example
     * // Delete a few Push_notification_histories
     * const { count } = await prisma.push_notification_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends push_notification_historyDeleteManyArgs>(args?: SelectSubset<T, push_notification_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Push_notification_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Push_notification_histories
     * const push_notification_history = await prisma.push_notification_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends push_notification_historyUpdateManyArgs>(args: SelectSubset<T, push_notification_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Push_notification_history.
     * @param {push_notification_historyUpsertArgs} args - Arguments to update or create a Push_notification_history.
     * @example
     * // Update or create a Push_notification_history
     * const push_notification_history = await prisma.push_notification_history.upsert({
     *   create: {
     *     // ... data to create a Push_notification_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Push_notification_history we want to update
     *   }
     * })
     */
    upsert<T extends push_notification_historyUpsertArgs>(args: SelectSubset<T, push_notification_historyUpsertArgs<ExtArgs>>): Prisma__push_notification_historyClient<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Push_notification_histories that matches the filter.
     * @param {push_notification_historyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const push_notification_history = await prisma.push_notification_history.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: push_notification_historyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Push_notification_history.
     * @param {push_notification_historyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const push_notification_history = await prisma.push_notification_history.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: push_notification_historyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Push_notification_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyCountArgs} args - Arguments to filter Push_notification_histories to count.
     * @example
     * // Count the number of Push_notification_histories
     * const count = await prisma.push_notification_history.count({
     *   where: {
     *     // ... the filter for the Push_notification_histories we want to count
     *   }
     * })
    **/
    count<T extends push_notification_historyCountArgs>(
      args?: Subset<T, push_notification_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Push_notification_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Push_notification_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Push_notification_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Push_notification_historyAggregateArgs>(args: Subset<T, Push_notification_historyAggregateArgs>): Prisma.PrismaPromise<GetPush_notification_historyAggregateType<T>>

    /**
     * Group by Push_notification_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {push_notification_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends push_notification_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: push_notification_historyGroupByArgs['orderBy'] }
        : { orderBy?: push_notification_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, push_notification_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPush_notification_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the push_notification_history model
   */
  readonly fields: push_notification_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for push_notification_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__push_notification_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the push_notification_history model
   */ 
  interface push_notification_historyFieldRefs {
    readonly id: FieldRef<"push_notification_history", 'String'>
    readonly userId: FieldRef<"push_notification_history", 'String'>
    readonly type: FieldRef<"push_notification_history", 'NotificationType'>
    readonly entityId: FieldRef<"push_notification_history", 'String'>
    readonly content: FieldRef<"push_notification_history", 'String'>
    readonly title: FieldRef<"push_notification_history", 'String'>
    readonly sentAt: FieldRef<"push_notification_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * push_notification_history findUnique
   */
  export type push_notification_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_history to fetch.
     */
    where: push_notification_historyWhereUniqueInput
  }

  /**
   * push_notification_history findUniqueOrThrow
   */
  export type push_notification_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_history to fetch.
     */
    where: push_notification_historyWhereUniqueInput
  }

  /**
   * push_notification_history findFirst
   */
  export type push_notification_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_history to fetch.
     */
    where?: push_notification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notification_histories to fetch.
     */
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notification_histories.
     */
    cursor?: push_notification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notification_histories.
     */
    distinct?: Push_notification_historyScalarFieldEnum | Push_notification_historyScalarFieldEnum[]
  }

  /**
   * push_notification_history findFirstOrThrow
   */
  export type push_notification_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_history to fetch.
     */
    where?: push_notification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notification_histories to fetch.
     */
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for push_notification_histories.
     */
    cursor?: push_notification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of push_notification_histories.
     */
    distinct?: Push_notification_historyScalarFieldEnum | Push_notification_historyScalarFieldEnum[]
  }

  /**
   * push_notification_history findMany
   */
  export type push_notification_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter, which push_notification_histories to fetch.
     */
    where?: push_notification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of push_notification_histories to fetch.
     */
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing push_notification_histories.
     */
    cursor?: push_notification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` push_notification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` push_notification_histories.
     */
    skip?: number
    distinct?: Push_notification_historyScalarFieldEnum | Push_notification_historyScalarFieldEnum[]
  }

  /**
   * push_notification_history create
   */
  export type push_notification_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a push_notification_history.
     */
    data: XOR<push_notification_historyCreateInput, push_notification_historyUncheckedCreateInput>
  }

  /**
   * push_notification_history createMany
   */
  export type push_notification_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many push_notification_histories.
     */
    data: push_notification_historyCreateManyInput | push_notification_historyCreateManyInput[]
  }

  /**
   * push_notification_history update
   */
  export type push_notification_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a push_notification_history.
     */
    data: XOR<push_notification_historyUpdateInput, push_notification_historyUncheckedUpdateInput>
    /**
     * Choose, which push_notification_history to update.
     */
    where: push_notification_historyWhereUniqueInput
  }

  /**
   * push_notification_history updateMany
   */
  export type push_notification_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update push_notification_histories.
     */
    data: XOR<push_notification_historyUpdateManyMutationInput, push_notification_historyUncheckedUpdateManyInput>
    /**
     * Filter which push_notification_histories to update
     */
    where?: push_notification_historyWhereInput
  }

  /**
   * push_notification_history upsert
   */
  export type push_notification_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the push_notification_history to update in case it exists.
     */
    where: push_notification_historyWhereUniqueInput
    /**
     * In case the push_notification_history found by the `where` argument doesn't exist, create a new push_notification_history with this data.
     */
    create: XOR<push_notification_historyCreateInput, push_notification_historyUncheckedCreateInput>
    /**
     * In case the push_notification_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<push_notification_historyUpdateInput, push_notification_historyUncheckedUpdateInput>
  }

  /**
   * push_notification_history delete
   */
  export type push_notification_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    /**
     * Filter which push_notification_history to delete.
     */
    where: push_notification_historyWhereUniqueInput
  }

  /**
   * push_notification_history deleteMany
   */
  export type push_notification_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which push_notification_histories to delete
     */
    where?: push_notification_historyWhereInput
  }

  /**
   * push_notification_history findRaw
   */
  export type push_notification_historyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * push_notification_history aggregateRaw
   */
  export type push_notification_historyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * push_notification_history without action
   */
  export type push_notification_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
  }


  /**
   * Model questionnaires
   */

  export type AggregateQuestionnaires = {
    _count: QuestionnairesCountAggregateOutputType | null
    _min: QuestionnairesMinAggregateOutputType | null
    _max: QuestionnairesMaxAggregateOutputType | null
  }

  export type QuestionnairesMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnairesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnairesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionnairesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnairesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnairesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionnairesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionnaires to aggregate.
     */
    where?: questionnairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionnaires to fetch.
     */
    orderBy?: questionnairesOrderByWithRelationInput | questionnairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionnairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questionnaires
    **/
    _count?: true | QuestionnairesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionnairesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionnairesMaxAggregateInputType
  }

  export type GetQuestionnairesAggregateType<T extends QuestionnairesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionnaires]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionnaires[P]>
      : GetScalarType<T[P], AggregateQuestionnaires[P]>
  }




  export type questionnairesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionnairesWhereInput
    orderBy?: questionnairesOrderByWithAggregationInput | questionnairesOrderByWithAggregationInput[]
    by: QuestionnairesScalarFieldEnum[] | QuestionnairesScalarFieldEnum
    having?: questionnairesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionnairesCountAggregateInputType | true
    _min?: QuestionnairesMinAggregateInputType
    _max?: QuestionnairesMaxAggregateInputType
  }

  export type QuestionnairesGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionnairesCountAggregateOutputType | null
    _min: QuestionnairesMinAggregateOutputType | null
    _max: QuestionnairesMaxAggregateOutputType | null
  }

  type GetQuestionnairesGroupByPayload<T extends questionnairesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionnairesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionnairesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionnairesGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionnairesGroupByOutputType[P]>
        }
      >
    >


  export type questionnairesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | questionnaires$questionsArgs<ExtArgs>
    level?: boolean | questionnaires$levelArgs<ExtArgs>
    _count?: boolean | QuestionnairesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaires"]>


  export type questionnairesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type questionnairesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | questionnaires$questionsArgs<ExtArgs>
    level?: boolean | questionnaires$levelArgs<ExtArgs>
    _count?: boolean | QuestionnairesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $questionnairesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questionnaires"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
      level: Prisma.$levelsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionnaires"]>
    composites: {}
  }

  type questionnairesGetPayload<S extends boolean | null | undefined | questionnairesDefaultArgs> = $Result.GetResult<Prisma.$questionnairesPayload, S>

  type questionnairesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questionnairesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionnairesCountAggregateInputType | true
    }

  export interface questionnairesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questionnaires'], meta: { name: 'questionnaires' } }
    /**
     * Find zero or one Questionnaires that matches the filter.
     * @param {questionnairesFindUniqueArgs} args - Arguments to find a Questionnaires
     * @example
     * // Get one Questionnaires
     * const questionnaires = await prisma.questionnaires.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionnairesFindUniqueArgs>(args: SelectSubset<T, questionnairesFindUniqueArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questionnaires that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questionnairesFindUniqueOrThrowArgs} args - Arguments to find a Questionnaires
     * @example
     * // Get one Questionnaires
     * const questionnaires = await prisma.questionnaires.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionnairesFindUniqueOrThrowArgs>(args: SelectSubset<T, questionnairesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questionnaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesFindFirstArgs} args - Arguments to find a Questionnaires
     * @example
     * // Get one Questionnaires
     * const questionnaires = await prisma.questionnaires.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionnairesFindFirstArgs>(args?: SelectSubset<T, questionnairesFindFirstArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questionnaires that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesFindFirstOrThrowArgs} args - Arguments to find a Questionnaires
     * @example
     * // Get one Questionnaires
     * const questionnaires = await prisma.questionnaires.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionnairesFindFirstOrThrowArgs>(args?: SelectSubset<T, questionnairesFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questionnaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questionnaires
     * const questionnaires = await prisma.questionnaires.findMany()
     * 
     * // Get first 10 Questionnaires
     * const questionnaires = await prisma.questionnaires.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionnairesWithIdOnly = await prisma.questionnaires.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionnairesFindManyArgs>(args?: SelectSubset<T, questionnairesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questionnaires.
     * @param {questionnairesCreateArgs} args - Arguments to create a Questionnaires.
     * @example
     * // Create one Questionnaires
     * const Questionnaires = await prisma.questionnaires.create({
     *   data: {
     *     // ... data to create a Questionnaires
     *   }
     * })
     * 
     */
    create<T extends questionnairesCreateArgs>(args: SelectSubset<T, questionnairesCreateArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questionnaires.
     * @param {questionnairesCreateManyArgs} args - Arguments to create many Questionnaires.
     * @example
     * // Create many Questionnaires
     * const questionnaires = await prisma.questionnaires.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionnairesCreateManyArgs>(args?: SelectSubset<T, questionnairesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questionnaires.
     * @param {questionnairesDeleteArgs} args - Arguments to delete one Questionnaires.
     * @example
     * // Delete one Questionnaires
     * const Questionnaires = await prisma.questionnaires.delete({
     *   where: {
     *     // ... filter to delete one Questionnaires
     *   }
     * })
     * 
     */
    delete<T extends questionnairesDeleteArgs>(args: SelectSubset<T, questionnairesDeleteArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questionnaires.
     * @param {questionnairesUpdateArgs} args - Arguments to update one Questionnaires.
     * @example
     * // Update one Questionnaires
     * const questionnaires = await prisma.questionnaires.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionnairesUpdateArgs>(args: SelectSubset<T, questionnairesUpdateArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questionnaires.
     * @param {questionnairesDeleteManyArgs} args - Arguments to filter Questionnaires to delete.
     * @example
     * // Delete a few Questionnaires
     * const { count } = await prisma.questionnaires.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionnairesDeleteManyArgs>(args?: SelectSubset<T, questionnairesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questionnaires
     * const questionnaires = await prisma.questionnaires.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionnairesUpdateManyArgs>(args: SelectSubset<T, questionnairesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questionnaires.
     * @param {questionnairesUpsertArgs} args - Arguments to update or create a Questionnaires.
     * @example
     * // Update or create a Questionnaires
     * const questionnaires = await prisma.questionnaires.upsert({
     *   create: {
     *     // ... data to create a Questionnaires
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questionnaires we want to update
     *   }
     * })
     */
    upsert<T extends questionnairesUpsertArgs>(args: SelectSubset<T, questionnairesUpsertArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Questionnaires that matches the filter.
     * @param {questionnairesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const questionnaires = await prisma.questionnaires.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: questionnairesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Questionnaires.
     * @param {questionnairesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const questionnaires = await prisma.questionnaires.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: questionnairesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesCountArgs} args - Arguments to filter Questionnaires to count.
     * @example
     * // Count the number of Questionnaires
     * const count = await prisma.questionnaires.count({
     *   where: {
     *     // ... the filter for the Questionnaires we want to count
     *   }
     * })
    **/
    count<T extends questionnairesCountArgs>(
      args?: Subset<T, questionnairesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionnairesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnairesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionnairesAggregateArgs>(args: Subset<T, QuestionnairesAggregateArgs>): Prisma.PrismaPromise<GetQuestionnairesAggregateType<T>>

    /**
     * Group by Questionnaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionnairesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionnairesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionnairesGroupByArgs['orderBy'] }
        : { orderBy?: questionnairesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionnairesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionnairesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questionnaires model
   */
  readonly fields: questionnairesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questionnaires.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionnairesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends questionnaires$questionsArgs<ExtArgs> = {}>(args?: Subset<T, questionnaires$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    level<T extends questionnaires$levelArgs<ExtArgs> = {}>(args?: Subset<T, questionnaires$levelArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questionnaires model
   */ 
  interface questionnairesFieldRefs {
    readonly id: FieldRef<"questionnaires", 'String'>
    readonly name: FieldRef<"questionnaires", 'String'>
    readonly createdAt: FieldRef<"questionnaires", 'DateTime'>
    readonly updatedAt: FieldRef<"questionnaires", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * questionnaires findUnique
   */
  export type questionnairesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where: questionnairesWhereUniqueInput
  }

  /**
   * questionnaires findUniqueOrThrow
   */
  export type questionnairesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where: questionnairesWhereUniqueInput
  }

  /**
   * questionnaires findFirst
   */
  export type questionnairesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where?: questionnairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionnaires to fetch.
     */
    orderBy?: questionnairesOrderByWithRelationInput | questionnairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionnaires.
     */
    cursor?: questionnairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionnaires.
     */
    distinct?: QuestionnairesScalarFieldEnum | QuestionnairesScalarFieldEnum[]
  }

  /**
   * questionnaires findFirstOrThrow
   */
  export type questionnairesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where?: questionnairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionnaires to fetch.
     */
    orderBy?: questionnairesOrderByWithRelationInput | questionnairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionnaires.
     */
    cursor?: questionnairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionnaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionnaires.
     */
    distinct?: QuestionnairesScalarFieldEnum | QuestionnairesScalarFieldEnum[]
  }

  /**
   * questionnaires findMany
   */
  export type questionnairesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter, which questionnaires to fetch.
     */
    where?: questionnairesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionnaires to fetch.
     */
    orderBy?: questionnairesOrderByWithRelationInput | questionnairesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questionnaires.
     */
    cursor?: questionnairesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionnaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionnaires.
     */
    skip?: number
    distinct?: QuestionnairesScalarFieldEnum | QuestionnairesScalarFieldEnum[]
  }

  /**
   * questionnaires create
   */
  export type questionnairesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * The data needed to create a questionnaires.
     */
    data: XOR<questionnairesCreateInput, questionnairesUncheckedCreateInput>
  }

  /**
   * questionnaires createMany
   */
  export type questionnairesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questionnaires.
     */
    data: questionnairesCreateManyInput | questionnairesCreateManyInput[]
  }

  /**
   * questionnaires update
   */
  export type questionnairesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * The data needed to update a questionnaires.
     */
    data: XOR<questionnairesUpdateInput, questionnairesUncheckedUpdateInput>
    /**
     * Choose, which questionnaires to update.
     */
    where: questionnairesWhereUniqueInput
  }

  /**
   * questionnaires updateMany
   */
  export type questionnairesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questionnaires.
     */
    data: XOR<questionnairesUpdateManyMutationInput, questionnairesUncheckedUpdateManyInput>
    /**
     * Filter which questionnaires to update
     */
    where?: questionnairesWhereInput
  }

  /**
   * questionnaires upsert
   */
  export type questionnairesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * The filter to search for the questionnaires to update in case it exists.
     */
    where: questionnairesWhereUniqueInput
    /**
     * In case the questionnaires found by the `where` argument doesn't exist, create a new questionnaires with this data.
     */
    create: XOR<questionnairesCreateInput, questionnairesUncheckedCreateInput>
    /**
     * In case the questionnaires was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionnairesUpdateInput, questionnairesUncheckedUpdateInput>
  }

  /**
   * questionnaires delete
   */
  export type questionnairesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    /**
     * Filter which questionnaires to delete.
     */
    where: questionnairesWhereUniqueInput
  }

  /**
   * questionnaires deleteMany
   */
  export type questionnairesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionnaires to delete
     */
    where?: questionnairesWhereInput
  }

  /**
   * questionnaires findRaw
   */
  export type questionnairesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * questionnaires aggregateRaw
   */
  export type questionnairesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * questionnaires.questions
   */
  export type questionnaires$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questionnaires.level
   */
  export type questionnaires$levelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    where?: levelsWhereInput
  }

  /**
   * questionnaires without action
   */
  export type questionnairesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
  }


  /**
   * Model question_classes
   */

  export type AggregateQuestion_classes = {
    _count: Question_classesCountAggregateOutputType | null
    _min: Question_classesMinAggregateOutputType | null
    _max: Question_classesMaxAggregateOutputType | null
  }

  export type Question_classesMinAggregateOutputType = {
    id: string | null
    name: string | null
    editable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Question_classesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    editable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Question_classesCountAggregateOutputType = {
    id: number
    name: number
    editable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Question_classesMinAggregateInputType = {
    id?: true
    name?: true
    editable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Question_classesMaxAggregateInputType = {
    id?: true
    name?: true
    editable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Question_classesCountAggregateInputType = {
    id?: true
    name?: true
    editable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Question_classesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_classes to aggregate.
     */
    where?: question_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_classes to fetch.
     */
    orderBy?: question_classesOrderByWithRelationInput | question_classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: question_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned question_classes
    **/
    _count?: true | Question_classesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Question_classesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Question_classesMaxAggregateInputType
  }

  export type GetQuestion_classesAggregateType<T extends Question_classesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion_classes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion_classes[P]>
      : GetScalarType<T[P], AggregateQuestion_classes[P]>
  }




  export type question_classesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_classesWhereInput
    orderBy?: question_classesOrderByWithAggregationInput | question_classesOrderByWithAggregationInput[]
    by: Question_classesScalarFieldEnum[] | Question_classesScalarFieldEnum
    having?: question_classesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Question_classesCountAggregateInputType | true
    _min?: Question_classesMinAggregateInputType
    _max?: Question_classesMaxAggregateInputType
  }

  export type Question_classesGroupByOutputType = {
    id: string
    name: string
    editable: boolean
    createdAt: Date
    updatedAt: Date
    _count: Question_classesCountAggregateOutputType | null
    _min: Question_classesMinAggregateOutputType | null
    _max: Question_classesMaxAggregateOutputType | null
  }

  type GetQuestion_classesGroupByPayload<T extends question_classesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Question_classesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Question_classesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Question_classesGroupByOutputType[P]>
            : GetScalarType<T[P], Question_classesGroupByOutputType[P]>
        }
      >
    >


  export type question_classesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    editable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | question_classes$questionsArgs<ExtArgs>
    _count?: boolean | Question_classesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question_classes"]>


  export type question_classesSelectScalar = {
    id?: boolean
    name?: boolean
    editable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type question_classesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | question_classes$questionsArgs<ExtArgs>
    _count?: boolean | Question_classesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $question_classesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "question_classes"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      editable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["question_classes"]>
    composites: {}
  }

  type question_classesGetPayload<S extends boolean | null | undefined | question_classesDefaultArgs> = $Result.GetResult<Prisma.$question_classesPayload, S>

  type question_classesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<question_classesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Question_classesCountAggregateInputType | true
    }

  export interface question_classesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['question_classes'], meta: { name: 'question_classes' } }
    /**
     * Find zero or one Question_classes that matches the filter.
     * @param {question_classesFindUniqueArgs} args - Arguments to find a Question_classes
     * @example
     * // Get one Question_classes
     * const question_classes = await prisma.question_classes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends question_classesFindUniqueArgs>(args: SelectSubset<T, question_classesFindUniqueArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question_classes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {question_classesFindUniqueOrThrowArgs} args - Arguments to find a Question_classes
     * @example
     * // Get one Question_classes
     * const question_classes = await prisma.question_classes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends question_classesFindUniqueOrThrowArgs>(args: SelectSubset<T, question_classesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question_classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesFindFirstArgs} args - Arguments to find a Question_classes
     * @example
     * // Get one Question_classes
     * const question_classes = await prisma.question_classes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends question_classesFindFirstArgs>(args?: SelectSubset<T, question_classesFindFirstArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question_classes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesFindFirstOrThrowArgs} args - Arguments to find a Question_classes
     * @example
     * // Get one Question_classes
     * const question_classes = await prisma.question_classes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends question_classesFindFirstOrThrowArgs>(args?: SelectSubset<T, question_classesFindFirstOrThrowArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Question_classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Question_classes
     * const question_classes = await prisma.question_classes.findMany()
     * 
     * // Get first 10 Question_classes
     * const question_classes = await prisma.question_classes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const question_classesWithIdOnly = await prisma.question_classes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends question_classesFindManyArgs>(args?: SelectSubset<T, question_classesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question_classes.
     * @param {question_classesCreateArgs} args - Arguments to create a Question_classes.
     * @example
     * // Create one Question_classes
     * const Question_classes = await prisma.question_classes.create({
     *   data: {
     *     // ... data to create a Question_classes
     *   }
     * })
     * 
     */
    create<T extends question_classesCreateArgs>(args: SelectSubset<T, question_classesCreateArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Question_classes.
     * @param {question_classesCreateManyArgs} args - Arguments to create many Question_classes.
     * @example
     * // Create many Question_classes
     * const question_classes = await prisma.question_classes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends question_classesCreateManyArgs>(args?: SelectSubset<T, question_classesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Question_classes.
     * @param {question_classesDeleteArgs} args - Arguments to delete one Question_classes.
     * @example
     * // Delete one Question_classes
     * const Question_classes = await prisma.question_classes.delete({
     *   where: {
     *     // ... filter to delete one Question_classes
     *   }
     * })
     * 
     */
    delete<T extends question_classesDeleteArgs>(args: SelectSubset<T, question_classesDeleteArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question_classes.
     * @param {question_classesUpdateArgs} args - Arguments to update one Question_classes.
     * @example
     * // Update one Question_classes
     * const question_classes = await prisma.question_classes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends question_classesUpdateArgs>(args: SelectSubset<T, question_classesUpdateArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Question_classes.
     * @param {question_classesDeleteManyArgs} args - Arguments to filter Question_classes to delete.
     * @example
     * // Delete a few Question_classes
     * const { count } = await prisma.question_classes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends question_classesDeleteManyArgs>(args?: SelectSubset<T, question_classesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Question_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Question_classes
     * const question_classes = await prisma.question_classes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends question_classesUpdateManyArgs>(args: SelectSubset<T, question_classesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question_classes.
     * @param {question_classesUpsertArgs} args - Arguments to update or create a Question_classes.
     * @example
     * // Update or create a Question_classes
     * const question_classes = await prisma.question_classes.upsert({
     *   create: {
     *     // ... data to create a Question_classes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question_classes we want to update
     *   }
     * })
     */
    upsert<T extends question_classesUpsertArgs>(args: SelectSubset<T, question_classesUpsertArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Question_classes that matches the filter.
     * @param {question_classesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const question_classes = await prisma.question_classes.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: question_classesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Question_classes.
     * @param {question_classesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const question_classes = await prisma.question_classes.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: question_classesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Question_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesCountArgs} args - Arguments to filter Question_classes to count.
     * @example
     * // Count the number of Question_classes
     * const count = await prisma.question_classes.count({
     *   where: {
     *     // ... the filter for the Question_classes we want to count
     *   }
     * })
    **/
    count<T extends question_classesCountArgs>(
      args?: Subset<T, question_classesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Question_classesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Question_classesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Question_classesAggregateArgs>(args: Subset<T, Question_classesAggregateArgs>): Prisma.PrismaPromise<GetQuestion_classesAggregateType<T>>

    /**
     * Group by Question_classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_classesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends question_classesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: question_classesGroupByArgs['orderBy'] }
        : { orderBy?: question_classesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, question_classesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestion_classesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the question_classes model
   */
  readonly fields: question_classesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for question_classes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__question_classesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends question_classes$questionsArgs<ExtArgs> = {}>(args?: Subset<T, question_classes$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the question_classes model
   */ 
  interface question_classesFieldRefs {
    readonly id: FieldRef<"question_classes", 'String'>
    readonly name: FieldRef<"question_classes", 'String'>
    readonly editable: FieldRef<"question_classes", 'Boolean'>
    readonly createdAt: FieldRef<"question_classes", 'DateTime'>
    readonly updatedAt: FieldRef<"question_classes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * question_classes findUnique
   */
  export type question_classesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where: question_classesWhereUniqueInput
  }

  /**
   * question_classes findUniqueOrThrow
   */
  export type question_classesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where: question_classesWhereUniqueInput
  }

  /**
   * question_classes findFirst
   */
  export type question_classesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where?: question_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_classes to fetch.
     */
    orderBy?: question_classesOrderByWithRelationInput | question_classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_classes.
     */
    cursor?: question_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_classes.
     */
    distinct?: Question_classesScalarFieldEnum | Question_classesScalarFieldEnum[]
  }

  /**
   * question_classes findFirstOrThrow
   */
  export type question_classesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where?: question_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_classes to fetch.
     */
    orderBy?: question_classesOrderByWithRelationInput | question_classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_classes.
     */
    cursor?: question_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_classes.
     */
    distinct?: Question_classesScalarFieldEnum | Question_classesScalarFieldEnum[]
  }

  /**
   * question_classes findMany
   */
  export type question_classesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter, which question_classes to fetch.
     */
    where?: question_classesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_classes to fetch.
     */
    orderBy?: question_classesOrderByWithRelationInput | question_classesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing question_classes.
     */
    cursor?: question_classesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_classes.
     */
    skip?: number
    distinct?: Question_classesScalarFieldEnum | Question_classesScalarFieldEnum[]
  }

  /**
   * question_classes create
   */
  export type question_classesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * The data needed to create a question_classes.
     */
    data: XOR<question_classesCreateInput, question_classesUncheckedCreateInput>
  }

  /**
   * question_classes createMany
   */
  export type question_classesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many question_classes.
     */
    data: question_classesCreateManyInput | question_classesCreateManyInput[]
  }

  /**
   * question_classes update
   */
  export type question_classesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * The data needed to update a question_classes.
     */
    data: XOR<question_classesUpdateInput, question_classesUncheckedUpdateInput>
    /**
     * Choose, which question_classes to update.
     */
    where: question_classesWhereUniqueInput
  }

  /**
   * question_classes updateMany
   */
  export type question_classesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update question_classes.
     */
    data: XOR<question_classesUpdateManyMutationInput, question_classesUncheckedUpdateManyInput>
    /**
     * Filter which question_classes to update
     */
    where?: question_classesWhereInput
  }

  /**
   * question_classes upsert
   */
  export type question_classesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * The filter to search for the question_classes to update in case it exists.
     */
    where: question_classesWhereUniqueInput
    /**
     * In case the question_classes found by the `where` argument doesn't exist, create a new question_classes with this data.
     */
    create: XOR<question_classesCreateInput, question_classesUncheckedCreateInput>
    /**
     * In case the question_classes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<question_classesUpdateInput, question_classesUncheckedUpdateInput>
  }

  /**
   * question_classes delete
   */
  export type question_classesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    /**
     * Filter which question_classes to delete.
     */
    where: question_classesWhereUniqueInput
  }

  /**
   * question_classes deleteMany
   */
  export type question_classesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_classes to delete
     */
    where?: question_classesWhereInput
  }

  /**
   * question_classes findRaw
   */
  export type question_classesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * question_classes aggregateRaw
   */
  export type question_classesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * question_classes.questions
   */
  export type question_classes$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * question_classes without action
   */
  export type question_classesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
  }


  /**
   * Model questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    position: number | null
    questionnaireSubCategory: number | null
    maxOptions: number | null
  }

  export type QuestionsSumAggregateOutputType = {
    position: number | null
    questionnaireSubCategory: number | null
    maxOptions: number | null
  }

  export type QuestionsMinAggregateOutputType = {
    id: string | null
    position: number | null
    type: string | null
    classId: string | null
    categoryId: string | null
    onboarding: boolean | null
    randomizeOptions: boolean | null
    fixedOptionSize: boolean | null
    hideOptionText: boolean | null
    brandId: string | null
    correctAnswerId: string | null
    questionnaireId: string | null
    questionnaireSubCategory: number | null
    createdAt: Date | null
    updatedAt: Date | null
    maxOptions: number | null
  }

  export type QuestionsMaxAggregateOutputType = {
    id: string | null
    position: number | null
    type: string | null
    classId: string | null
    categoryId: string | null
    onboarding: boolean | null
    randomizeOptions: boolean | null
    fixedOptionSize: boolean | null
    hideOptionText: boolean | null
    brandId: string | null
    correctAnswerId: string | null
    questionnaireId: string | null
    questionnaireSubCategory: number | null
    createdAt: Date | null
    updatedAt: Date | null
    maxOptions: number | null
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    position: number
    question: number
    type: number
    options: number
    classId: number
    categoryId: number
    onboarding: number
    randomizeOptions: number
    fixedOptionSize: number
    hideOptionText: number
    displayImage: number
    footnote: number
    subtitle: number
    products: number
    brandId: number
    correctAnswerId: number
    questionnaireId: number
    questionnaireSubCategory: number
    createdAt: number
    updatedAt: number
    scaleTopLabel: number
    scaleBottomLabel: number
    maxOptions: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    position?: true
    questionnaireSubCategory?: true
    maxOptions?: true
  }

  export type QuestionsSumAggregateInputType = {
    position?: true
    questionnaireSubCategory?: true
    maxOptions?: true
  }

  export type QuestionsMinAggregateInputType = {
    id?: true
    position?: true
    type?: true
    classId?: true
    categoryId?: true
    onboarding?: true
    randomizeOptions?: true
    fixedOptionSize?: true
    hideOptionText?: true
    brandId?: true
    correctAnswerId?: true
    questionnaireId?: true
    questionnaireSubCategory?: true
    createdAt?: true
    updatedAt?: true
    maxOptions?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    position?: true
    type?: true
    classId?: true
    categoryId?: true
    onboarding?: true
    randomizeOptions?: true
    fixedOptionSize?: true
    hideOptionText?: true
    brandId?: true
    correctAnswerId?: true
    questionnaireId?: true
    questionnaireSubCategory?: true
    createdAt?: true
    updatedAt?: true
    maxOptions?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    position?: true
    question?: true
    type?: true
    options?: true
    classId?: true
    categoryId?: true
    onboarding?: true
    randomizeOptions?: true
    fixedOptionSize?: true
    hideOptionText?: true
    displayImage?: true
    footnote?: true
    subtitle?: true
    products?: true
    brandId?: true
    correctAnswerId?: true
    questionnaireId?: true
    questionnaireSubCategory?: true
    createdAt?: true
    updatedAt?: true
    scaleTopLabel?: true
    scaleBottomLabel?: true
    maxOptions?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to aggregate.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithAggregationInput | questionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _avg?: QuestionsAvgAggregateInputType
    _sum?: QuestionsSumAggregateInputType
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    id: string
    position: number
    question: JsonValue
    type: string
    options: JsonValue[]
    classId: string | null
    categoryId: string | null
    onboarding: boolean
    randomizeOptions: boolean | null
    fixedOptionSize: boolean | null
    hideOptionText: boolean | null
    displayImage: JsonValue | null
    footnote: JsonValue | null
    subtitle: JsonValue | null
    products: JsonValue | null
    brandId: string | null
    correctAnswerId: string | null
    questionnaireId: string | null
    questionnaireSubCategory: number | null
    createdAt: Date
    updatedAt: Date
    scaleTopLabel: JsonValue | null
    scaleBottomLabel: JsonValue | null
    maxOptions: number | null
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    position?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    classId?: boolean
    categoryId?: boolean
    onboarding?: boolean
    randomizeOptions?: boolean
    fixedOptionSize?: boolean
    hideOptionText?: boolean
    displayImage?: boolean
    footnote?: boolean
    subtitle?: boolean
    products?: boolean
    brandId?: boolean
    correctAnswerId?: boolean
    questionnaireId?: boolean
    questionnaireSubCategory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scaleTopLabel?: boolean
    scaleBottomLabel?: boolean
    maxOptions?: boolean
    questionClass?: boolean | questions$questionClassArgs<ExtArgs>
    answers?: boolean | questions$answersArgs<ExtArgs>
    brand?: boolean | questions$brandArgs<ExtArgs>
    questionnaire?: boolean | questions$questionnaireArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>


  export type questionsSelectScalar = {
    id?: boolean
    position?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    classId?: boolean
    categoryId?: boolean
    onboarding?: boolean
    randomizeOptions?: boolean
    fixedOptionSize?: boolean
    hideOptionText?: boolean
    displayImage?: boolean
    footnote?: boolean
    subtitle?: boolean
    products?: boolean
    brandId?: boolean
    correctAnswerId?: boolean
    questionnaireId?: boolean
    questionnaireSubCategory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scaleTopLabel?: boolean
    scaleBottomLabel?: boolean
    maxOptions?: boolean
  }

  export type questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionClass?: boolean | questions$questionClassArgs<ExtArgs>
    answers?: boolean | questions$answersArgs<ExtArgs>
    brand?: boolean | questions$brandArgs<ExtArgs>
    questionnaire?: boolean | questions$questionnaireArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions"
    objects: {
      questionClass: Prisma.$question_classesPayload<ExtArgs> | null
      answers: Prisma.$answersPayload<ExtArgs>[]
      brand: Prisma.$brandsPayload<ExtArgs> | null
      questionnaire: Prisma.$questionnairesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      position: number
      question: Prisma.JsonValue
      type: string
      options: Prisma.JsonValue[]
      classId: string | null
      categoryId: string | null
      onboarding: boolean
      randomizeOptions: boolean | null
      fixedOptionSize: boolean | null
      hideOptionText: boolean | null
      displayImage: Prisma.JsonValue | null
      footnote: Prisma.JsonValue | null
      subtitle: Prisma.JsonValue | null
      products: Prisma.JsonValue | null
      brandId: string | null
      correctAnswerId: string | null
      questionnaireId: string | null
      questionnaireSubCategory: number | null
      createdAt: Date
      updatedAt: Date
      scaleTopLabel: Prisma.JsonValue | null
      scaleBottomLabel: Prisma.JsonValue | null
      maxOptions: number | null
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type questionsGetPayload<S extends boolean | null | undefined | questionsDefaultArgs> = $Result.GetResult<Prisma.$questionsPayload, S>

  type questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<questionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions'], meta: { name: 'questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {questionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionsFindUniqueArgs>(args: SelectSubset<T, questionsFindUniqueArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {questionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionsFindFirstArgs>(args?: SelectSubset<T, questionsFindFirstArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionsFindManyArgs>(args?: SelectSubset<T, questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions.
     * @param {questionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends questionsCreateArgs>(args: SelectSubset<T, questionsCreateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {questionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionsCreateManyArgs>(args?: SelectSubset<T, questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questions.
     * @param {questionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends questionsDeleteArgs>(args: SelectSubset<T, questionsDeleteArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions.
     * @param {questionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionsUpdateArgs>(args: SelectSubset<T, questionsUpdateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {questionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionsDeleteManyArgs>(args?: SelectSubset<T, questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionsUpdateManyArgs>(args: SelectSubset<T, questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions.
     * @param {questionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends questionsUpsertArgs>(args: SelectSubset<T, questionsUpsertArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * @param {questionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const questions = await prisma.questions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: questionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Questions.
     * @param {questionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const questions = await prisma.questions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: questionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionsCountArgs>(
      args?: Subset<T, questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionsGroupByArgs['orderBy'] }
        : { orderBy?: questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions model
   */
  readonly fields: questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questionClass<T extends questions$questionClassArgs<ExtArgs> = {}>(args?: Subset<T, questions$questionClassArgs<ExtArgs>>): Prisma__question_classesClient<$Result.GetResult<Prisma.$question_classesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    answers<T extends questions$answersArgs<ExtArgs> = {}>(args?: Subset<T, questions$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany"> | Null>
    brand<T extends questions$brandArgs<ExtArgs> = {}>(args?: Subset<T, questions$brandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    questionnaire<T extends questions$questionnaireArgs<ExtArgs> = {}>(args?: Subset<T, questions$questionnaireArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions model
   */ 
  interface questionsFieldRefs {
    readonly id: FieldRef<"questions", 'String'>
    readonly position: FieldRef<"questions", 'Int'>
    readonly question: FieldRef<"questions", 'Json'>
    readonly type: FieldRef<"questions", 'String'>
    readonly options: FieldRef<"questions", 'Json[]'>
    readonly classId: FieldRef<"questions", 'String'>
    readonly categoryId: FieldRef<"questions", 'String'>
    readonly onboarding: FieldRef<"questions", 'Boolean'>
    readonly randomizeOptions: FieldRef<"questions", 'Boolean'>
    readonly fixedOptionSize: FieldRef<"questions", 'Boolean'>
    readonly hideOptionText: FieldRef<"questions", 'Boolean'>
    readonly displayImage: FieldRef<"questions", 'Json'>
    readonly footnote: FieldRef<"questions", 'Json'>
    readonly subtitle: FieldRef<"questions", 'Json'>
    readonly products: FieldRef<"questions", 'Json'>
    readonly brandId: FieldRef<"questions", 'String'>
    readonly correctAnswerId: FieldRef<"questions", 'String'>
    readonly questionnaireId: FieldRef<"questions", 'String'>
    readonly questionnaireSubCategory: FieldRef<"questions", 'Int'>
    readonly createdAt: FieldRef<"questions", 'DateTime'>
    readonly updatedAt: FieldRef<"questions", 'DateTime'>
    readonly scaleTopLabel: FieldRef<"questions", 'Json'>
    readonly scaleBottomLabel: FieldRef<"questions", 'Json'>
    readonly maxOptions: FieldRef<"questions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * questions findUnique
   */
  export type questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findUniqueOrThrow
   */
  export type questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findFirst
   */
  export type questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findFirstOrThrow
   */
  export type questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findMany
   */
  export type questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions create
   */
  export type questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a questions.
     */
    data: XOR<questionsCreateInput, questionsUncheckedCreateInput>
  }

  /**
   * questions createMany
   */
  export type questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionsCreateManyInput | questionsCreateManyInput[]
  }

  /**
   * questions update
   */
  export type questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a questions.
     */
    data: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
    /**
     * Choose, which questions to update.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions updateMany
   */
  export type questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionsWhereInput
  }

  /**
   * questions upsert
   */
  export type questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the questions to update in case it exists.
     */
    where: questionsWhereUniqueInput
    /**
     * In case the questions found by the `where` argument doesn't exist, create a new questions with this data.
     */
    create: XOR<questionsCreateInput, questionsUncheckedCreateInput>
    /**
     * In case the questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
  }

  /**
   * questions delete
   */
  export type questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter which questions to delete.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions deleteMany
   */
  export type questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionsWhereInput
  }

  /**
   * questions findRaw
   */
  export type questionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * questions aggregateRaw
   */
  export type questionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * questions.questionClass
   */
  export type questions$questionClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_classes
     */
    select?: question_classesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_classesInclude<ExtArgs> | null
    where?: question_classesWhereInput
  }

  /**
   * questions.answers
   */
  export type questions$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    where?: answersWhereInput
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    cursor?: answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * questions.brand
   */
  export type questions$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * questions.questionnaire
   */
  export type questions$questionnaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    where?: questionnairesWhereInput
  }

  /**
   * questions without action
   */
  export type questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
  }


  /**
   * Model ratings
   */

  export type AggregateRatings = {
    _count: RatingsCountAggregateOutputType | null
    _avg: RatingsAvgAggregateOutputType | null
    _sum: RatingsSumAggregateOutputType | null
    _min: RatingsMinAggregateOutputType | null
    _max: RatingsMaxAggregateOutputType | null
  }

  export type RatingsAvgAggregateOutputType = {
    rating: number | null
  }

  export type RatingsSumAggregateOutputType = {
    rating: number | null
  }

  export type RatingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    brandId: string | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    brandId: string | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingsCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    brandId: number
    rating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RatingsAvgAggregateInputType = {
    rating?: true
  }

  export type RatingsSumAggregateInputType = {
    rating?: true
  }

  export type RatingsMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    brandId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingsMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    brandId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingsCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    brandId?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RatingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ratings to aggregate.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ratings
    **/
    _count?: true | RatingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingsMaxAggregateInputType
  }

  export type GetRatingsAggregateType<T extends RatingsAggregateArgs> = {
        [P in keyof T & keyof AggregateRatings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRatings[P]>
      : GetScalarType<T[P], AggregateRatings[P]>
  }




  export type ratingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ratingsWhereInput
    orderBy?: ratingsOrderByWithAggregationInput | ratingsOrderByWithAggregationInput[]
    by: RatingsScalarFieldEnum[] | RatingsScalarFieldEnum
    having?: ratingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingsCountAggregateInputType | true
    _avg?: RatingsAvgAggregateInputType
    _sum?: RatingsSumAggregateInputType
    _min?: RatingsMinAggregateInputType
    _max?: RatingsMaxAggregateInputType
  }

  export type RatingsGroupByOutputType = {
    id: string
    userId: string
    productId: string | null
    brandId: string
    rating: number
    createdAt: Date
    updatedAt: Date
    _count: RatingsCountAggregateOutputType | null
    _avg: RatingsAvgAggregateOutputType | null
    _sum: RatingsSumAggregateOutputType | null
    _min: RatingsMinAggregateOutputType | null
    _max: RatingsMaxAggregateOutputType | null
  }

  type GetRatingsGroupByPayload<T extends ratingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingsGroupByOutputType[P]>
            : GetScalarType<T[P], RatingsGroupByOutputType[P]>
        }
      >
    >


  export type ratingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    brandId?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    product?: boolean | ratings$productArgs<ExtArgs>
    brand?: boolean | brandsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ratings"]>


  export type ratingsSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    brandId?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ratingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    product?: boolean | ratings$productArgs<ExtArgs>
    brand?: boolean | brandsDefaultArgs<ExtArgs>
  }

  export type $ratingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ratings"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      product: Prisma.$productsPayload<ExtArgs> | null
      brand: Prisma.$brandsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string | null
      brandId: string
      rating: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ratings"]>
    composites: {}
  }

  type ratingsGetPayload<S extends boolean | null | undefined | ratingsDefaultArgs> = $Result.GetResult<Prisma.$ratingsPayload, S>

  type ratingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ratingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RatingsCountAggregateInputType | true
    }

  export interface ratingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ratings'], meta: { name: 'ratings' } }
    /**
     * Find zero or one Ratings that matches the filter.
     * @param {ratingsFindUniqueArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ratingsFindUniqueArgs>(args: SelectSubset<T, ratingsFindUniqueArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ratings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ratingsFindUniqueOrThrowArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ratingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ratingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindFirstArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ratingsFindFirstArgs>(args?: SelectSubset<T, ratingsFindFirstArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ratings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindFirstOrThrowArgs} args - Arguments to find a Ratings
     * @example
     * // Get one Ratings
     * const ratings = await prisma.ratings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ratingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ratingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.ratings.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.ratings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingsWithIdOnly = await prisma.ratings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ratingsFindManyArgs>(args?: SelectSubset<T, ratingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ratings.
     * @param {ratingsCreateArgs} args - Arguments to create a Ratings.
     * @example
     * // Create one Ratings
     * const Ratings = await prisma.ratings.create({
     *   data: {
     *     // ... data to create a Ratings
     *   }
     * })
     * 
     */
    create<T extends ratingsCreateArgs>(args: SelectSubset<T, ratingsCreateArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ratings.
     * @param {ratingsCreateManyArgs} args - Arguments to create many Ratings.
     * @example
     * // Create many Ratings
     * const ratings = await prisma.ratings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ratingsCreateManyArgs>(args?: SelectSubset<T, ratingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ratings.
     * @param {ratingsDeleteArgs} args - Arguments to delete one Ratings.
     * @example
     * // Delete one Ratings
     * const Ratings = await prisma.ratings.delete({
     *   where: {
     *     // ... filter to delete one Ratings
     *   }
     * })
     * 
     */
    delete<T extends ratingsDeleteArgs>(args: SelectSubset<T, ratingsDeleteArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ratings.
     * @param {ratingsUpdateArgs} args - Arguments to update one Ratings.
     * @example
     * // Update one Ratings
     * const ratings = await prisma.ratings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ratingsUpdateArgs>(args: SelectSubset<T, ratingsUpdateArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ratings.
     * @param {ratingsDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.ratings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ratingsDeleteManyArgs>(args?: SelectSubset<T, ratingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const ratings = await prisma.ratings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ratingsUpdateManyArgs>(args: SelectSubset<T, ratingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ratings.
     * @param {ratingsUpsertArgs} args - Arguments to update or create a Ratings.
     * @example
     * // Update or create a Ratings
     * const ratings = await prisma.ratings.upsert({
     *   create: {
     *     // ... data to create a Ratings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ratings we want to update
     *   }
     * })
     */
    upsert<T extends ratingsUpsertArgs>(args: SelectSubset<T, ratingsUpsertArgs<ExtArgs>>): Prisma__ratingsClient<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * @param {ratingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ratings = await prisma.ratings.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ratingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Ratings.
     * @param {ratingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ratings = await prisma.ratings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ratingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.ratings.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends ratingsCountArgs>(
      args?: Subset<T, ratingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingsAggregateArgs>(args: Subset<T, RatingsAggregateArgs>): Prisma.PrismaPromise<GetRatingsAggregateType<T>>

    /**
     * Group by Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ratingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ratingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ratingsGroupByArgs['orderBy'] }
        : { orderBy?: ratingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ratingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ratings model
   */
  readonly fields: ratingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ratings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ratingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ratings$productArgs<ExtArgs> = {}>(args?: Subset<T, ratings$productArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    brand<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ratings model
   */ 
  interface ratingsFieldRefs {
    readonly id: FieldRef<"ratings", 'String'>
    readonly userId: FieldRef<"ratings", 'String'>
    readonly productId: FieldRef<"ratings", 'String'>
    readonly brandId: FieldRef<"ratings", 'String'>
    readonly rating: FieldRef<"ratings", 'Float'>
    readonly createdAt: FieldRef<"ratings", 'DateTime'>
    readonly updatedAt: FieldRef<"ratings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ratings findUnique
   */
  export type ratingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings findUniqueOrThrow
   */
  export type ratingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings findFirst
   */
  export type ratingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings findFirstOrThrow
   */
  export type ratingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ratings.
     */
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings findMany
   */
  export type ratingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter, which ratings to fetch.
     */
    where?: ratingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ratings to fetch.
     */
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ratings.
     */
    cursor?: ratingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ratings.
     */
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * ratings create
   */
  export type ratingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * The data needed to create a ratings.
     */
    data: XOR<ratingsCreateInput, ratingsUncheckedCreateInput>
  }

  /**
   * ratings createMany
   */
  export type ratingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ratings.
     */
    data: ratingsCreateManyInput | ratingsCreateManyInput[]
  }

  /**
   * ratings update
   */
  export type ratingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * The data needed to update a ratings.
     */
    data: XOR<ratingsUpdateInput, ratingsUncheckedUpdateInput>
    /**
     * Choose, which ratings to update.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings updateMany
   */
  export type ratingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ratings.
     */
    data: XOR<ratingsUpdateManyMutationInput, ratingsUncheckedUpdateManyInput>
    /**
     * Filter which ratings to update
     */
    where?: ratingsWhereInput
  }

  /**
   * ratings upsert
   */
  export type ratingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * The filter to search for the ratings to update in case it exists.
     */
    where: ratingsWhereUniqueInput
    /**
     * In case the ratings found by the `where` argument doesn't exist, create a new ratings with this data.
     */
    create: XOR<ratingsCreateInput, ratingsUncheckedCreateInput>
    /**
     * In case the ratings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ratingsUpdateInput, ratingsUncheckedUpdateInput>
  }

  /**
   * ratings delete
   */
  export type ratingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    /**
     * Filter which ratings to delete.
     */
    where: ratingsWhereUniqueInput
  }

  /**
   * ratings deleteMany
   */
  export type ratingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ratings to delete
     */
    where?: ratingsWhereInput
  }

  /**
   * ratings findRaw
   */
  export type ratingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ratings aggregateRaw
   */
  export type ratingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ratings.product
   */
  export type ratings$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * ratings without action
   */
  export type ratingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
  }


  /**
   * Model settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    receiveNotifications: boolean | null
    newBrands: boolean | null
    personalizedOffers: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    receiveNotifications: boolean | null
    newBrands: boolean | null
    personalizedOffers: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    userId: number
    receiveNotifications: number
    newBrands: number
    personalizedOffers: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    userId?: true
    receiveNotifications?: true
    newBrands?: true
    personalizedOffers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    receiveNotifications?: true
    newBrands?: true
    personalizedOffers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    userId?: true
    receiveNotifications?: true
    newBrands?: true
    personalizedOffers?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to aggregate.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput
    orderBy?: settingsOrderByWithAggregationInput | settingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    userId: string
    receiveNotifications: boolean
    newBrands: boolean
    personalizedOffers: boolean
    createdAt: Date
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    receiveNotifications?: boolean
    newBrands?: boolean
    personalizedOffers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>


  export type settingsSelectScalar = {
    id?: boolean
    userId?: boolean
    receiveNotifications?: boolean
    newBrands?: boolean
    personalizedOffers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settings"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      receiveNotifications: boolean
      newBrands: boolean
      personalizedOffers: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type settingsGetPayload<S extends boolean | null | undefined | settingsDefaultArgs> = $Result.GetResult<Prisma.$settingsPayload, S>

  type settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<settingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settings'], meta: { name: 'settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingsFindUniqueArgs>(args: SelectSubset<T, settingsFindUniqueArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingsFindFirstArgs>(args?: SelectSubset<T, settingsFindFirstArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends settingsFindManyArgs>(args?: SelectSubset<T, settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends settingsCreateArgs>(args: SelectSubset<T, settingsCreateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settings.
     * @param {settingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settingsCreateManyArgs>(args?: SelectSubset<T, settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends settingsDeleteArgs>(args: SelectSubset<T, settingsDeleteArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settingsUpdateArgs>(args: SelectSubset<T, settingsUpdateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settingsDeleteManyArgs>(args?: SelectSubset<T, settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settingsUpdateManyArgs>(args: SelectSubset<T, settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends settingsUpsertArgs>(args: SelectSubset<T, settingsUpsertArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * @param {settingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const settings = await prisma.settings.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: settingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Settings.
     * @param {settingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const settings = await prisma.settings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: settingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingsGroupByArgs['orderBy'] }
        : { orderBy?: settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settings model
   */
  readonly fields: settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the settings model
   */ 
  interface settingsFieldRefs {
    readonly id: FieldRef<"settings", 'String'>
    readonly userId: FieldRef<"settings", 'String'>
    readonly receiveNotifications: FieldRef<"settings", 'Boolean'>
    readonly newBrands: FieldRef<"settings", 'Boolean'>
    readonly personalizedOffers: FieldRef<"settings", 'Boolean'>
    readonly createdAt: FieldRef<"settings", 'DateTime'>
    readonly updatedAt: FieldRef<"settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * settings findUnique
   */
  export type settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findFirst
   */
  export type settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findMany
   */
  export type settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings create
   */
  export type settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a settings.
     */
    data: XOR<settingsCreateInput, settingsUncheckedCreateInput>
  }

  /**
   * settings createMany
   */
  export type settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
  }

  /**
   * settings update
   */
  export type settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a settings.
     */
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
    /**
     * Choose, which settings to update.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
  }

  /**
   * settings upsert
   */
  export type settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the settings to update in case it exists.
     */
    where: settingsWhereUniqueInput
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     */
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
  }

  /**
   * settings delete
   */
  export type settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    /**
     * Filter which settings to delete.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingsWhereInput
  }

  /**
   * settings findRaw
   */
  export type settingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * settings aggregateRaw
   */
  export type settingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * settings without action
   */
  export type settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
  }


  /**
   * Model terms_and_conditions
   */

  export type AggregateTerms_and_conditions = {
    _count: Terms_and_conditionsCountAggregateOutputType | null
    _min: Terms_and_conditionsMinAggregateOutputType | null
    _max: Terms_and_conditionsMaxAggregateOutputType | null
  }

  export type Terms_and_conditionsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmailAddress: string | null
    acceptanceDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Terms_and_conditionsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmailAddress: string | null
    acceptanceDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Terms_and_conditionsCountAggregateOutputType = {
    id: number
    userId: number
    userEmailAddress: number
    acceptanceDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Terms_and_conditionsMinAggregateInputType = {
    id?: true
    userId?: true
    userEmailAddress?: true
    acceptanceDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Terms_and_conditionsMaxAggregateInputType = {
    id?: true
    userId?: true
    userEmailAddress?: true
    acceptanceDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Terms_and_conditionsCountAggregateInputType = {
    id?: true
    userId?: true
    userEmailAddress?: true
    acceptanceDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Terms_and_conditionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which terms_and_conditions to aggregate.
     */
    where?: terms_and_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terms_and_conditions to fetch.
     */
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: terms_and_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terms_and_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terms_and_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned terms_and_conditions
    **/
    _count?: true | Terms_and_conditionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Terms_and_conditionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Terms_and_conditionsMaxAggregateInputType
  }

  export type GetTerms_and_conditionsAggregateType<T extends Terms_and_conditionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTerms_and_conditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerms_and_conditions[P]>
      : GetScalarType<T[P], AggregateTerms_and_conditions[P]>
  }




  export type terms_and_conditionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: terms_and_conditionsWhereInput
    orderBy?: terms_and_conditionsOrderByWithAggregationInput | terms_and_conditionsOrderByWithAggregationInput[]
    by: Terms_and_conditionsScalarFieldEnum[] | Terms_and_conditionsScalarFieldEnum
    having?: terms_and_conditionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Terms_and_conditionsCountAggregateInputType | true
    _min?: Terms_and_conditionsMinAggregateInputType
    _max?: Terms_and_conditionsMaxAggregateInputType
  }

  export type Terms_and_conditionsGroupByOutputType = {
    id: string
    userId: string
    userEmailAddress: string
    acceptanceDate: Date
    createdAt: Date
    updatedAt: Date
    _count: Terms_and_conditionsCountAggregateOutputType | null
    _min: Terms_and_conditionsMinAggregateOutputType | null
    _max: Terms_and_conditionsMaxAggregateOutputType | null
  }

  type GetTerms_and_conditionsGroupByPayload<T extends terms_and_conditionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Terms_and_conditionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Terms_and_conditionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Terms_and_conditionsGroupByOutputType[P]>
            : GetScalarType<T[P], Terms_and_conditionsGroupByOutputType[P]>
        }
      >
    >


  export type terms_and_conditionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmailAddress?: boolean
    acceptanceDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terms_and_conditions"]>


  export type terms_and_conditionsSelectScalar = {
    id?: boolean
    userId?: boolean
    userEmailAddress?: boolean
    acceptanceDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type terms_and_conditionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $terms_and_conditionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "terms_and_conditions"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userEmailAddress: string
      acceptanceDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["terms_and_conditions"]>
    composites: {}
  }

  type terms_and_conditionsGetPayload<S extends boolean | null | undefined | terms_and_conditionsDefaultArgs> = $Result.GetResult<Prisma.$terms_and_conditionsPayload, S>

  type terms_and_conditionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<terms_and_conditionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Terms_and_conditionsCountAggregateInputType | true
    }

  export interface terms_and_conditionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['terms_and_conditions'], meta: { name: 'terms_and_conditions' } }
    /**
     * Find zero or one Terms_and_conditions that matches the filter.
     * @param {terms_and_conditionsFindUniqueArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends terms_and_conditionsFindUniqueArgs>(args: SelectSubset<T, terms_and_conditionsFindUniqueArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Terms_and_conditions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {terms_and_conditionsFindUniqueOrThrowArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends terms_and_conditionsFindUniqueOrThrowArgs>(args: SelectSubset<T, terms_and_conditionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Terms_and_conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsFindFirstArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends terms_and_conditionsFindFirstArgs>(args?: SelectSubset<T, terms_and_conditionsFindFirstArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Terms_and_conditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsFindFirstOrThrowArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends terms_and_conditionsFindFirstOrThrowArgs>(args?: SelectSubset<T, terms_and_conditionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Terms_and_conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findMany()
     * 
     * // Get first 10 Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const terms_and_conditionsWithIdOnly = await prisma.terms_and_conditions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends terms_and_conditionsFindManyArgs>(args?: SelectSubset<T, terms_and_conditionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Terms_and_conditions.
     * @param {terms_and_conditionsCreateArgs} args - Arguments to create a Terms_and_conditions.
     * @example
     * // Create one Terms_and_conditions
     * const Terms_and_conditions = await prisma.terms_and_conditions.create({
     *   data: {
     *     // ... data to create a Terms_and_conditions
     *   }
     * })
     * 
     */
    create<T extends terms_and_conditionsCreateArgs>(args: SelectSubset<T, terms_and_conditionsCreateArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Terms_and_conditions.
     * @param {terms_and_conditionsCreateManyArgs} args - Arguments to create many Terms_and_conditions.
     * @example
     * // Create many Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends terms_and_conditionsCreateManyArgs>(args?: SelectSubset<T, terms_and_conditionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Terms_and_conditions.
     * @param {terms_and_conditionsDeleteArgs} args - Arguments to delete one Terms_and_conditions.
     * @example
     * // Delete one Terms_and_conditions
     * const Terms_and_conditions = await prisma.terms_and_conditions.delete({
     *   where: {
     *     // ... filter to delete one Terms_and_conditions
     *   }
     * })
     * 
     */
    delete<T extends terms_and_conditionsDeleteArgs>(args: SelectSubset<T, terms_and_conditionsDeleteArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Terms_and_conditions.
     * @param {terms_and_conditionsUpdateArgs} args - Arguments to update one Terms_and_conditions.
     * @example
     * // Update one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends terms_and_conditionsUpdateArgs>(args: SelectSubset<T, terms_and_conditionsUpdateArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Terms_and_conditions.
     * @param {terms_and_conditionsDeleteManyArgs} args - Arguments to filter Terms_and_conditions to delete.
     * @example
     * // Delete a few Terms_and_conditions
     * const { count } = await prisma.terms_and_conditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends terms_and_conditionsDeleteManyArgs>(args?: SelectSubset<T, terms_and_conditionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terms_and_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends terms_and_conditionsUpdateManyArgs>(args: SelectSubset<T, terms_and_conditionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Terms_and_conditions.
     * @param {terms_and_conditionsUpsertArgs} args - Arguments to update or create a Terms_and_conditions.
     * @example
     * // Update or create a Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.upsert({
     *   create: {
     *     // ... data to create a Terms_and_conditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terms_and_conditions we want to update
     *   }
     * })
     */
    upsert<T extends terms_and_conditionsUpsertArgs>(args: SelectSubset<T, terms_and_conditionsUpsertArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Terms_and_conditions that matches the filter.
     * @param {terms_and_conditionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const terms_and_conditions = await prisma.terms_and_conditions.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: terms_and_conditionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Terms_and_conditions.
     * @param {terms_and_conditionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const terms_and_conditions = await prisma.terms_and_conditions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: terms_and_conditionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Terms_and_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsCountArgs} args - Arguments to filter Terms_and_conditions to count.
     * @example
     * // Count the number of Terms_and_conditions
     * const count = await prisma.terms_and_conditions.count({
     *   where: {
     *     // ... the filter for the Terms_and_conditions we want to count
     *   }
     * })
    **/
    count<T extends terms_and_conditionsCountArgs>(
      args?: Subset<T, terms_and_conditionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Terms_and_conditionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Terms_and_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Terms_and_conditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Terms_and_conditionsAggregateArgs>(args: Subset<T, Terms_and_conditionsAggregateArgs>): Prisma.PrismaPromise<GetTerms_and_conditionsAggregateType<T>>

    /**
     * Group by Terms_and_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends terms_and_conditionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: terms_and_conditionsGroupByArgs['orderBy'] }
        : { orderBy?: terms_and_conditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, terms_and_conditionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerms_and_conditionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the terms_and_conditions model
   */
  readonly fields: terms_and_conditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for terms_and_conditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__terms_and_conditionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the terms_and_conditions model
   */ 
  interface terms_and_conditionsFieldRefs {
    readonly id: FieldRef<"terms_and_conditions", 'String'>
    readonly userId: FieldRef<"terms_and_conditions", 'String'>
    readonly userEmailAddress: FieldRef<"terms_and_conditions", 'String'>
    readonly acceptanceDate: FieldRef<"terms_and_conditions", 'DateTime'>
    readonly createdAt: FieldRef<"terms_and_conditions", 'DateTime'>
    readonly updatedAt: FieldRef<"terms_and_conditions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * terms_and_conditions findUnique
   */
  export type terms_and_conditionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where: terms_and_conditionsWhereUniqueInput
  }

  /**
   * terms_and_conditions findUniqueOrThrow
   */
  export type terms_and_conditionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where: terms_and_conditionsWhereUniqueInput
  }

  /**
   * terms_and_conditions findFirst
   */
  export type terms_and_conditionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where?: terms_and_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terms_and_conditions to fetch.
     */
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for terms_and_conditions.
     */
    cursor?: terms_and_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terms_and_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terms_and_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of terms_and_conditions.
     */
    distinct?: Terms_and_conditionsScalarFieldEnum | Terms_and_conditionsScalarFieldEnum[]
  }

  /**
   * terms_and_conditions findFirstOrThrow
   */
  export type terms_and_conditionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where?: terms_and_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terms_and_conditions to fetch.
     */
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for terms_and_conditions.
     */
    cursor?: terms_and_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terms_and_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terms_and_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of terms_and_conditions.
     */
    distinct?: Terms_and_conditionsScalarFieldEnum | Terms_and_conditionsScalarFieldEnum[]
  }

  /**
   * terms_and_conditions findMany
   */
  export type terms_and_conditionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where?: terms_and_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terms_and_conditions to fetch.
     */
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing terms_and_conditions.
     */
    cursor?: terms_and_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terms_and_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terms_and_conditions.
     */
    skip?: number
    distinct?: Terms_and_conditionsScalarFieldEnum | Terms_and_conditionsScalarFieldEnum[]
  }

  /**
   * terms_and_conditions create
   */
  export type terms_and_conditionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * The data needed to create a terms_and_conditions.
     */
    data: XOR<terms_and_conditionsCreateInput, terms_and_conditionsUncheckedCreateInput>
  }

  /**
   * terms_and_conditions createMany
   */
  export type terms_and_conditionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many terms_and_conditions.
     */
    data: terms_and_conditionsCreateManyInput | terms_and_conditionsCreateManyInput[]
  }

  /**
   * terms_and_conditions update
   */
  export type terms_and_conditionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * The data needed to update a terms_and_conditions.
     */
    data: XOR<terms_and_conditionsUpdateInput, terms_and_conditionsUncheckedUpdateInput>
    /**
     * Choose, which terms_and_conditions to update.
     */
    where: terms_and_conditionsWhereUniqueInput
  }

  /**
   * terms_and_conditions updateMany
   */
  export type terms_and_conditionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update terms_and_conditions.
     */
    data: XOR<terms_and_conditionsUpdateManyMutationInput, terms_and_conditionsUncheckedUpdateManyInput>
    /**
     * Filter which terms_and_conditions to update
     */
    where?: terms_and_conditionsWhereInput
  }

  /**
   * terms_and_conditions upsert
   */
  export type terms_and_conditionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * The filter to search for the terms_and_conditions to update in case it exists.
     */
    where: terms_and_conditionsWhereUniqueInput
    /**
     * In case the terms_and_conditions found by the `where` argument doesn't exist, create a new terms_and_conditions with this data.
     */
    create: XOR<terms_and_conditionsCreateInput, terms_and_conditionsUncheckedCreateInput>
    /**
     * In case the terms_and_conditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<terms_and_conditionsUpdateInput, terms_and_conditionsUncheckedUpdateInput>
  }

  /**
   * terms_and_conditions delete
   */
  export type terms_and_conditionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    /**
     * Filter which terms_and_conditions to delete.
     */
    where: terms_and_conditionsWhereUniqueInput
  }

  /**
   * terms_and_conditions deleteMany
   */
  export type terms_and_conditionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which terms_and_conditions to delete
     */
    where?: terms_and_conditionsWhereInput
  }

  /**
   * terms_and_conditions findRaw
   */
  export type terms_and_conditionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * terms_and_conditions aggregateRaw
   */
  export type terms_and_conditionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * terms_and_conditions without action
   */
  export type terms_and_conditionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
  }


  /**
   * Model feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    text: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    text: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    userId: number
    text: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    text?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedback to aggregate.
     */
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type feedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbackWhereInput
    orderBy?: feedbackOrderByWithAggregationInput | feedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: feedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    userId: string
    text: string
    email: string | null
    createdAt: Date
    updatedAt: Date
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends feedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type feedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    text?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>


  export type feedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    text?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type feedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $feedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feedback"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      text: string
      email: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type feedbackGetPayload<S extends boolean | null | undefined | feedbackDefaultArgs> = $Result.GetResult<Prisma.$feedbackPayload, S>

  type feedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<feedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface feedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feedback'], meta: { name: 'feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {feedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feedbackFindUniqueArgs>(args: SelectSubset<T, feedbackFindUniqueArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {feedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, feedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feedbackFindFirstArgs>(args?: SelectSubset<T, feedbackFindFirstArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, feedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends feedbackFindManyArgs>(args?: SelectSubset<T, feedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feedback.
     * @param {feedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends feedbackCreateArgs>(args: SelectSubset<T, feedbackCreateArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feedbacks.
     * @param {feedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feedbackCreateManyArgs>(args?: SelectSubset<T, feedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {feedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends feedbackDeleteArgs>(args: SelectSubset<T, feedbackDeleteArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {feedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feedbackUpdateArgs>(args: SelectSubset<T, feedbackUpdateArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {feedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feedbackDeleteManyArgs>(args?: SelectSubset<T, feedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feedbackUpdateManyArgs>(args: SelectSubset<T, feedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {feedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends feedbackUpsertArgs>(args: SelectSubset<T, feedbackUpsertArgs<ExtArgs>>): Prisma__feedbackClient<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * @param {feedbackFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const feedback = await prisma.feedback.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: feedbackFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Feedback.
     * @param {feedbackAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const feedback = await prisma.feedback.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: feedbackAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends feedbackCountArgs>(
      args?: Subset<T, feedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feedbackGroupByArgs['orderBy'] }
        : { orderBy?: feedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feedback model
   */
  readonly fields: feedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feedback model
   */ 
  interface feedbackFieldRefs {
    readonly id: FieldRef<"feedback", 'String'>
    readonly userId: FieldRef<"feedback", 'String'>
    readonly text: FieldRef<"feedback", 'String'>
    readonly email: FieldRef<"feedback", 'String'>
    readonly createdAt: FieldRef<"feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * feedback findUnique
   */
  export type feedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedback to fetch.
     */
    where: feedbackWhereUniqueInput
  }

  /**
   * feedback findUniqueOrThrow
   */
  export type feedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedback to fetch.
     */
    where: feedbackWhereUniqueInput
  }

  /**
   * feedback findFirst
   */
  export type feedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedback to fetch.
     */
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     */
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * feedback findFirstOrThrow
   */
  export type feedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedback to fetch.
     */
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     */
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * feedback findMany
   */
  export type feedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where?: feedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feedbacks.
     */
    cursor?: feedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * feedback create
   */
  export type feedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a feedback.
     */
    data: XOR<feedbackCreateInput, feedbackUncheckedCreateInput>
  }

  /**
   * feedback createMany
   */
  export type feedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feedbacks.
     */
    data: feedbackCreateManyInput | feedbackCreateManyInput[]
  }

  /**
   * feedback update
   */
  export type feedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a feedback.
     */
    data: XOR<feedbackUpdateInput, feedbackUncheckedUpdateInput>
    /**
     * Choose, which feedback to update.
     */
    where: feedbackWhereUniqueInput
  }

  /**
   * feedback updateMany
   */
  export type feedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feedbacks.
     */
    data: XOR<feedbackUpdateManyMutationInput, feedbackUncheckedUpdateManyInput>
    /**
     * Filter which feedbacks to update
     */
    where?: feedbackWhereInput
  }

  /**
   * feedback upsert
   */
  export type feedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the feedback to update in case it exists.
     */
    where: feedbackWhereUniqueInput
    /**
     * In case the feedback found by the `where` argument doesn't exist, create a new feedback with this data.
     */
    create: XOR<feedbackCreateInput, feedbackUncheckedCreateInput>
    /**
     * In case the feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feedbackUpdateInput, feedbackUncheckedUpdateInput>
  }

  /**
   * feedback delete
   */
  export type feedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    /**
     * Filter which feedback to delete.
     */
    where: feedbackWhereUniqueInput
  }

  /**
   * feedback deleteMany
   */
  export type feedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedbacks to delete
     */
    where?: feedbackWhereInput
  }

  /**
   * feedback findRaw
   */
  export type feedbackFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * feedback aggregateRaw
   */
  export type feedbackAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * feedback without action
   */
  export type feedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
  }


  /**
   * Model levels
   */

  export type AggregateLevels = {
    _count: LevelsCountAggregateOutputType | null
    _avg: LevelsAvgAggregateOutputType | null
    _sum: LevelsSumAggregateOutputType | null
    _min: LevelsMinAggregateOutputType | null
    _max: LevelsMaxAggregateOutputType | null
  }

  export type LevelsAvgAggregateOutputType = {
    order: number | null
    requiredBrandsExplored: number | null
    requiredAnswers: number | null
  }

  export type LevelsSumAggregateOutputType = {
    order: number | null
    requiredBrandsExplored: number | null
    requiredAnswers: number | null
  }

  export type LevelsMinAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    requiredBrandsExplored: number | null
    requiredAnswers: number | null
    questionnaireId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    order: number | null
    requiredBrandsExplored: number | null
    requiredAnswers: number | null
    questionnaireId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelsCountAggregateOutputType = {
    id: number
    name: number
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    questionnaireId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevelsAvgAggregateInputType = {
    order?: true
    requiredBrandsExplored?: true
    requiredAnswers?: true
  }

  export type LevelsSumAggregateInputType = {
    order?: true
    requiredBrandsExplored?: true
    requiredAnswers?: true
  }

  export type LevelsMinAggregateInputType = {
    id?: true
    name?: true
    order?: true
    requiredBrandsExplored?: true
    requiredAnswers?: true
    questionnaireId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelsMaxAggregateInputType = {
    id?: true
    name?: true
    order?: true
    requiredBrandsExplored?: true
    requiredAnswers?: true
    questionnaireId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelsCountAggregateInputType = {
    id?: true
    name?: true
    order?: true
    requiredBrandsExplored?: true
    requiredAnswers?: true
    questionnaireId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which levels to aggregate.
     */
    where?: levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelsOrderByWithRelationInput | levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned levels
    **/
    _count?: true | LevelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelsMaxAggregateInputType
  }

  export type GetLevelsAggregateType<T extends LevelsAggregateArgs> = {
        [P in keyof T & keyof AggregateLevels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevels[P]>
      : GetScalarType<T[P], AggregateLevels[P]>
  }




  export type levelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: levelsWhereInput
    orderBy?: levelsOrderByWithAggregationInput | levelsOrderByWithAggregationInput[]
    by: LevelsScalarFieldEnum[] | LevelsScalarFieldEnum
    having?: levelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelsCountAggregateInputType | true
    _avg?: LevelsAvgAggregateInputType
    _sum?: LevelsSumAggregateInputType
    _min?: LevelsMinAggregateInputType
    _max?: LevelsMaxAggregateInputType
  }

  export type LevelsGroupByOutputType = {
    id: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    questionnaireId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LevelsCountAggregateOutputType | null
    _avg: LevelsAvgAggregateOutputType | null
    _sum: LevelsSumAggregateOutputType | null
    _min: LevelsMinAggregateOutputType | null
    _max: LevelsMaxAggregateOutputType | null
  }

  type GetLevelsGroupByPayload<T extends levelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelsGroupByOutputType[P]>
            : GetScalarType<T[P], LevelsGroupByOutputType[P]>
        }
      >
    >


  export type levelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    order?: boolean
    requiredBrandsExplored?: boolean
    requiredAnswers?: boolean
    questionnaireId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questionnaire?: boolean | levels$questionnaireArgs<ExtArgs>
    benefits?: boolean | levels$benefitsArgs<ExtArgs>
    users?: boolean | levels$usersArgs<ExtArgs>
    _count?: boolean | LevelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["levels"]>


  export type levelsSelectScalar = {
    id?: boolean
    name?: boolean
    order?: boolean
    requiredBrandsExplored?: boolean
    requiredAnswers?: boolean
    questionnaireId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type levelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionnaire?: boolean | levels$questionnaireArgs<ExtArgs>
    benefits?: boolean | levels$benefitsArgs<ExtArgs>
    users?: boolean | levels$usersArgs<ExtArgs>
    _count?: boolean | LevelsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $levelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "levels"
    objects: {
      questionnaire: Prisma.$questionnairesPayload<ExtArgs> | null
      benefits: Prisma.$benefitsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      order: number
      requiredBrandsExplored: number
      requiredAnswers: number
      questionnaireId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["levels"]>
    composites: {}
  }

  type levelsGetPayload<S extends boolean | null | undefined | levelsDefaultArgs> = $Result.GetResult<Prisma.$levelsPayload, S>

  type levelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<levelsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LevelsCountAggregateInputType | true
    }

  export interface levelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['levels'], meta: { name: 'levels' } }
    /**
     * Find zero or one Levels that matches the filter.
     * @param {levelsFindUniqueArgs} args - Arguments to find a Levels
     * @example
     * // Get one Levels
     * const levels = await prisma.levels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends levelsFindUniqueArgs>(args: SelectSubset<T, levelsFindUniqueArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Levels that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {levelsFindUniqueOrThrowArgs} args - Arguments to find a Levels
     * @example
     * // Get one Levels
     * const levels = await prisma.levels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends levelsFindUniqueOrThrowArgs>(args: SelectSubset<T, levelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsFindFirstArgs} args - Arguments to find a Levels
     * @example
     * // Get one Levels
     * const levels = await prisma.levels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends levelsFindFirstArgs>(args?: SelectSubset<T, levelsFindFirstArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Levels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsFindFirstOrThrowArgs} args - Arguments to find a Levels
     * @example
     * // Get one Levels
     * const levels = await prisma.levels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends levelsFindFirstOrThrowArgs>(args?: SelectSubset<T, levelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.levels.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.levels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelsWithIdOnly = await prisma.levels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends levelsFindManyArgs>(args?: SelectSubset<T, levelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Levels.
     * @param {levelsCreateArgs} args - Arguments to create a Levels.
     * @example
     * // Create one Levels
     * const Levels = await prisma.levels.create({
     *   data: {
     *     // ... data to create a Levels
     *   }
     * })
     * 
     */
    create<T extends levelsCreateArgs>(args: SelectSubset<T, levelsCreateArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Levels.
     * @param {levelsCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const levels = await prisma.levels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends levelsCreateManyArgs>(args?: SelectSubset<T, levelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Levels.
     * @param {levelsDeleteArgs} args - Arguments to delete one Levels.
     * @example
     * // Delete one Levels
     * const Levels = await prisma.levels.delete({
     *   where: {
     *     // ... filter to delete one Levels
     *   }
     * })
     * 
     */
    delete<T extends levelsDeleteArgs>(args: SelectSubset<T, levelsDeleteArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Levels.
     * @param {levelsUpdateArgs} args - Arguments to update one Levels.
     * @example
     * // Update one Levels
     * const levels = await prisma.levels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends levelsUpdateArgs>(args: SelectSubset<T, levelsUpdateArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Levels.
     * @param {levelsDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.levels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends levelsDeleteManyArgs>(args?: SelectSubset<T, levelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const levels = await prisma.levels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends levelsUpdateManyArgs>(args: SelectSubset<T, levelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Levels.
     * @param {levelsUpsertArgs} args - Arguments to update or create a Levels.
     * @example
     * // Update or create a Levels
     * const levels = await prisma.levels.upsert({
     *   create: {
     *     // ... data to create a Levels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Levels we want to update
     *   }
     * })
     */
    upsert<T extends levelsUpsertArgs>(args: SelectSubset<T, levelsUpsertArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Levels that matches the filter.
     * @param {levelsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const levels = await prisma.levels.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: levelsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Levels.
     * @param {levelsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const levels = await prisma.levels.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: levelsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.levels.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends levelsCountArgs>(
      args?: Subset<T, levelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelsAggregateArgs>(args: Subset<T, LevelsAggregateArgs>): Prisma.PrismaPromise<GetLevelsAggregateType<T>>

    /**
     * Group by Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {levelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends levelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: levelsGroupByArgs['orderBy'] }
        : { orderBy?: levelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, levelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the levels model
   */
  readonly fields: levelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for levels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__levelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questionnaire<T extends levels$questionnaireArgs<ExtArgs> = {}>(args?: Subset<T, levels$questionnaireArgs<ExtArgs>>): Prisma__questionnairesClient<$Result.GetResult<Prisma.$questionnairesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    benefits<T extends levels$benefitsArgs<ExtArgs> = {}>(args?: Subset<T, levels$benefitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$benefitsPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends levels$usersArgs<ExtArgs> = {}>(args?: Subset<T, levels$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the levels model
   */ 
  interface levelsFieldRefs {
    readonly id: FieldRef<"levels", 'String'>
    readonly name: FieldRef<"levels", 'String'>
    readonly order: FieldRef<"levels", 'Int'>
    readonly requiredBrandsExplored: FieldRef<"levels", 'Int'>
    readonly requiredAnswers: FieldRef<"levels", 'Int'>
    readonly questionnaireId: FieldRef<"levels", 'String'>
    readonly createdAt: FieldRef<"levels", 'DateTime'>
    readonly updatedAt: FieldRef<"levels", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * levels findUnique
   */
  export type levelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where: levelsWhereUniqueInput
  }

  /**
   * levels findUniqueOrThrow
   */
  export type levelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where: levelsWhereUniqueInput
  }

  /**
   * levels findFirst
   */
  export type levelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where?: levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelsOrderByWithRelationInput | levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for levels.
     */
    cursor?: levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of levels.
     */
    distinct?: LevelsScalarFieldEnum | LevelsScalarFieldEnum[]
  }

  /**
   * levels findFirstOrThrow
   */
  export type levelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where?: levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelsOrderByWithRelationInput | levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for levels.
     */
    cursor?: levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of levels.
     */
    distinct?: LevelsScalarFieldEnum | LevelsScalarFieldEnum[]
  }

  /**
   * levels findMany
   */
  export type levelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter, which levels to fetch.
     */
    where?: levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of levels to fetch.
     */
    orderBy?: levelsOrderByWithRelationInput | levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing levels.
     */
    cursor?: levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` levels.
     */
    skip?: number
    distinct?: LevelsScalarFieldEnum | LevelsScalarFieldEnum[]
  }

  /**
   * levels create
   */
  export type levelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * The data needed to create a levels.
     */
    data: XOR<levelsCreateInput, levelsUncheckedCreateInput>
  }

  /**
   * levels createMany
   */
  export type levelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many levels.
     */
    data: levelsCreateManyInput | levelsCreateManyInput[]
  }

  /**
   * levels update
   */
  export type levelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * The data needed to update a levels.
     */
    data: XOR<levelsUpdateInput, levelsUncheckedUpdateInput>
    /**
     * Choose, which levels to update.
     */
    where: levelsWhereUniqueInput
  }

  /**
   * levels updateMany
   */
  export type levelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update levels.
     */
    data: XOR<levelsUpdateManyMutationInput, levelsUncheckedUpdateManyInput>
    /**
     * Filter which levels to update
     */
    where?: levelsWhereInput
  }

  /**
   * levels upsert
   */
  export type levelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * The filter to search for the levels to update in case it exists.
     */
    where: levelsWhereUniqueInput
    /**
     * In case the levels found by the `where` argument doesn't exist, create a new levels with this data.
     */
    create: XOR<levelsCreateInput, levelsUncheckedCreateInput>
    /**
     * In case the levels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<levelsUpdateInput, levelsUncheckedUpdateInput>
  }

  /**
   * levels delete
   */
  export type levelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    /**
     * Filter which levels to delete.
     */
    where: levelsWhereUniqueInput
  }

  /**
   * levels deleteMany
   */
  export type levelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which levels to delete
     */
    where?: levelsWhereInput
  }

  /**
   * levels findRaw
   */
  export type levelsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * levels aggregateRaw
   */
  export type levelsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * levels.questionnaire
   */
  export type levels$questionnaireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionnaires
     */
    select?: questionnairesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionnairesInclude<ExtArgs> | null
    where?: questionnairesWhereInput
  }

  /**
   * levels.benefits
   */
  export type levels$benefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the benefits
     */
    select?: benefitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: benefitsInclude<ExtArgs> | null
    where?: benefitsWhereInput
    orderBy?: benefitsOrderByWithRelationInput | benefitsOrderByWithRelationInput[]
    cursor?: benefitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BenefitsScalarFieldEnum | BenefitsScalarFieldEnum[]
  }

  /**
   * levels.users
   */
  export type levels$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * levels without action
   */
  export type levelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    brandsExplored: number | null
    budgetInterval: number | null
  }

  export type UsersSumAggregateOutputType = {
    brandsExplored: number | null
    budgetInterval: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    hasAcceptedTermsAndConditions: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    notificationsToken: string | null
    levelId: string | null
    brandsExplored: number | null
    ownedBrandId: string | null
    foundersReachedLeaderboardId: string | null
    targetGender: $Enums.GenderPreference | null
    budgetInterval: number | null
    superUser: boolean | null
    hasNewForYouBrands: boolean | null
    lastOpened: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    hasAcceptedTermsAndConditions: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    notificationsToken: string | null
    levelId: string | null
    brandsExplored: number | null
    ownedBrandId: string | null
    foundersReachedLeaderboardId: string | null
    targetGender: $Enums.GenderPreference | null
    budgetInterval: number | null
    superUser: boolean | null
    hasNewForYouBrands: boolean | null
    lastOpened: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    myFavourites: number
    hasAcceptedTermsAndConditions: number
    createdAt: number
    updatedAt: number
    name: number
    notificationsToken: number
    forYouBrandsIds: number
    forYouBrandsPoolIds: number
    notInterestedBrandsIds: number
    levelId: number
    brandsExplored: number
    ownedBrandId: number
    foundersReachedLeaderboardId: number
    viewedPitches: number
    targetGender: number
    budgetInterval: number
    deletedBrands: number
    superUser: number
    hasNewForYouBrands: number
    likedPostsIds: number
    lastOpened: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    brandsExplored?: true
    budgetInterval?: true
  }

  export type UsersSumAggregateInputType = {
    brandsExplored?: true
    budgetInterval?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    hasAcceptedTermsAndConditions?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    notificationsToken?: true
    levelId?: true
    brandsExplored?: true
    ownedBrandId?: true
    foundersReachedLeaderboardId?: true
    targetGender?: true
    budgetInterval?: true
    superUser?: true
    hasNewForYouBrands?: true
    lastOpened?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    hasAcceptedTermsAndConditions?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    notificationsToken?: true
    levelId?: true
    brandsExplored?: true
    ownedBrandId?: true
    foundersReachedLeaderboardId?: true
    targetGender?: true
    budgetInterval?: true
    superUser?: true
    hasNewForYouBrands?: true
    lastOpened?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    myFavourites?: true
    hasAcceptedTermsAndConditions?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    notificationsToken?: true
    forYouBrandsIds?: true
    forYouBrandsPoolIds?: true
    notInterestedBrandsIds?: true
    levelId?: true
    brandsExplored?: true
    ownedBrandId?: true
    foundersReachedLeaderboardId?: true
    viewedPitches?: true
    targetGender?: true
    budgetInterval?: true
    deletedBrands?: true
    superUser?: true
    hasNewForYouBrands?: true
    likedPostsIds?: true
    lastOpened?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    myFavourites: JsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt: Date
    updatedAt: Date
    name: string | null
    notificationsToken: string | null
    forYouBrandsIds: string[]
    forYouBrandsPoolIds: string[]
    notInterestedBrandsIds: string[]
    levelId: string | null
    brandsExplored: number
    ownedBrandId: string | null
    foundersReachedLeaderboardId: string | null
    viewedPitches: string[]
    targetGender: $Enums.GenderPreference | null
    budgetInterval: number | null
    deletedBrands: string[]
    superUser: boolean | null
    hasNewForYouBrands: boolean
    likedPostsIds: string[]
    lastOpened: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    myFavourites?: boolean
    hasAcceptedTermsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    notificationsToken?: boolean
    forYouBrandsIds?: boolean
    forYouBrandsPoolIds?: boolean
    notInterestedBrandsIds?: boolean
    levelId?: boolean
    brandsExplored?: boolean
    ownedBrandId?: boolean
    foundersReachedLeaderboardId?: boolean
    viewedPitches?: boolean
    targetGender?: boolean
    budgetInterval?: boolean
    deletedBrands?: boolean
    superUser?: boolean
    hasNewForYouBrands?: boolean
    likedPostsIds?: boolean
    lastOpened?: boolean
    answers?: boolean | users$answersArgs<ExtArgs>
    pitchViews?: boolean | users$pitchViewsArgs<ExtArgs>
    settings?: boolean | users$settingsArgs<ExtArgs>
    ratings?: boolean | users$ratingsArgs<ExtArgs>
    forYouBrands?: boolean | users$forYouBrandsArgs<ExtArgs>
    forYouBrandsPool?: boolean | users$forYouBrandsPoolArgs<ExtArgs>
    notInterestedBrands?: boolean | users$notInterestedBrandsArgs<ExtArgs>
    linkVisits?: boolean | users$linkVisitsArgs<ExtArgs>
    brandScreenTimes?: boolean | users$brandScreenTimesArgs<ExtArgs>
    termsAndConditions?: boolean | users$termsAndConditionsArgs<ExtArgs>
    feedbacks?: boolean | users$feedbacksArgs<ExtArgs>
    level?: boolean | users$levelArgs<ExtArgs>
    ownedBrand?: boolean | users$ownedBrandArgs<ExtArgs>
    productionSubmissions?: boolean | users$productionSubmissionsArgs<ExtArgs>
    foundersReachedLeaderboard?: boolean | users$foundersReachedLeaderboardArgs<ExtArgs>
    dealCodes?: boolean | users$dealCodesArgs<ExtArgs>
    brandUnlockHistory?: boolean | users$brandUnlockHistoryArgs<ExtArgs>
    categoryChoices?: boolean | users$categoryChoicesArgs<ExtArgs>
    likedPosts?: boolean | users$likedPostsArgs<ExtArgs>
    pushNotificationHistory?: boolean | users$pushNotificationHistoryArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    myFavourites?: boolean
    hasAcceptedTermsAndConditions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    notificationsToken?: boolean
    forYouBrandsIds?: boolean
    forYouBrandsPoolIds?: boolean
    notInterestedBrandsIds?: boolean
    levelId?: boolean
    brandsExplored?: boolean
    ownedBrandId?: boolean
    foundersReachedLeaderboardId?: boolean
    viewedPitches?: boolean
    targetGender?: boolean
    budgetInterval?: boolean
    deletedBrands?: boolean
    superUser?: boolean
    hasNewForYouBrands?: boolean
    likedPostsIds?: boolean
    lastOpened?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | users$answersArgs<ExtArgs>
    pitchViews?: boolean | users$pitchViewsArgs<ExtArgs>
    settings?: boolean | users$settingsArgs<ExtArgs>
    ratings?: boolean | users$ratingsArgs<ExtArgs>
    forYouBrands?: boolean | users$forYouBrandsArgs<ExtArgs>
    forYouBrandsPool?: boolean | users$forYouBrandsPoolArgs<ExtArgs>
    notInterestedBrands?: boolean | users$notInterestedBrandsArgs<ExtArgs>
    linkVisits?: boolean | users$linkVisitsArgs<ExtArgs>
    brandScreenTimes?: boolean | users$brandScreenTimesArgs<ExtArgs>
    termsAndConditions?: boolean | users$termsAndConditionsArgs<ExtArgs>
    feedbacks?: boolean | users$feedbacksArgs<ExtArgs>
    level?: boolean | users$levelArgs<ExtArgs>
    ownedBrand?: boolean | users$ownedBrandArgs<ExtArgs>
    productionSubmissions?: boolean | users$productionSubmissionsArgs<ExtArgs>
    foundersReachedLeaderboard?: boolean | users$foundersReachedLeaderboardArgs<ExtArgs>
    dealCodes?: boolean | users$dealCodesArgs<ExtArgs>
    brandUnlockHistory?: boolean | users$brandUnlockHistoryArgs<ExtArgs>
    categoryChoices?: boolean | users$categoryChoicesArgs<ExtArgs>
    likedPosts?: boolean | users$likedPostsArgs<ExtArgs>
    pushNotificationHistory?: boolean | users$pushNotificationHistoryArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      answers: Prisma.$answersPayload<ExtArgs>[]
      pitchViews: Prisma.$pitch_viewsPayload<ExtArgs>[]
      settings: Prisma.$settingsPayload<ExtArgs> | null
      ratings: Prisma.$ratingsPayload<ExtArgs>[]
      forYouBrands: Prisma.$brandsPayload<ExtArgs>[]
      forYouBrandsPool: Prisma.$brandsPayload<ExtArgs>[]
      notInterestedBrands: Prisma.$brandsPayload<ExtArgs>[]
      linkVisits: Prisma.$link_visitsPayload<ExtArgs>[]
      brandScreenTimes: Prisma.$brand_screen_timesPayload<ExtArgs>[]
      termsAndConditions: Prisma.$terms_and_conditionsPayload<ExtArgs> | null
      feedbacks: Prisma.$feedbackPayload<ExtArgs>[]
      level: Prisma.$levelsPayload<ExtArgs> | null
      ownedBrand: Prisma.$brandsPayload<ExtArgs> | null
      productionSubmissions: Prisma.$production_submissionsPayload<ExtArgs>[]
      foundersReachedLeaderboard: Prisma.$foundersReachedLeaderboardPayload<ExtArgs> | null
      dealCodes: Prisma.$deal_codesPayload<ExtArgs>[]
      brandUnlockHistory: Prisma.$unlocked_brands_historyPayload<ExtArgs>[]
      categoryChoices: Prisma.$category_choicesPayload<ExtArgs>[]
      likedPosts: Prisma.$postsPayload<ExtArgs>[]
      pushNotificationHistory: Prisma.$push_notification_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      myFavourites: Prisma.JsonValue[]
      hasAcceptedTermsAndConditions: boolean
      createdAt: Date
      updatedAt: Date
      name: string | null
      notificationsToken: string | null
      forYouBrandsIds: string[]
      forYouBrandsPoolIds: string[]
      notInterestedBrandsIds: string[]
      levelId: string | null
      brandsExplored: number
      ownedBrandId: string | null
      foundersReachedLeaderboardId: string | null
      viewedPitches: string[]
      targetGender: $Enums.GenderPreference | null
      budgetInterval: number | null
      deletedBrands: string[]
      superUser: boolean | null
      hasNewForYouBrands: boolean
      likedPostsIds: string[]
      lastOpened: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users = await prisma.users.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: usersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users.
     * @param {usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users = await prisma.users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: usersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends users$answersArgs<ExtArgs> = {}>(args?: Subset<T, users$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany"> | Null>
    pitchViews<T extends users$pitchViewsArgs<ExtArgs> = {}>(args?: Subset<T, users$pitchViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pitch_viewsPayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends users$settingsArgs<ExtArgs> = {}>(args?: Subset<T, users$settingsArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ratings<T extends users$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, users$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ratingsPayload<ExtArgs>, T, "findMany"> | Null>
    forYouBrands<T extends users$forYouBrandsArgs<ExtArgs> = {}>(args?: Subset<T, users$forYouBrandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany"> | Null>
    forYouBrandsPool<T extends users$forYouBrandsPoolArgs<ExtArgs> = {}>(args?: Subset<T, users$forYouBrandsPoolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany"> | Null>
    notInterestedBrands<T extends users$notInterestedBrandsArgs<ExtArgs> = {}>(args?: Subset<T, users$notInterestedBrandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany"> | Null>
    linkVisits<T extends users$linkVisitsArgs<ExtArgs> = {}>(args?: Subset<T, users$linkVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$link_visitsPayload<ExtArgs>, T, "findMany"> | Null>
    brandScreenTimes<T extends users$brandScreenTimesArgs<ExtArgs> = {}>(args?: Subset<T, users$brandScreenTimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brand_screen_timesPayload<ExtArgs>, T, "findMany"> | Null>
    termsAndConditions<T extends users$termsAndConditionsArgs<ExtArgs> = {}>(args?: Subset<T, users$termsAndConditionsArgs<ExtArgs>>): Prisma__terms_and_conditionsClient<$Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    feedbacks<T extends users$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, users$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbackPayload<ExtArgs>, T, "findMany"> | Null>
    level<T extends users$levelArgs<ExtArgs> = {}>(args?: Subset<T, users$levelArgs<ExtArgs>>): Prisma__levelsClient<$Result.GetResult<Prisma.$levelsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ownedBrand<T extends users$ownedBrandArgs<ExtArgs> = {}>(args?: Subset<T, users$ownedBrandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    productionSubmissions<T extends users$productionSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, users$productionSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$production_submissionsPayload<ExtArgs>, T, "findMany"> | Null>
    foundersReachedLeaderboard<T extends users$foundersReachedLeaderboardArgs<ExtArgs> = {}>(args?: Subset<T, users$foundersReachedLeaderboardArgs<ExtArgs>>): Prisma__foundersReachedLeaderboardClient<$Result.GetResult<Prisma.$foundersReachedLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dealCodes<T extends users$dealCodesArgs<ExtArgs> = {}>(args?: Subset<T, users$dealCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "findMany"> | Null>
    brandUnlockHistory<T extends users$brandUnlockHistoryArgs<ExtArgs> = {}>(args?: Subset<T, users$brandUnlockHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$unlocked_brands_historyPayload<ExtArgs>, T, "findMany"> | Null>
    categoryChoices<T extends users$categoryChoicesArgs<ExtArgs> = {}>(args?: Subset<T, users$categoryChoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$category_choicesPayload<ExtArgs>, T, "findMany"> | Null>
    likedPosts<T extends users$likedPostsArgs<ExtArgs> = {}>(args?: Subset<T, users$likedPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findMany"> | Null>
    pushNotificationHistory<T extends users$pushNotificationHistoryArgs<ExtArgs> = {}>(args?: Subset<T, users$pushNotificationHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$push_notification_historyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly myFavourites: FieldRef<"users", 'Json[]'>
    readonly hasAcceptedTermsAndConditions: FieldRef<"users", 'Boolean'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
    readonly name: FieldRef<"users", 'String'>
    readonly notificationsToken: FieldRef<"users", 'String'>
    readonly forYouBrandsIds: FieldRef<"users", 'String[]'>
    readonly forYouBrandsPoolIds: FieldRef<"users", 'String[]'>
    readonly notInterestedBrandsIds: FieldRef<"users", 'String[]'>
    readonly levelId: FieldRef<"users", 'String'>
    readonly brandsExplored: FieldRef<"users", 'Int'>
    readonly ownedBrandId: FieldRef<"users", 'String'>
    readonly foundersReachedLeaderboardId: FieldRef<"users", 'String'>
    readonly viewedPitches: FieldRef<"users", 'String[]'>
    readonly targetGender: FieldRef<"users", 'GenderPreference'>
    readonly budgetInterval: FieldRef<"users", 'Int'>
    readonly deletedBrands: FieldRef<"users", 'String[]'>
    readonly superUser: FieldRef<"users", 'Boolean'>
    readonly hasNewForYouBrands: FieldRef<"users", 'Boolean'>
    readonly likedPostsIds: FieldRef<"users", 'String[]'>
    readonly lastOpened: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users findRaw
   */
  export type usersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users aggregateRaw
   */
  export type usersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users.answers
   */
  export type users$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    where?: answersWhereInput
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    cursor?: answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * users.pitchViews
   */
  export type users$pitchViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pitch_views
     */
    select?: pitch_viewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pitch_viewsInclude<ExtArgs> | null
    where?: pitch_viewsWhereInput
    orderBy?: pitch_viewsOrderByWithRelationInput | pitch_viewsOrderByWithRelationInput[]
    cursor?: pitch_viewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pitch_viewsScalarFieldEnum | Pitch_viewsScalarFieldEnum[]
  }

  /**
   * users.settings
   */
  export type users$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: settingsInclude<ExtArgs> | null
    where?: settingsWhereInput
  }

  /**
   * users.ratings
   */
  export type users$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ratings
     */
    select?: ratingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ratingsInclude<ExtArgs> | null
    where?: ratingsWhereInput
    orderBy?: ratingsOrderByWithRelationInput | ratingsOrderByWithRelationInput[]
    cursor?: ratingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingsScalarFieldEnum | RatingsScalarFieldEnum[]
  }

  /**
   * users.forYouBrands
   */
  export type users$forYouBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    cursor?: brandsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * users.forYouBrandsPool
   */
  export type users$forYouBrandsPoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    cursor?: brandsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * users.notInterestedBrands
   */
  export type users$notInterestedBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    cursor?: brandsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * users.linkVisits
   */
  export type users$linkVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the link_visits
     */
    select?: link_visitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: link_visitsInclude<ExtArgs> | null
    where?: link_visitsWhereInput
    orderBy?: link_visitsOrderByWithRelationInput | link_visitsOrderByWithRelationInput[]
    cursor?: link_visitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Link_visitsScalarFieldEnum | Link_visitsScalarFieldEnum[]
  }

  /**
   * users.brandScreenTimes
   */
  export type users$brandScreenTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand_screen_times
     */
    select?: brand_screen_timesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brand_screen_timesInclude<ExtArgs> | null
    where?: brand_screen_timesWhereInput
    orderBy?: brand_screen_timesOrderByWithRelationInput | brand_screen_timesOrderByWithRelationInput[]
    cursor?: brand_screen_timesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Brand_screen_timesScalarFieldEnum | Brand_screen_timesScalarFieldEnum[]
  }

  /**
   * users.termsAndConditions
   */
  export type users$termsAndConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null
    where?: terms_and_conditionsWhereInput
  }

  /**
   * users.feedbacks
   */
  export type users$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedback
     */
    select?: feedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbackInclude<ExtArgs> | null
    where?: feedbackWhereInput
    orderBy?: feedbackOrderByWithRelationInput | feedbackOrderByWithRelationInput[]
    cursor?: feedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * users.level
   */
  export type users$levelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the levels
     */
    select?: levelsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: levelsInclude<ExtArgs> | null
    where?: levelsWhereInput
  }

  /**
   * users.ownedBrand
   */
  export type users$ownedBrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * users.productionSubmissions
   */
  export type users$productionSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the production_submissions
     */
    select?: production_submissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: production_submissionsInclude<ExtArgs> | null
    where?: production_submissionsWhereInput
    orderBy?: production_submissionsOrderByWithRelationInput | production_submissionsOrderByWithRelationInput[]
    cursor?: production_submissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Production_submissionsScalarFieldEnum | Production_submissionsScalarFieldEnum[]
  }

  /**
   * users.foundersReachedLeaderboard
   */
  export type users$foundersReachedLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the foundersReachedLeaderboard
     */
    select?: foundersReachedLeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: foundersReachedLeaderboardInclude<ExtArgs> | null
    where?: foundersReachedLeaderboardWhereInput
  }

  /**
   * users.dealCodes
   */
  export type users$dealCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    where?: deal_codesWhereInput
    orderBy?: deal_codesOrderByWithRelationInput | deal_codesOrderByWithRelationInput[]
    cursor?: deal_codesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Deal_codesScalarFieldEnum | Deal_codesScalarFieldEnum[]
  }

  /**
   * users.brandUnlockHistory
   */
  export type users$brandUnlockHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the unlocked_brands_history
     */
    select?: unlocked_brands_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: unlocked_brands_historyInclude<ExtArgs> | null
    where?: unlocked_brands_historyWhereInput
    orderBy?: unlocked_brands_historyOrderByWithRelationInput | unlocked_brands_historyOrderByWithRelationInput[]
    cursor?: unlocked_brands_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Unlocked_brands_historyScalarFieldEnum | Unlocked_brands_historyScalarFieldEnum[]
  }

  /**
   * users.categoryChoices
   */
  export type users$categoryChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category_choices
     */
    select?: category_choicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: category_choicesInclude<ExtArgs> | null
    where?: category_choicesWhereInput
    orderBy?: category_choicesOrderByWithRelationInput | category_choicesOrderByWithRelationInput[]
    cursor?: category_choicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Category_choicesScalarFieldEnum | Category_choicesScalarFieldEnum[]
  }

  /**
   * users.likedPosts
   */
  export type users$likedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    where?: postsWhereInput
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    cursor?: postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * users.pushNotificationHistory
   */
  export type users$pushNotificationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the push_notification_history
     */
    select?: push_notification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: push_notification_historyInclude<ExtArgs> | null
    where?: push_notification_historyWhereInput
    orderBy?: push_notification_historyOrderByWithRelationInput | push_notification_historyOrderByWithRelationInput[]
    cursor?: push_notification_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Push_notification_historyScalarFieldEnum | Push_notification_historyScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model deal_codes
   */

  export type AggregateDeal_codes = {
    _count: Deal_codesCountAggregateOutputType | null
    _min: Deal_codesMinAggregateOutputType | null
    _max: Deal_codesMaxAggregateOutputType | null
  }

  export type Deal_codesMinAggregateOutputType = {
    id: string | null
    code: string | null
    isUsed: boolean | null
    userId: string | null
    groupId: string | null
    userExpireDate: Date | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Deal_codesMaxAggregateOutputType = {
    id: string | null
    code: string | null
    isUsed: boolean | null
    userId: string | null
    groupId: string | null
    userExpireDate: Date | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Deal_codesCountAggregateOutputType = {
    id: number
    code: number
    isUsed: number
    userId: number
    groupId: number
    userExpireDate: number
    unlockedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Deal_codesMinAggregateInputType = {
    id?: true
    code?: true
    isUsed?: true
    userId?: true
    groupId?: true
    userExpireDate?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Deal_codesMaxAggregateInputType = {
    id?: true
    code?: true
    isUsed?: true
    userId?: true
    groupId?: true
    userExpireDate?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Deal_codesCountAggregateInputType = {
    id?: true
    code?: true
    isUsed?: true
    userId?: true
    groupId?: true
    userExpireDate?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Deal_codesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deal_codes to aggregate.
     */
    where?: deal_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deal_codes to fetch.
     */
    orderBy?: deal_codesOrderByWithRelationInput | deal_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deal_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deal_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deal_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deal_codes
    **/
    _count?: true | Deal_codesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Deal_codesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Deal_codesMaxAggregateInputType
  }

  export type GetDeal_codesAggregateType<T extends Deal_codesAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal_codes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal_codes[P]>
      : GetScalarType<T[P], AggregateDeal_codes[P]>
  }




  export type deal_codesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deal_codesWhereInput
    orderBy?: deal_codesOrderByWithAggregationInput | deal_codesOrderByWithAggregationInput[]
    by: Deal_codesScalarFieldEnum[] | Deal_codesScalarFieldEnum
    having?: deal_codesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Deal_codesCountAggregateInputType | true
    _min?: Deal_codesMinAggregateInputType
    _max?: Deal_codesMaxAggregateInputType
  }

  export type Deal_codesGroupByOutputType = {
    id: string
    code: string
    isUsed: boolean
    userId: string | null
    groupId: string
    userExpireDate: Date | null
    unlockedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Deal_codesCountAggregateOutputType | null
    _min: Deal_codesMinAggregateOutputType | null
    _max: Deal_codesMaxAggregateOutputType | null
  }

  type GetDeal_codesGroupByPayload<T extends deal_codesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Deal_codesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Deal_codesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Deal_codesGroupByOutputType[P]>
            : GetScalarType<T[P], Deal_codesGroupByOutputType[P]>
        }
      >
    >


  export type deal_codesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    isUsed?: boolean
    userId?: boolean
    groupId?: boolean
    userExpireDate?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | deal_codes$userArgs<ExtArgs>
    group?: boolean | deal_code_groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal_codes"]>


  export type deal_codesSelectScalar = {
    id?: boolean
    code?: boolean
    isUsed?: boolean
    userId?: boolean
    groupId?: boolean
    userExpireDate?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type deal_codesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | deal_codes$userArgs<ExtArgs>
    group?: boolean | deal_code_groupsDefaultArgs<ExtArgs>
  }

  export type $deal_codesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "deal_codes"
    objects: {
      user: Prisma.$usersPayload<ExtArgs> | null
      group: Prisma.$deal_code_groupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      isUsed: boolean
      userId: string | null
      groupId: string
      userExpireDate: Date | null
      unlockedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deal_codes"]>
    composites: {}
  }

  type deal_codesGetPayload<S extends boolean | null | undefined | deal_codesDefaultArgs> = $Result.GetResult<Prisma.$deal_codesPayload, S>

  type deal_codesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<deal_codesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Deal_codesCountAggregateInputType | true
    }

  export interface deal_codesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['deal_codes'], meta: { name: 'deal_codes' } }
    /**
     * Find zero or one Deal_codes that matches the filter.
     * @param {deal_codesFindUniqueArgs} args - Arguments to find a Deal_codes
     * @example
     * // Get one Deal_codes
     * const deal_codes = await prisma.deal_codes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deal_codesFindUniqueArgs>(args: SelectSubset<T, deal_codesFindUniqueArgs<ExtArgs>>): Prisma__deal_codesClient<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deal_codes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {deal_codesFindUniqueOrThrowArgs} args - Arguments to find a Deal_codes
     * @example
     * // Get one Deal_codes
     * const deal_codes = await prisma.deal_codes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deal_codesFindUniqueOrThrowArgs>(args: SelectSubset<T, deal_codesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deal_codesClient<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deal_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_codesFindFirstArgs} args - Arguments to find a Deal_codes
     * @example
     * // Get one Deal_codes
     * const deal_codes = await prisma.deal_codes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deal_codesFindFirstArgs>(args?: SelectSubset<T, deal_codesFindFirstArgs<ExtArgs>>): Prisma__deal_codesClient<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deal_codes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_codesFindFirstOrThrowArgs} args - Arguments to find a Deal_codes
     * @example
     * // Get one Deal_codes
     * const deal_codes = await prisma.deal_codes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deal_codesFindFirstOrThrowArgs>(args?: SelectSubset<T, deal_codesFindFirstOrThrowArgs<ExtArgs>>): Prisma__deal_codesClient<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deal_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_codesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deal_codes
     * const deal_codes = await prisma.deal_codes.findMany()
     * 
     * // Get first 10 Deal_codes
     * const deal_codes = await prisma.deal_codes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deal_codesWithIdOnly = await prisma.deal_codes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deal_codesFindManyArgs>(args?: SelectSubset<T, deal_codesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deal_codes.
     * @param {deal_codesCreateArgs} args - Arguments to create a Deal_codes.
     * @example
     * // Create one Deal_codes
     * const Deal_codes = await prisma.deal_codes.create({
     *   data: {
     *     // ... data to create a Deal_codes
     *   }
     * })
     * 
     */
    create<T extends deal_codesCreateArgs>(args: SelectSubset<T, deal_codesCreateArgs<ExtArgs>>): Prisma__deal_codesClient<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deal_codes.
     * @param {deal_codesCreateManyArgs} args - Arguments to create many Deal_codes.
     * @example
     * // Create many Deal_codes
     * const deal_codes = await prisma.deal_codes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deal_codesCreateManyArgs>(args?: SelectSubset<T, deal_codesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deal_codes.
     * @param {deal_codesDeleteArgs} args - Arguments to delete one Deal_codes.
     * @example
     * // Delete one Deal_codes
     * const Deal_codes = await prisma.deal_codes.delete({
     *   where: {
     *     // ... filter to delete one Deal_codes
     *   }
     * })
     * 
     */
    delete<T extends deal_codesDeleteArgs>(args: SelectSubset<T, deal_codesDeleteArgs<ExtArgs>>): Prisma__deal_codesClient<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deal_codes.
     * @param {deal_codesUpdateArgs} args - Arguments to update one Deal_codes.
     * @example
     * // Update one Deal_codes
     * const deal_codes = await prisma.deal_codes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deal_codesUpdateArgs>(args: SelectSubset<T, deal_codesUpdateArgs<ExtArgs>>): Prisma__deal_codesClient<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deal_codes.
     * @param {deal_codesDeleteManyArgs} args - Arguments to filter Deal_codes to delete.
     * @example
     * // Delete a few Deal_codes
     * const { count } = await prisma.deal_codes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deal_codesDeleteManyArgs>(args?: SelectSubset<T, deal_codesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deal_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_codesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deal_codes
     * const deal_codes = await prisma.deal_codes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deal_codesUpdateManyArgs>(args: SelectSubset<T, deal_codesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deal_codes.
     * @param {deal_codesUpsertArgs} args - Arguments to update or create a Deal_codes.
     * @example
     * // Update or create a Deal_codes
     * const deal_codes = await prisma.deal_codes.upsert({
     *   create: {
     *     // ... data to create a Deal_codes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal_codes we want to update
     *   }
     * })
     */
    upsert<T extends deal_codesUpsertArgs>(args: SelectSubset<T, deal_codesUpsertArgs<ExtArgs>>): Prisma__deal_codesClient<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Deal_codes that matches the filter.
     * @param {deal_codesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const deal_codes = await prisma.deal_codes.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: deal_codesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Deal_codes.
     * @param {deal_codesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const deal_codes = await prisma.deal_codes.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: deal_codesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Deal_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_codesCountArgs} args - Arguments to filter Deal_codes to count.
     * @example
     * // Count the number of Deal_codes
     * const count = await prisma.deal_codes.count({
     *   where: {
     *     // ... the filter for the Deal_codes we want to count
     *   }
     * })
    **/
    count<T extends deal_codesCountArgs>(
      args?: Subset<T, deal_codesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Deal_codesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Deal_codesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Deal_codesAggregateArgs>(args: Subset<T, Deal_codesAggregateArgs>): Prisma.PrismaPromise<GetDeal_codesAggregateType<T>>

    /**
     * Group by Deal_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_codesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deal_codesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deal_codesGroupByArgs['orderBy'] }
        : { orderBy?: deal_codesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deal_codesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeal_codesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the deal_codes model
   */
  readonly fields: deal_codesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for deal_codes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deal_codesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends deal_codes$userArgs<ExtArgs> = {}>(args?: Subset<T, deal_codes$userArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    group<T extends deal_code_groupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, deal_code_groupsDefaultArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the deal_codes model
   */ 
  interface deal_codesFieldRefs {
    readonly id: FieldRef<"deal_codes", 'String'>
    readonly code: FieldRef<"deal_codes", 'String'>
    readonly isUsed: FieldRef<"deal_codes", 'Boolean'>
    readonly userId: FieldRef<"deal_codes", 'String'>
    readonly groupId: FieldRef<"deal_codes", 'String'>
    readonly userExpireDate: FieldRef<"deal_codes", 'DateTime'>
    readonly unlockedAt: FieldRef<"deal_codes", 'DateTime'>
    readonly createdAt: FieldRef<"deal_codes", 'DateTime'>
    readonly updatedAt: FieldRef<"deal_codes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * deal_codes findUnique
   */
  export type deal_codesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * Filter, which deal_codes to fetch.
     */
    where: deal_codesWhereUniqueInput
  }

  /**
   * deal_codes findUniqueOrThrow
   */
  export type deal_codesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * Filter, which deal_codes to fetch.
     */
    where: deal_codesWhereUniqueInput
  }

  /**
   * deal_codes findFirst
   */
  export type deal_codesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * Filter, which deal_codes to fetch.
     */
    where?: deal_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deal_codes to fetch.
     */
    orderBy?: deal_codesOrderByWithRelationInput | deal_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deal_codes.
     */
    cursor?: deal_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deal_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deal_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deal_codes.
     */
    distinct?: Deal_codesScalarFieldEnum | Deal_codesScalarFieldEnum[]
  }

  /**
   * deal_codes findFirstOrThrow
   */
  export type deal_codesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * Filter, which deal_codes to fetch.
     */
    where?: deal_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deal_codes to fetch.
     */
    orderBy?: deal_codesOrderByWithRelationInput | deal_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deal_codes.
     */
    cursor?: deal_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deal_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deal_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deal_codes.
     */
    distinct?: Deal_codesScalarFieldEnum | Deal_codesScalarFieldEnum[]
  }

  /**
   * deal_codes findMany
   */
  export type deal_codesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * Filter, which deal_codes to fetch.
     */
    where?: deal_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deal_codes to fetch.
     */
    orderBy?: deal_codesOrderByWithRelationInput | deal_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deal_codes.
     */
    cursor?: deal_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deal_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deal_codes.
     */
    skip?: number
    distinct?: Deal_codesScalarFieldEnum | Deal_codesScalarFieldEnum[]
  }

  /**
   * deal_codes create
   */
  export type deal_codesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * The data needed to create a deal_codes.
     */
    data: XOR<deal_codesCreateInput, deal_codesUncheckedCreateInput>
  }

  /**
   * deal_codes createMany
   */
  export type deal_codesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many deal_codes.
     */
    data: deal_codesCreateManyInput | deal_codesCreateManyInput[]
  }

  /**
   * deal_codes update
   */
  export type deal_codesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * The data needed to update a deal_codes.
     */
    data: XOR<deal_codesUpdateInput, deal_codesUncheckedUpdateInput>
    /**
     * Choose, which deal_codes to update.
     */
    where: deal_codesWhereUniqueInput
  }

  /**
   * deal_codes updateMany
   */
  export type deal_codesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update deal_codes.
     */
    data: XOR<deal_codesUpdateManyMutationInput, deal_codesUncheckedUpdateManyInput>
    /**
     * Filter which deal_codes to update
     */
    where?: deal_codesWhereInput
  }

  /**
   * deal_codes upsert
   */
  export type deal_codesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * The filter to search for the deal_codes to update in case it exists.
     */
    where: deal_codesWhereUniqueInput
    /**
     * In case the deal_codes found by the `where` argument doesn't exist, create a new deal_codes with this data.
     */
    create: XOR<deal_codesCreateInput, deal_codesUncheckedCreateInput>
    /**
     * In case the deal_codes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deal_codesUpdateInput, deal_codesUncheckedUpdateInput>
  }

  /**
   * deal_codes delete
   */
  export type deal_codesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    /**
     * Filter which deal_codes to delete.
     */
    where: deal_codesWhereUniqueInput
  }

  /**
   * deal_codes deleteMany
   */
  export type deal_codesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deal_codes to delete
     */
    where?: deal_codesWhereInput
  }

  /**
   * deal_codes findRaw
   */
  export type deal_codesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * deal_codes aggregateRaw
   */
  export type deal_codesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * deal_codes.user
   */
  export type deal_codes$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * deal_codes without action
   */
  export type deal_codesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
  }


  /**
   * Model deal_code_groups
   */

  export type AggregateDeal_code_groups = {
    _count: Deal_code_groupsCountAggregateOutputType | null
    _min: Deal_code_groupsMinAggregateOutputType | null
    _max: Deal_code_groupsMaxAggregateOutputType | null
  }

  export type Deal_code_groupsMinAggregateOutputType = {
    id: string | null
    codesState: string | null
    brandId: string | null
    generalExpireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Deal_code_groupsMaxAggregateOutputType = {
    id: string | null
    codesState: string | null
    brandId: string | null
    generalExpireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Deal_code_groupsCountAggregateOutputType = {
    id: number
    description: number
    shortDescription: number
    codesState: number
    brandId: number
    generalExpireDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Deal_code_groupsMinAggregateInputType = {
    id?: true
    codesState?: true
    brandId?: true
    generalExpireDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Deal_code_groupsMaxAggregateInputType = {
    id?: true
    codesState?: true
    brandId?: true
    generalExpireDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Deal_code_groupsCountAggregateInputType = {
    id?: true
    description?: true
    shortDescription?: true
    codesState?: true
    brandId?: true
    generalExpireDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Deal_code_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deal_code_groups to aggregate.
     */
    where?: deal_code_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deal_code_groups to fetch.
     */
    orderBy?: deal_code_groupsOrderByWithRelationInput | deal_code_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deal_code_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deal_code_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deal_code_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deal_code_groups
    **/
    _count?: true | Deal_code_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Deal_code_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Deal_code_groupsMaxAggregateInputType
  }

  export type GetDeal_code_groupsAggregateType<T extends Deal_code_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal_code_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal_code_groups[P]>
      : GetScalarType<T[P], AggregateDeal_code_groups[P]>
  }




  export type deal_code_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deal_code_groupsWhereInput
    orderBy?: deal_code_groupsOrderByWithAggregationInput | deal_code_groupsOrderByWithAggregationInput[]
    by: Deal_code_groupsScalarFieldEnum[] | Deal_code_groupsScalarFieldEnum
    having?: deal_code_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Deal_code_groupsCountAggregateInputType | true
    _min?: Deal_code_groupsMinAggregateInputType
    _max?: Deal_code_groupsMaxAggregateInputType
  }

  export type Deal_code_groupsGroupByOutputType = {
    id: string
    description: JsonValue
    shortDescription: JsonValue | null
    codesState: string | null
    brandId: string
    generalExpireDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Deal_code_groupsCountAggregateOutputType | null
    _min: Deal_code_groupsMinAggregateOutputType | null
    _max: Deal_code_groupsMaxAggregateOutputType | null
  }

  type GetDeal_code_groupsGroupByPayload<T extends deal_code_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Deal_code_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Deal_code_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Deal_code_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Deal_code_groupsGroupByOutputType[P]>
        }
      >
    >


  export type deal_code_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    shortDescription?: boolean
    codesState?: boolean
    brandId?: boolean
    generalExpireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    dealCodes?: boolean | deal_code_groups$dealCodesArgs<ExtArgs>
    _count?: boolean | Deal_code_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal_code_groups"]>


  export type deal_code_groupsSelectScalar = {
    id?: boolean
    description?: boolean
    shortDescription?: boolean
    codesState?: boolean
    brandId?: boolean
    generalExpireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type deal_code_groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    dealCodes?: boolean | deal_code_groups$dealCodesArgs<ExtArgs>
    _count?: boolean | Deal_code_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $deal_code_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "deal_code_groups"
    objects: {
      brand: Prisma.$brandsPayload<ExtArgs>
      dealCodes: Prisma.$deal_codesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: Prisma.JsonValue
      shortDescription: Prisma.JsonValue | null
      codesState: string | null
      brandId: string
      generalExpireDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deal_code_groups"]>
    composites: {}
  }

  type deal_code_groupsGetPayload<S extends boolean | null | undefined | deal_code_groupsDefaultArgs> = $Result.GetResult<Prisma.$deal_code_groupsPayload, S>

  type deal_code_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<deal_code_groupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Deal_code_groupsCountAggregateInputType | true
    }

  export interface deal_code_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['deal_code_groups'], meta: { name: 'deal_code_groups' } }
    /**
     * Find zero or one Deal_code_groups that matches the filter.
     * @param {deal_code_groupsFindUniqueArgs} args - Arguments to find a Deal_code_groups
     * @example
     * // Get one Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deal_code_groupsFindUniqueArgs>(args: SelectSubset<T, deal_code_groupsFindUniqueArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deal_code_groups that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {deal_code_groupsFindUniqueOrThrowArgs} args - Arguments to find a Deal_code_groups
     * @example
     * // Get one Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deal_code_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, deal_code_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deal_code_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_code_groupsFindFirstArgs} args - Arguments to find a Deal_code_groups
     * @example
     * // Get one Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deal_code_groupsFindFirstArgs>(args?: SelectSubset<T, deal_code_groupsFindFirstArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deal_code_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_code_groupsFindFirstOrThrowArgs} args - Arguments to find a Deal_code_groups
     * @example
     * // Get one Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deal_code_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, deal_code_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deal_code_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_code_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.findMany()
     * 
     * // Get first 10 Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deal_code_groupsWithIdOnly = await prisma.deal_code_groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deal_code_groupsFindManyArgs>(args?: SelectSubset<T, deal_code_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deal_code_groups.
     * @param {deal_code_groupsCreateArgs} args - Arguments to create a Deal_code_groups.
     * @example
     * // Create one Deal_code_groups
     * const Deal_code_groups = await prisma.deal_code_groups.create({
     *   data: {
     *     // ... data to create a Deal_code_groups
     *   }
     * })
     * 
     */
    create<T extends deal_code_groupsCreateArgs>(args: SelectSubset<T, deal_code_groupsCreateArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deal_code_groups.
     * @param {deal_code_groupsCreateManyArgs} args - Arguments to create many Deal_code_groups.
     * @example
     * // Create many Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deal_code_groupsCreateManyArgs>(args?: SelectSubset<T, deal_code_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deal_code_groups.
     * @param {deal_code_groupsDeleteArgs} args - Arguments to delete one Deal_code_groups.
     * @example
     * // Delete one Deal_code_groups
     * const Deal_code_groups = await prisma.deal_code_groups.delete({
     *   where: {
     *     // ... filter to delete one Deal_code_groups
     *   }
     * })
     * 
     */
    delete<T extends deal_code_groupsDeleteArgs>(args: SelectSubset<T, deal_code_groupsDeleteArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deal_code_groups.
     * @param {deal_code_groupsUpdateArgs} args - Arguments to update one Deal_code_groups.
     * @example
     * // Update one Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deal_code_groupsUpdateArgs>(args: SelectSubset<T, deal_code_groupsUpdateArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deal_code_groups.
     * @param {deal_code_groupsDeleteManyArgs} args - Arguments to filter Deal_code_groups to delete.
     * @example
     * // Delete a few Deal_code_groups
     * const { count } = await prisma.deal_code_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deal_code_groupsDeleteManyArgs>(args?: SelectSubset<T, deal_code_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deal_code_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_code_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deal_code_groupsUpdateManyArgs>(args: SelectSubset<T, deal_code_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deal_code_groups.
     * @param {deal_code_groupsUpsertArgs} args - Arguments to update or create a Deal_code_groups.
     * @example
     * // Update or create a Deal_code_groups
     * const deal_code_groups = await prisma.deal_code_groups.upsert({
     *   create: {
     *     // ... data to create a Deal_code_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal_code_groups we want to update
     *   }
     * })
     */
    upsert<T extends deal_code_groupsUpsertArgs>(args: SelectSubset<T, deal_code_groupsUpsertArgs<ExtArgs>>): Prisma__deal_code_groupsClient<$Result.GetResult<Prisma.$deal_code_groupsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Deal_code_groups that matches the filter.
     * @param {deal_code_groupsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const deal_code_groups = await prisma.deal_code_groups.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: deal_code_groupsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Deal_code_groups.
     * @param {deal_code_groupsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const deal_code_groups = await prisma.deal_code_groups.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: deal_code_groupsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Deal_code_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_code_groupsCountArgs} args - Arguments to filter Deal_code_groups to count.
     * @example
     * // Count the number of Deal_code_groups
     * const count = await prisma.deal_code_groups.count({
     *   where: {
     *     // ... the filter for the Deal_code_groups we want to count
     *   }
     * })
    **/
    count<T extends deal_code_groupsCountArgs>(
      args?: Subset<T, deal_code_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Deal_code_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal_code_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Deal_code_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Deal_code_groupsAggregateArgs>(args: Subset<T, Deal_code_groupsAggregateArgs>): Prisma.PrismaPromise<GetDeal_code_groupsAggregateType<T>>

    /**
     * Group by Deal_code_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deal_code_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deal_code_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deal_code_groupsGroupByArgs['orderBy'] }
        : { orderBy?: deal_code_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deal_code_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeal_code_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the deal_code_groups model
   */
  readonly fields: deal_code_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for deal_code_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deal_code_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dealCodes<T extends deal_code_groups$dealCodesArgs<ExtArgs> = {}>(args?: Subset<T, deal_code_groups$dealCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deal_codesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the deal_code_groups model
   */ 
  interface deal_code_groupsFieldRefs {
    readonly id: FieldRef<"deal_code_groups", 'String'>
    readonly description: FieldRef<"deal_code_groups", 'Json'>
    readonly shortDescription: FieldRef<"deal_code_groups", 'Json'>
    readonly codesState: FieldRef<"deal_code_groups", 'String'>
    readonly brandId: FieldRef<"deal_code_groups", 'String'>
    readonly generalExpireDate: FieldRef<"deal_code_groups", 'DateTime'>
    readonly createdAt: FieldRef<"deal_code_groups", 'DateTime'>
    readonly updatedAt: FieldRef<"deal_code_groups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * deal_code_groups findUnique
   */
  export type deal_code_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * Filter, which deal_code_groups to fetch.
     */
    where: deal_code_groupsWhereUniqueInput
  }

  /**
   * deal_code_groups findUniqueOrThrow
   */
  export type deal_code_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * Filter, which deal_code_groups to fetch.
     */
    where: deal_code_groupsWhereUniqueInput
  }

  /**
   * deal_code_groups findFirst
   */
  export type deal_code_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * Filter, which deal_code_groups to fetch.
     */
    where?: deal_code_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deal_code_groups to fetch.
     */
    orderBy?: deal_code_groupsOrderByWithRelationInput | deal_code_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deal_code_groups.
     */
    cursor?: deal_code_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deal_code_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deal_code_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deal_code_groups.
     */
    distinct?: Deal_code_groupsScalarFieldEnum | Deal_code_groupsScalarFieldEnum[]
  }

  /**
   * deal_code_groups findFirstOrThrow
   */
  export type deal_code_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * Filter, which deal_code_groups to fetch.
     */
    where?: deal_code_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deal_code_groups to fetch.
     */
    orderBy?: deal_code_groupsOrderByWithRelationInput | deal_code_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deal_code_groups.
     */
    cursor?: deal_code_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deal_code_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deal_code_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deal_code_groups.
     */
    distinct?: Deal_code_groupsScalarFieldEnum | Deal_code_groupsScalarFieldEnum[]
  }

  /**
   * deal_code_groups findMany
   */
  export type deal_code_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * Filter, which deal_code_groups to fetch.
     */
    where?: deal_code_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deal_code_groups to fetch.
     */
    orderBy?: deal_code_groupsOrderByWithRelationInput | deal_code_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deal_code_groups.
     */
    cursor?: deal_code_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deal_code_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deal_code_groups.
     */
    skip?: number
    distinct?: Deal_code_groupsScalarFieldEnum | Deal_code_groupsScalarFieldEnum[]
  }

  /**
   * deal_code_groups create
   */
  export type deal_code_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a deal_code_groups.
     */
    data: XOR<deal_code_groupsCreateInput, deal_code_groupsUncheckedCreateInput>
  }

  /**
   * deal_code_groups createMany
   */
  export type deal_code_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many deal_code_groups.
     */
    data: deal_code_groupsCreateManyInput | deal_code_groupsCreateManyInput[]
  }

  /**
   * deal_code_groups update
   */
  export type deal_code_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a deal_code_groups.
     */
    data: XOR<deal_code_groupsUpdateInput, deal_code_groupsUncheckedUpdateInput>
    /**
     * Choose, which deal_code_groups to update.
     */
    where: deal_code_groupsWhereUniqueInput
  }

  /**
   * deal_code_groups updateMany
   */
  export type deal_code_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update deal_code_groups.
     */
    data: XOR<deal_code_groupsUpdateManyMutationInput, deal_code_groupsUncheckedUpdateManyInput>
    /**
     * Filter which deal_code_groups to update
     */
    where?: deal_code_groupsWhereInput
  }

  /**
   * deal_code_groups upsert
   */
  export type deal_code_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the deal_code_groups to update in case it exists.
     */
    where: deal_code_groupsWhereUniqueInput
    /**
     * In case the deal_code_groups found by the `where` argument doesn't exist, create a new deal_code_groups with this data.
     */
    create: XOR<deal_code_groupsCreateInput, deal_code_groupsUncheckedCreateInput>
    /**
     * In case the deal_code_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deal_code_groupsUpdateInput, deal_code_groupsUncheckedUpdateInput>
  }

  /**
   * deal_code_groups delete
   */
  export type deal_code_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
    /**
     * Filter which deal_code_groups to delete.
     */
    where: deal_code_groupsWhereUniqueInput
  }

  /**
   * deal_code_groups deleteMany
   */
  export type deal_code_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deal_code_groups to delete
     */
    where?: deal_code_groupsWhereInput
  }

  /**
   * deal_code_groups findRaw
   */
  export type deal_code_groupsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * deal_code_groups aggregateRaw
   */
  export type deal_code_groupsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * deal_code_groups.dealCodes
   */
  export type deal_code_groups$dealCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_codes
     */
    select?: deal_codesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_codesInclude<ExtArgs> | null
    where?: deal_codesWhereInput
    orderBy?: deal_codesOrderByWithRelationInput | deal_codesOrderByWithRelationInput[]
    cursor?: deal_codesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Deal_codesScalarFieldEnum | Deal_codesScalarFieldEnum[]
  }

  /**
   * deal_code_groups without action
   */
  export type deal_code_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deal_code_groups
     */
    select?: deal_code_groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deal_code_groupsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const Order_historyScalarFieldEnum: {
    id: 'id',
    brandId: 'brandId',
    brandName: 'brandName',
    dealCodes: 'dealCodes',
    orderJson: 'orderJson',
    createdAt: 'createdAt'
  };

  export type Order_historyScalarFieldEnum = (typeof Order_historyScalarFieldEnum)[keyof typeof Order_historyScalarFieldEnum]


  export const AnswersScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    questionId: 'questionId',
    questionText: 'questionText',
    answer: 'answer',
    productFeedbackBrandId: 'productFeedbackBrandId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pitchExitBrandId: 'pitchExitBrandId'
  };

  export type AnswersScalarFieldEnum = (typeof AnswersScalarFieldEnum)[keyof typeof AnswersScalarFieldEnum]


  export const App_versionsScalarFieldEnum: {
    id: 'id',
    version: 'version',
    critical: 'critical',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type App_versionsScalarFieldEnum = (typeof App_versionsScalarFieldEnum)[keyof typeof App_versionsScalarFieldEnum]


  export const BenefitsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    logo: 'logo',
    image: 'image',
    redeemLink: 'redeemLink',
    levelId: 'levelId',
    tags: 'tags',
    code: 'code',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BenefitsScalarFieldEnum = (typeof BenefitsScalarFieldEnum)[keyof typeof BenefitsScalarFieldEnum]


  export const BrandsScalarFieldEnum: {
    id: 'id',
    description: 'description',
    shortDescription: 'shortDescription',
    name: 'name',
    pitchVideo: 'pitchVideo',
    pitchCaptions: 'pitchCaptions',
    pitchSections: 'pitchSections',
    updatedAt: 'updatedAt',
    brandLogo: 'brandLogo',
    email: 'email',
    managerEmail: 'managerEmail',
    managerName: 'managerName',
    managerPhone: 'managerPhone',
    labels: 'labels',
    teamPicture: 'teamPicture',
    website: 'website',
    categoryId: 'categoryId',
    teaser: 'teaser',
    mainPhrase: 'mainPhrase',
    founders: 'founders',
    image: 'image',
    usersForYouIds: 'usersForYouIds',
    usersForYouPoolIds: 'usersForYouPoolIds',
    usersNotInterestedBrandsIds: 'usersNotInterestedBrandsIds',
    images: 'images',
    usersFeedback: 'usersFeedback',
    selectedFeedback: 'selectedFeedback',
    targetGender: 'targetGender',
    budgetInterval: 'budgetInterval',
    shopifyDomain: 'shopifyDomain',
    shopifyKeyName: 'shopifyKeyName',
    ledgeRating: 'ledgeRating',
    showTeamPictureInRating: 'showTeamPictureInRating'
  };

  export type BrandsScalarFieldEnum = (typeof BrandsScalarFieldEnum)[keyof typeof BrandsScalarFieldEnum]


  export const Unlocked_brands_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    brandId: 'brandId',
    createdAt: 'createdAt'
  };

  export type Unlocked_brands_historyScalarFieldEnum = (typeof Unlocked_brands_historyScalarFieldEnum)[keyof typeof Unlocked_brands_historyScalarFieldEnum]


  export const Brand_screen_timesScalarFieldEnum: {
    id: 'id',
    time: 'time',
    userId: 'userId',
    brandId: 'brandId',
    createdAt: 'createdAt'
  };

  export type Brand_screen_timesScalarFieldEnum = (typeof Brand_screen_timesScalarFieldEnum)[keyof typeof Brand_screen_timesScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const Category_choicesScalarFieldEnum: {
    id: 'id',
    like: 'like',
    categoryId: 'categoryId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Category_choicesScalarFieldEnum = (typeof Category_choicesScalarFieldEnum)[keyof typeof Category_choicesScalarFieldEnum]


  export const FoundersReachedLeaderboardScalarFieldEnum: {
    id: 'id',
    amount: 'amount'
  };

  export type FoundersReachedLeaderboardScalarFieldEnum = (typeof FoundersReachedLeaderboardScalarFieldEnum)[keyof typeof FoundersReachedLeaderboardScalarFieldEnum]


  export const Link_visitsScalarFieldEnum: {
    id: 'id',
    url: 'url',
    userId: 'userId',
    brandId: 'brandId',
    productId: 'productId',
    benefitId: 'benefitId',
    createdAt: 'createdAt'
  };

  export type Link_visitsScalarFieldEnum = (typeof Link_visitsScalarFieldEnum)[keyof typeof Link_visitsScalarFieldEnum]


  export const Pitch_viewsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    brandId: 'brandId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Pitch_viewsScalarFieldEnum = (typeof Pitch_viewsScalarFieldEnum)[keyof typeof Pitch_viewsScalarFieldEnum]


  export const PostsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    author: 'author',
    content: 'content',
    video: 'video',
    image: 'image',
    brandId: 'brandId',
    userLikesIds: 'userLikesIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]


  export const Production_submissionsScalarFieldEnum: {
    id: 'id',
    overlays: 'overlays',
    videos: 'videos',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    brandId: 'brandId',
    userId: 'userId'
  };

  export type Production_submissionsScalarFieldEnum = (typeof Production_submissionsScalarFieldEnum)[keyof typeof Production_submissionsScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    description: 'description',
    images: 'images',
    regularPrice: 'regularPrice',
    deal: 'deal',
    dealPrice: 'dealPrice',
    purchaseUrl: 'purchaseUrl',
    brandId: 'brandId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uniqueDeal: 'uniqueDeal'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const Push_notificationsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    minDaysInactive: 'minDaysInactive',
    oneTimeOnly: 'oneTimeOnly',
    sendAfterInactiveDays: 'sendAfterInactiveDays',
    repeatAfterDays: 'repeatAfterDays',
    daysAfterActivation: 'daysAfterActivation',
    daysBeforeExpiry: 'daysBeforeExpiry'
  };

  export type Push_notificationsScalarFieldEnum = (typeof Push_notificationsScalarFieldEnum)[keyof typeof Push_notificationsScalarFieldEnum]


  export const Push_notification_historyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    entityId: 'entityId',
    content: 'content',
    title: 'title',
    sentAt: 'sentAt'
  };

  export type Push_notification_historyScalarFieldEnum = (typeof Push_notification_historyScalarFieldEnum)[keyof typeof Push_notification_historyScalarFieldEnum]


  export const QuestionnairesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionnairesScalarFieldEnum = (typeof QuestionnairesScalarFieldEnum)[keyof typeof QuestionnairesScalarFieldEnum]


  export const Question_classesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    editable: 'editable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Question_classesScalarFieldEnum = (typeof Question_classesScalarFieldEnum)[keyof typeof Question_classesScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    position: 'position',
    question: 'question',
    type: 'type',
    options: 'options',
    classId: 'classId',
    categoryId: 'categoryId',
    onboarding: 'onboarding',
    randomizeOptions: 'randomizeOptions',
    fixedOptionSize: 'fixedOptionSize',
    hideOptionText: 'hideOptionText',
    displayImage: 'displayImage',
    footnote: 'footnote',
    subtitle: 'subtitle',
    products: 'products',
    brandId: 'brandId',
    correctAnswerId: 'correctAnswerId',
    questionnaireId: 'questionnaireId',
    questionnaireSubCategory: 'questionnaireSubCategory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    scaleTopLabel: 'scaleTopLabel',
    scaleBottomLabel: 'scaleBottomLabel',
    maxOptions: 'maxOptions'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const RatingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    brandId: 'brandId',
    rating: 'rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RatingsScalarFieldEnum = (typeof RatingsScalarFieldEnum)[keyof typeof RatingsScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    receiveNotifications: 'receiveNotifications',
    newBrands: 'newBrands',
    personalizedOffers: 'personalizedOffers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const Terms_and_conditionsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmailAddress: 'userEmailAddress',
    acceptanceDate: 'acceptanceDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Terms_and_conditionsScalarFieldEnum = (typeof Terms_and_conditionsScalarFieldEnum)[keyof typeof Terms_and_conditionsScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    text: 'text',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const LevelsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    order: 'order',
    requiredBrandsExplored: 'requiredBrandsExplored',
    requiredAnswers: 'requiredAnswers',
    questionnaireId: 'questionnaireId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevelsScalarFieldEnum = (typeof LevelsScalarFieldEnum)[keyof typeof LevelsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    myFavourites: 'myFavourites',
    hasAcceptedTermsAndConditions: 'hasAcceptedTermsAndConditions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    notificationsToken: 'notificationsToken',
    forYouBrandsIds: 'forYouBrandsIds',
    forYouBrandsPoolIds: 'forYouBrandsPoolIds',
    notInterestedBrandsIds: 'notInterestedBrandsIds',
    levelId: 'levelId',
    brandsExplored: 'brandsExplored',
    ownedBrandId: 'ownedBrandId',
    foundersReachedLeaderboardId: 'foundersReachedLeaderboardId',
    viewedPitches: 'viewedPitches',
    targetGender: 'targetGender',
    budgetInterval: 'budgetInterval',
    deletedBrands: 'deletedBrands',
    superUser: 'superUser',
    hasNewForYouBrands: 'hasNewForYouBrands',
    likedPostsIds: 'likedPostsIds',
    lastOpened: 'lastOpened'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Deal_codesScalarFieldEnum: {
    id: 'id',
    code: 'code',
    isUsed: 'isUsed',
    userId: 'userId',
    groupId: 'groupId',
    userExpireDate: 'userExpireDate',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Deal_codesScalarFieldEnum = (typeof Deal_codesScalarFieldEnum)[keyof typeof Deal_codesScalarFieldEnum]


  export const Deal_code_groupsScalarFieldEnum: {
    id: 'id',
    description: 'description',
    shortDescription: 'shortDescription',
    codesState: 'codesState',
    brandId: 'brandId',
    generalExpireDate: 'generalExpireDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Deal_code_groupsScalarFieldEnum = (typeof Deal_code_groupsScalarFieldEnum)[keyof typeof Deal_code_groupsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'GenderPreference'
   */
  export type EnumGenderPreferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenderPreference'>
    


  /**
   * Reference to a field of type 'GenderPreference[]'
   */
  export type ListEnumGenderPreferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenderPreference[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type order_historyWhereInput = {
    AND?: order_historyWhereInput | order_historyWhereInput[]
    OR?: order_historyWhereInput[]
    NOT?: order_historyWhereInput | order_historyWhereInput[]
    id?: StringFilter<"order_history"> | string
    brandId?: StringFilter<"order_history"> | string
    brandName?: StringFilter<"order_history"> | string
    dealCodes?: StringNullableListFilter<"order_history">
    orderJson?: JsonFilter<"order_history">
    createdAt?: DateTimeFilter<"order_history"> | Date | string
  }

  export type order_historyOrderByWithRelationInput = {
    id?: SortOrder
    brandId?: SortOrder
    brandName?: SortOrder
    dealCodes?: SortOrder
    orderJson?: SortOrder
    createdAt?: SortOrder
  }

  export type order_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: order_historyWhereInput | order_historyWhereInput[]
    OR?: order_historyWhereInput[]
    NOT?: order_historyWhereInput | order_historyWhereInput[]
    brandId?: StringFilter<"order_history"> | string
    brandName?: StringFilter<"order_history"> | string
    dealCodes?: StringNullableListFilter<"order_history">
    orderJson?: JsonFilter<"order_history">
    createdAt?: DateTimeFilter<"order_history"> | Date | string
  }, "id">

  export type order_historyOrderByWithAggregationInput = {
    id?: SortOrder
    brandId?: SortOrder
    brandName?: SortOrder
    dealCodes?: SortOrder
    orderJson?: SortOrder
    createdAt?: SortOrder
    _count?: order_historyCountOrderByAggregateInput
    _max?: order_historyMaxOrderByAggregateInput
    _min?: order_historyMinOrderByAggregateInput
  }

  export type order_historyScalarWhereWithAggregatesInput = {
    AND?: order_historyScalarWhereWithAggregatesInput | order_historyScalarWhereWithAggregatesInput[]
    OR?: order_historyScalarWhereWithAggregatesInput[]
    NOT?: order_historyScalarWhereWithAggregatesInput | order_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"order_history"> | string
    brandId?: StringWithAggregatesFilter<"order_history"> | string
    brandName?: StringWithAggregatesFilter<"order_history"> | string
    dealCodes?: StringNullableListFilter<"order_history">
    orderJson?: JsonWithAggregatesFilter<"order_history">
    createdAt?: DateTimeWithAggregatesFilter<"order_history"> | Date | string
  }

  export type answersWhereInput = {
    AND?: answersWhereInput | answersWhereInput[]
    OR?: answersWhereInput[]
    NOT?: answersWhereInput | answersWhereInput[]
    id?: StringFilter<"answers"> | string
    userId?: StringFilter<"answers"> | string
    questionId?: StringNullableFilter<"answers"> | string | null
    questionText?: JsonFilter<"answers">
    answer?: JsonFilter<"answers">
    productFeedbackBrandId?: StringNullableFilter<"answers"> | string | null
    createdAt?: DateTimeFilter<"answers"> | Date | string
    updatedAt?: DateTimeFilter<"answers"> | Date | string
    pitchExitBrandId?: StringNullableFilter<"answers"> | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    question?: XOR<QuestionsNullableRelationFilter, questionsWhereInput> | null
    productFeedbackBrand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    pitchExitBrand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
  }

  export type answersOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    questionText?: SortOrder
    answer?: SortOrder
    productFeedbackBrandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pitchExitBrandId?: SortOrder
    user?: usersOrderByWithRelationInput
    question?: questionsOrderByWithRelationInput
    productFeedbackBrand?: brandsOrderByWithRelationInput
    pitchExitBrand?: brandsOrderByWithRelationInput
  }

  export type answersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_questionId?: answersUserIdQuestionIdCompoundUniqueInput
    AND?: answersWhereInput | answersWhereInput[]
    OR?: answersWhereInput[]
    NOT?: answersWhereInput | answersWhereInput[]
    userId?: StringFilter<"answers"> | string
    questionId?: StringNullableFilter<"answers"> | string | null
    questionText?: JsonFilter<"answers">
    answer?: JsonFilter<"answers">
    productFeedbackBrandId?: StringNullableFilter<"answers"> | string | null
    createdAt?: DateTimeFilter<"answers"> | Date | string
    updatedAt?: DateTimeFilter<"answers"> | Date | string
    pitchExitBrandId?: StringNullableFilter<"answers"> | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    question?: XOR<QuestionsNullableRelationFilter, questionsWhereInput> | null
    productFeedbackBrand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    pitchExitBrand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
  }, "id" | "userId_questionId">

  export type answersOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    questionText?: SortOrder
    answer?: SortOrder
    productFeedbackBrandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pitchExitBrandId?: SortOrder
    _count?: answersCountOrderByAggregateInput
    _max?: answersMaxOrderByAggregateInput
    _min?: answersMinOrderByAggregateInput
  }

  export type answersScalarWhereWithAggregatesInput = {
    AND?: answersScalarWhereWithAggregatesInput | answersScalarWhereWithAggregatesInput[]
    OR?: answersScalarWhereWithAggregatesInput[]
    NOT?: answersScalarWhereWithAggregatesInput | answersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"answers"> | string
    userId?: StringWithAggregatesFilter<"answers"> | string
    questionId?: StringNullableWithAggregatesFilter<"answers"> | string | null
    questionText?: JsonWithAggregatesFilter<"answers">
    answer?: JsonWithAggregatesFilter<"answers">
    productFeedbackBrandId?: StringNullableWithAggregatesFilter<"answers"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"answers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"answers"> | Date | string
    pitchExitBrandId?: StringNullableWithAggregatesFilter<"answers"> | string | null
  }

  export type app_versionsWhereInput = {
    AND?: app_versionsWhereInput | app_versionsWhereInput[]
    OR?: app_versionsWhereInput[]
    NOT?: app_versionsWhereInput | app_versionsWhereInput[]
    id?: StringFilter<"app_versions"> | string
    version?: StringFilter<"app_versions"> | string
    critical?: BoolFilter<"app_versions"> | boolean
    createdAt?: DateTimeFilter<"app_versions"> | Date | string
    updatedAt?: DateTimeFilter<"app_versions"> | Date | string
  }

  export type app_versionsOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type app_versionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: app_versionsWhereInput | app_versionsWhereInput[]
    OR?: app_versionsWhereInput[]
    NOT?: app_versionsWhereInput | app_versionsWhereInput[]
    version?: StringFilter<"app_versions"> | string
    critical?: BoolFilter<"app_versions"> | boolean
    createdAt?: DateTimeFilter<"app_versions"> | Date | string
    updatedAt?: DateTimeFilter<"app_versions"> | Date | string
  }, "id">

  export type app_versionsOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: app_versionsCountOrderByAggregateInput
    _max?: app_versionsMaxOrderByAggregateInput
    _min?: app_versionsMinOrderByAggregateInput
  }

  export type app_versionsScalarWhereWithAggregatesInput = {
    AND?: app_versionsScalarWhereWithAggregatesInput | app_versionsScalarWhereWithAggregatesInput[]
    OR?: app_versionsScalarWhereWithAggregatesInput[]
    NOT?: app_versionsScalarWhereWithAggregatesInput | app_versionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"app_versions"> | string
    version?: StringWithAggregatesFilter<"app_versions"> | string
    critical?: BoolWithAggregatesFilter<"app_versions"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"app_versions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"app_versions"> | Date | string
  }

  export type benefitsWhereInput = {
    AND?: benefitsWhereInput | benefitsWhereInput[]
    OR?: benefitsWhereInput[]
    NOT?: benefitsWhereInput | benefitsWhereInput[]
    id?: StringFilter<"benefits"> | string
    title?: StringFilter<"benefits"> | string
    subtitle?: JsonFilter<"benefits">
    description?: JsonFilter<"benefits">
    logo?: JsonNullableFilter<"benefits">
    image?: JsonNullableFilter<"benefits">
    redeemLink?: StringFilter<"benefits"> | string
    levelId?: StringNullableFilter<"benefits"> | string | null
    tags?: JsonNullableListFilter<"benefits">
    code?: StringNullableFilter<"benefits"> | string | null
    createdAt?: DateTimeFilter<"benefits"> | Date | string
    updatedAt?: DateTimeFilter<"benefits"> | Date | string
    level?: XOR<LevelsNullableRelationFilter, levelsWhereInput> | null
    linkVisits?: Link_visitsListRelationFilter
  }

  export type benefitsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    redeemLink?: SortOrder
    levelId?: SortOrder
    tags?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: levelsOrderByWithRelationInput
    linkVisits?: link_visitsOrderByRelationAggregateInput
  }

  export type benefitsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: benefitsWhereInput | benefitsWhereInput[]
    OR?: benefitsWhereInput[]
    NOT?: benefitsWhereInput | benefitsWhereInput[]
    title?: StringFilter<"benefits"> | string
    subtitle?: JsonFilter<"benefits">
    description?: JsonFilter<"benefits">
    logo?: JsonNullableFilter<"benefits">
    image?: JsonNullableFilter<"benefits">
    redeemLink?: StringFilter<"benefits"> | string
    levelId?: StringNullableFilter<"benefits"> | string | null
    tags?: JsonNullableListFilter<"benefits">
    code?: StringNullableFilter<"benefits"> | string | null
    createdAt?: DateTimeFilter<"benefits"> | Date | string
    updatedAt?: DateTimeFilter<"benefits"> | Date | string
    level?: XOR<LevelsNullableRelationFilter, levelsWhereInput> | null
    linkVisits?: Link_visitsListRelationFilter
  }, "id">

  export type benefitsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    redeemLink?: SortOrder
    levelId?: SortOrder
    tags?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: benefitsCountOrderByAggregateInput
    _max?: benefitsMaxOrderByAggregateInput
    _min?: benefitsMinOrderByAggregateInput
  }

  export type benefitsScalarWhereWithAggregatesInput = {
    AND?: benefitsScalarWhereWithAggregatesInput | benefitsScalarWhereWithAggregatesInput[]
    OR?: benefitsScalarWhereWithAggregatesInput[]
    NOT?: benefitsScalarWhereWithAggregatesInput | benefitsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"benefits"> | string
    title?: StringWithAggregatesFilter<"benefits"> | string
    subtitle?: JsonWithAggregatesFilter<"benefits">
    description?: JsonWithAggregatesFilter<"benefits">
    logo?: JsonNullableWithAggregatesFilter<"benefits">
    image?: JsonNullableWithAggregatesFilter<"benefits">
    redeemLink?: StringWithAggregatesFilter<"benefits"> | string
    levelId?: StringNullableWithAggregatesFilter<"benefits"> | string | null
    tags?: JsonNullableListFilter<"benefits">
    code?: StringNullableWithAggregatesFilter<"benefits"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"benefits"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"benefits"> | Date | string
  }

  export type brandsWhereInput = {
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    id?: StringFilter<"brands"> | string
    description?: JsonFilter<"brands">
    shortDescription?: JsonNullableFilter<"brands">
    name?: StringFilter<"brands"> | string
    pitchVideo?: StringNullableFilter<"brands"> | string | null
    pitchCaptions?: JsonNullableFilter<"brands">
    pitchSections?: JsonNullableFilter<"brands">
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    brandLogo?: JsonNullableFilter<"brands">
    email?: StringNullableFilter<"brands"> | string | null
    managerEmail?: StringNullableFilter<"brands"> | string | null
    managerName?: StringNullableFilter<"brands"> | string | null
    managerPhone?: StringNullableFilter<"brands"> | string | null
    labels?: JsonNullableListFilter<"brands">
    teamPicture?: JsonNullableFilter<"brands">
    website?: StringNullableFilter<"brands"> | string | null
    categoryId?: StringNullableFilter<"brands"> | string | null
    teaser?: StringNullableFilter<"brands"> | string | null
    mainPhrase?: StringNullableFilter<"brands"> | string | null
    founders?: JsonNullableListFilter<"brands">
    image?: JsonNullableFilter<"brands">
    usersForYouIds?: StringNullableListFilter<"brands">
    usersForYouPoolIds?: StringNullableListFilter<"brands">
    usersNotInterestedBrandsIds?: StringNullableListFilter<"brands">
    images?: JsonNullableListFilter<"brands">
    usersFeedback?: JsonNullableFilter<"brands">
    selectedFeedback?: JsonFilter<"brands">
    targetGender?: EnumGenderPreferenceNullableFilter<"brands"> | $Enums.GenderPreference | null
    budgetInterval?: IntNullableFilter<"brands"> | number | null
    shopifyDomain?: StringNullableFilter<"brands"> | string | null
    shopifyKeyName?: StringNullableFilter<"brands"> | string | null
    ledgeRating?: IntFilter<"brands"> | number
    showTeamPictureInRating?: BoolNullableFilter<"brands"> | boolean | null
    pitchQuestions?: QuestionsListRelationFilter
    pitchViews?: Pitch_viewsListRelationFilter
    products?: ProductsListRelationFilter
    category?: XOR<CategoriesNullableRelationFilter, categoriesWhereInput> | null
    ratings?: RatingsListRelationFilter
    usersForYou?: UsersListRelationFilter
    usersForYouPool?: UsersListRelationFilter
    usersNotInterestedBrands?: UsersListRelationFilter
    linkVisits?: Link_visitsListRelationFilter
    brandScreenTimes?: Brand_screen_timesListRelationFilter
    productionSubmissions?: Production_submissionsListRelationFilter
    owner?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    posts?: PostsListRelationFilter
    dealCodeGroups?: Deal_code_groupsListRelationFilter
    unlockHistory?: Unlocked_brands_historyListRelationFilter
    pitchExitBrandAnswers?: AnswersListRelationFilter
    productFeedbackAnswers?: AnswersListRelationFilter
  }

  export type brandsOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    name?: SortOrder
    pitchVideo?: SortOrder
    pitchCaptions?: SortOrder
    pitchSections?: SortOrder
    updatedAt?: SortOrder
    brandLogo?: SortOrder
    email?: SortOrder
    managerEmail?: SortOrder
    managerName?: SortOrder
    managerPhone?: SortOrder
    labels?: SortOrder
    teamPicture?: SortOrder
    website?: SortOrder
    categoryId?: SortOrder
    teaser?: SortOrder
    mainPhrase?: SortOrder
    founders?: SortOrder
    image?: SortOrder
    usersForYouIds?: SortOrder
    usersForYouPoolIds?: SortOrder
    usersNotInterestedBrandsIds?: SortOrder
    images?: SortOrder
    usersFeedback?: SortOrder
    selectedFeedback?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    shopifyDomain?: SortOrder
    shopifyKeyName?: SortOrder
    ledgeRating?: SortOrder
    showTeamPictureInRating?: SortOrder
    pitchQuestions?: questionsOrderByRelationAggregateInput
    pitchViews?: pitch_viewsOrderByRelationAggregateInput
    products?: productsOrderByRelationAggregateInput
    category?: categoriesOrderByWithRelationInput
    ratings?: ratingsOrderByRelationAggregateInput
    usersForYou?: usersOrderByRelationAggregateInput
    usersForYouPool?: usersOrderByRelationAggregateInput
    usersNotInterestedBrands?: usersOrderByRelationAggregateInput
    linkVisits?: link_visitsOrderByRelationAggregateInput
    brandScreenTimes?: brand_screen_timesOrderByRelationAggregateInput
    productionSubmissions?: production_submissionsOrderByRelationAggregateInput
    owner?: usersOrderByWithRelationInput
    posts?: postsOrderByRelationAggregateInput
    dealCodeGroups?: deal_code_groupsOrderByRelationAggregateInput
    unlockHistory?: unlocked_brands_historyOrderByRelationAggregateInput
    pitchExitBrandAnswers?: answersOrderByRelationAggregateInput
    productFeedbackAnswers?: answersOrderByRelationAggregateInput
  }

  export type brandsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    description?: JsonFilter<"brands">
    shortDescription?: JsonNullableFilter<"brands">
    name?: StringFilter<"brands"> | string
    pitchVideo?: StringNullableFilter<"brands"> | string | null
    pitchCaptions?: JsonNullableFilter<"brands">
    pitchSections?: JsonNullableFilter<"brands">
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    brandLogo?: JsonNullableFilter<"brands">
    email?: StringNullableFilter<"brands"> | string | null
    managerEmail?: StringNullableFilter<"brands"> | string | null
    managerName?: StringNullableFilter<"brands"> | string | null
    managerPhone?: StringNullableFilter<"brands"> | string | null
    labels?: JsonNullableListFilter<"brands">
    teamPicture?: JsonNullableFilter<"brands">
    website?: StringNullableFilter<"brands"> | string | null
    categoryId?: StringNullableFilter<"brands"> | string | null
    teaser?: StringNullableFilter<"brands"> | string | null
    mainPhrase?: StringNullableFilter<"brands"> | string | null
    founders?: JsonNullableListFilter<"brands">
    image?: JsonNullableFilter<"brands">
    usersForYouIds?: StringNullableListFilter<"brands">
    usersForYouPoolIds?: StringNullableListFilter<"brands">
    usersNotInterestedBrandsIds?: StringNullableListFilter<"brands">
    images?: JsonNullableListFilter<"brands">
    usersFeedback?: JsonNullableFilter<"brands">
    selectedFeedback?: JsonFilter<"brands">
    targetGender?: EnumGenderPreferenceNullableFilter<"brands"> | $Enums.GenderPreference | null
    budgetInterval?: IntNullableFilter<"brands"> | number | null
    shopifyDomain?: StringNullableFilter<"brands"> | string | null
    shopifyKeyName?: StringNullableFilter<"brands"> | string | null
    ledgeRating?: IntFilter<"brands"> | number
    showTeamPictureInRating?: BoolNullableFilter<"brands"> | boolean | null
    pitchQuestions?: QuestionsListRelationFilter
    pitchViews?: Pitch_viewsListRelationFilter
    products?: ProductsListRelationFilter
    category?: XOR<CategoriesNullableRelationFilter, categoriesWhereInput> | null
    ratings?: RatingsListRelationFilter
    usersForYou?: UsersListRelationFilter
    usersForYouPool?: UsersListRelationFilter
    usersNotInterestedBrands?: UsersListRelationFilter
    linkVisits?: Link_visitsListRelationFilter
    brandScreenTimes?: Brand_screen_timesListRelationFilter
    productionSubmissions?: Production_submissionsListRelationFilter
    owner?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    posts?: PostsListRelationFilter
    dealCodeGroups?: Deal_code_groupsListRelationFilter
    unlockHistory?: Unlocked_brands_historyListRelationFilter
    pitchExitBrandAnswers?: AnswersListRelationFilter
    productFeedbackAnswers?: AnswersListRelationFilter
  }, "id">

  export type brandsOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    name?: SortOrder
    pitchVideo?: SortOrder
    pitchCaptions?: SortOrder
    pitchSections?: SortOrder
    updatedAt?: SortOrder
    brandLogo?: SortOrder
    email?: SortOrder
    managerEmail?: SortOrder
    managerName?: SortOrder
    managerPhone?: SortOrder
    labels?: SortOrder
    teamPicture?: SortOrder
    website?: SortOrder
    categoryId?: SortOrder
    teaser?: SortOrder
    mainPhrase?: SortOrder
    founders?: SortOrder
    image?: SortOrder
    usersForYouIds?: SortOrder
    usersForYouPoolIds?: SortOrder
    usersNotInterestedBrandsIds?: SortOrder
    images?: SortOrder
    usersFeedback?: SortOrder
    selectedFeedback?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    shopifyDomain?: SortOrder
    shopifyKeyName?: SortOrder
    ledgeRating?: SortOrder
    showTeamPictureInRating?: SortOrder
    _count?: brandsCountOrderByAggregateInput
    _avg?: brandsAvgOrderByAggregateInput
    _max?: brandsMaxOrderByAggregateInput
    _min?: brandsMinOrderByAggregateInput
    _sum?: brandsSumOrderByAggregateInput
  }

  export type brandsScalarWhereWithAggregatesInput = {
    AND?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    OR?: brandsScalarWhereWithAggregatesInput[]
    NOT?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"brands"> | string
    description?: JsonWithAggregatesFilter<"brands">
    shortDescription?: JsonNullableWithAggregatesFilter<"brands">
    name?: StringWithAggregatesFilter<"brands"> | string
    pitchVideo?: StringNullableWithAggregatesFilter<"brands"> | string | null
    pitchCaptions?: JsonNullableWithAggregatesFilter<"brands">
    pitchSections?: JsonNullableWithAggregatesFilter<"brands">
    updatedAt?: DateTimeWithAggregatesFilter<"brands"> | Date | string
    brandLogo?: JsonNullableWithAggregatesFilter<"brands">
    email?: StringNullableWithAggregatesFilter<"brands"> | string | null
    managerEmail?: StringNullableWithAggregatesFilter<"brands"> | string | null
    managerName?: StringNullableWithAggregatesFilter<"brands"> | string | null
    managerPhone?: StringNullableWithAggregatesFilter<"brands"> | string | null
    labels?: JsonNullableListFilter<"brands">
    teamPicture?: JsonNullableWithAggregatesFilter<"brands">
    website?: StringNullableWithAggregatesFilter<"brands"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"brands"> | string | null
    teaser?: StringNullableWithAggregatesFilter<"brands"> | string | null
    mainPhrase?: StringNullableWithAggregatesFilter<"brands"> | string | null
    founders?: JsonNullableListFilter<"brands">
    image?: JsonNullableWithAggregatesFilter<"brands">
    usersForYouIds?: StringNullableListFilter<"brands">
    usersForYouPoolIds?: StringNullableListFilter<"brands">
    usersNotInterestedBrandsIds?: StringNullableListFilter<"brands">
    images?: JsonNullableListFilter<"brands">
    usersFeedback?: JsonNullableWithAggregatesFilter<"brands">
    selectedFeedback?: JsonWithAggregatesFilter<"brands">
    targetGender?: EnumGenderPreferenceNullableWithAggregatesFilter<"brands"> | $Enums.GenderPreference | null
    budgetInterval?: IntNullableWithAggregatesFilter<"brands"> | number | null
    shopifyDomain?: StringNullableWithAggregatesFilter<"brands"> | string | null
    shopifyKeyName?: StringNullableWithAggregatesFilter<"brands"> | string | null
    ledgeRating?: IntWithAggregatesFilter<"brands"> | number
    showTeamPictureInRating?: BoolNullableWithAggregatesFilter<"brands"> | boolean | null
  }

  export type unlocked_brands_historyWhereInput = {
    AND?: unlocked_brands_historyWhereInput | unlocked_brands_historyWhereInput[]
    OR?: unlocked_brands_historyWhereInput[]
    NOT?: unlocked_brands_historyWhereInput | unlocked_brands_historyWhereInput[]
    id?: StringFilter<"unlocked_brands_history"> | string
    userId?: StringFilter<"unlocked_brands_history"> | string
    brandId?: StringNullableFilter<"unlocked_brands_history"> | string | null
    createdAt?: DateTimeFilter<"unlocked_brands_history"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
  }

  export type unlocked_brands_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
    brand?: brandsOrderByWithRelationInput
  }

  export type unlocked_brands_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_brandId?: unlocked_brands_historyUserIdBrandIdCompoundUniqueInput
    AND?: unlocked_brands_historyWhereInput | unlocked_brands_historyWhereInput[]
    OR?: unlocked_brands_historyWhereInput[]
    NOT?: unlocked_brands_historyWhereInput | unlocked_brands_historyWhereInput[]
    userId?: StringFilter<"unlocked_brands_history"> | string
    brandId?: StringNullableFilter<"unlocked_brands_history"> | string | null
    createdAt?: DateTimeFilter<"unlocked_brands_history"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
  }, "id" | "userId_brandId">

  export type unlocked_brands_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    _count?: unlocked_brands_historyCountOrderByAggregateInput
    _max?: unlocked_brands_historyMaxOrderByAggregateInput
    _min?: unlocked_brands_historyMinOrderByAggregateInput
  }

  export type unlocked_brands_historyScalarWhereWithAggregatesInput = {
    AND?: unlocked_brands_historyScalarWhereWithAggregatesInput | unlocked_brands_historyScalarWhereWithAggregatesInput[]
    OR?: unlocked_brands_historyScalarWhereWithAggregatesInput[]
    NOT?: unlocked_brands_historyScalarWhereWithAggregatesInput | unlocked_brands_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"unlocked_brands_history"> | string
    userId?: StringWithAggregatesFilter<"unlocked_brands_history"> | string
    brandId?: StringNullableWithAggregatesFilter<"unlocked_brands_history"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"unlocked_brands_history"> | Date | string
  }

  export type brand_screen_timesWhereInput = {
    AND?: brand_screen_timesWhereInput | brand_screen_timesWhereInput[]
    OR?: brand_screen_timesWhereInput[]
    NOT?: brand_screen_timesWhereInput | brand_screen_timesWhereInput[]
    id?: StringFilter<"brand_screen_times"> | string
    time?: IntFilter<"brand_screen_times"> | number
    userId?: StringFilter<"brand_screen_times"> | string
    brandId?: StringNullableFilter<"brand_screen_times"> | string | null
    createdAt?: DateTimeFilter<"brand_screen_times"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
  }

  export type brand_screen_timesOrderByWithRelationInput = {
    id?: SortOrder
    time?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
    brand?: brandsOrderByWithRelationInput
  }

  export type brand_screen_timesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_brandId?: brand_screen_timesUserIdBrandIdCompoundUniqueInput
    AND?: brand_screen_timesWhereInput | brand_screen_timesWhereInput[]
    OR?: brand_screen_timesWhereInput[]
    NOT?: brand_screen_timesWhereInput | brand_screen_timesWhereInput[]
    time?: IntFilter<"brand_screen_times"> | number
    userId?: StringFilter<"brand_screen_times"> | string
    brandId?: StringNullableFilter<"brand_screen_times"> | string | null
    createdAt?: DateTimeFilter<"brand_screen_times"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
  }, "id" | "userId_brandId">

  export type brand_screen_timesOrderByWithAggregationInput = {
    id?: SortOrder
    time?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    _count?: brand_screen_timesCountOrderByAggregateInput
    _avg?: brand_screen_timesAvgOrderByAggregateInput
    _max?: brand_screen_timesMaxOrderByAggregateInput
    _min?: brand_screen_timesMinOrderByAggregateInput
    _sum?: brand_screen_timesSumOrderByAggregateInput
  }

  export type brand_screen_timesScalarWhereWithAggregatesInput = {
    AND?: brand_screen_timesScalarWhereWithAggregatesInput | brand_screen_timesScalarWhereWithAggregatesInput[]
    OR?: brand_screen_timesScalarWhereWithAggregatesInput[]
    NOT?: brand_screen_timesScalarWhereWithAggregatesInput | brand_screen_timesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"brand_screen_times"> | string
    time?: IntWithAggregatesFilter<"brand_screen_times"> | number
    userId?: StringWithAggregatesFilter<"brand_screen_times"> | string
    brandId?: StringNullableWithAggregatesFilter<"brand_screen_times"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"brand_screen_times"> | Date | string
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: StringFilter<"categories"> | string
    name?: JsonFilter<"categories">
    image?: JsonNullableFilter<"categories">
    createdAt?: DateTimeFilter<"categories"> | Date | string
    updatedAt?: DateTimeFilter<"categories"> | Date | string
    brands?: BrandsListRelationFilter
    userChoices?: Category_choicesListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brands?: brandsOrderByRelationAggregateInput
    userChoices?: category_choicesOrderByRelationAggregateInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    name?: JsonFilter<"categories">
    image?: JsonNullableFilter<"categories">
    createdAt?: DateTimeFilter<"categories"> | Date | string
    updatedAt?: DateTimeFilter<"categories"> | Date | string
    brands?: BrandsListRelationFilter
    userChoices?: Category_choicesListRelationFilter
  }, "id">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"categories"> | string
    name?: JsonWithAggregatesFilter<"categories">
    image?: JsonNullableWithAggregatesFilter<"categories">
    createdAt?: DateTimeWithAggregatesFilter<"categories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"categories"> | Date | string
  }

  export type category_choicesWhereInput = {
    AND?: category_choicesWhereInput | category_choicesWhereInput[]
    OR?: category_choicesWhereInput[]
    NOT?: category_choicesWhereInput | category_choicesWhereInput[]
    id?: StringFilter<"category_choices"> | string
    like?: BoolFilter<"category_choices"> | boolean
    categoryId?: StringFilter<"category_choices"> | string
    userId?: StringFilter<"category_choices"> | string
    createdAt?: DateTimeFilter<"category_choices"> | Date | string
    updatedAt?: DateTimeFilter<"category_choices"> | Date | string
    category?: XOR<CategoriesRelationFilter, categoriesWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type category_choicesOrderByWithRelationInput = {
    id?: SortOrder
    like?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: categoriesOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type category_choicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: category_choicesWhereInput | category_choicesWhereInput[]
    OR?: category_choicesWhereInput[]
    NOT?: category_choicesWhereInput | category_choicesWhereInput[]
    like?: BoolFilter<"category_choices"> | boolean
    categoryId?: StringFilter<"category_choices"> | string
    userId?: StringFilter<"category_choices"> | string
    createdAt?: DateTimeFilter<"category_choices"> | Date | string
    updatedAt?: DateTimeFilter<"category_choices"> | Date | string
    category?: XOR<CategoriesRelationFilter, categoriesWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type category_choicesOrderByWithAggregationInput = {
    id?: SortOrder
    like?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: category_choicesCountOrderByAggregateInput
    _max?: category_choicesMaxOrderByAggregateInput
    _min?: category_choicesMinOrderByAggregateInput
  }

  export type category_choicesScalarWhereWithAggregatesInput = {
    AND?: category_choicesScalarWhereWithAggregatesInput | category_choicesScalarWhereWithAggregatesInput[]
    OR?: category_choicesScalarWhereWithAggregatesInput[]
    NOT?: category_choicesScalarWhereWithAggregatesInput | category_choicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"category_choices"> | string
    like?: BoolWithAggregatesFilter<"category_choices"> | boolean
    categoryId?: StringWithAggregatesFilter<"category_choices"> | string
    userId?: StringWithAggregatesFilter<"category_choices"> | string
    createdAt?: DateTimeWithAggregatesFilter<"category_choices"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"category_choices"> | Date | string
  }

  export type foundersReachedLeaderboardWhereInput = {
    AND?: foundersReachedLeaderboardWhereInput | foundersReachedLeaderboardWhereInput[]
    OR?: foundersReachedLeaderboardWhereInput[]
    NOT?: foundersReachedLeaderboardWhereInput | foundersReachedLeaderboardWhereInput[]
    id?: StringFilter<"foundersReachedLeaderboard"> | string
    amount?: IntFilter<"foundersReachedLeaderboard"> | number
    users?: UsersListRelationFilter
  }

  export type foundersReachedLeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type foundersReachedLeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    amount?: number
    AND?: foundersReachedLeaderboardWhereInput | foundersReachedLeaderboardWhereInput[]
    OR?: foundersReachedLeaderboardWhereInput[]
    NOT?: foundersReachedLeaderboardWhereInput | foundersReachedLeaderboardWhereInput[]
    users?: UsersListRelationFilter
  }, "id" | "amount">

  export type foundersReachedLeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    _count?: foundersReachedLeaderboardCountOrderByAggregateInput
    _avg?: foundersReachedLeaderboardAvgOrderByAggregateInput
    _max?: foundersReachedLeaderboardMaxOrderByAggregateInput
    _min?: foundersReachedLeaderboardMinOrderByAggregateInput
    _sum?: foundersReachedLeaderboardSumOrderByAggregateInput
  }

  export type foundersReachedLeaderboardScalarWhereWithAggregatesInput = {
    AND?: foundersReachedLeaderboardScalarWhereWithAggregatesInput | foundersReachedLeaderboardScalarWhereWithAggregatesInput[]
    OR?: foundersReachedLeaderboardScalarWhereWithAggregatesInput[]
    NOT?: foundersReachedLeaderboardScalarWhereWithAggregatesInput | foundersReachedLeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"foundersReachedLeaderboard"> | string
    amount?: IntWithAggregatesFilter<"foundersReachedLeaderboard"> | number
  }

  export type link_visitsWhereInput = {
    AND?: link_visitsWhereInput | link_visitsWhereInput[]
    OR?: link_visitsWhereInput[]
    NOT?: link_visitsWhereInput | link_visitsWhereInput[]
    id?: StringFilter<"link_visits"> | string
    url?: StringFilter<"link_visits"> | string
    userId?: StringFilter<"link_visits"> | string
    brandId?: StringNullableFilter<"link_visits"> | string | null
    productId?: StringNullableFilter<"link_visits"> | string | null
    benefitId?: StringNullableFilter<"link_visits"> | string | null
    createdAt?: DateTimeFilter<"link_visits"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    product?: XOR<ProductsNullableRelationFilter, productsWhereInput> | null
    benefit?: XOR<BenefitsNullableRelationFilter, benefitsWhereInput> | null
  }

  export type link_visitsOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
    brand?: brandsOrderByWithRelationInput
    product?: productsOrderByWithRelationInput
    benefit?: benefitsOrderByWithRelationInput
  }

  export type link_visitsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: link_visitsWhereInput | link_visitsWhereInput[]
    OR?: link_visitsWhereInput[]
    NOT?: link_visitsWhereInput | link_visitsWhereInput[]
    url?: StringFilter<"link_visits"> | string
    userId?: StringFilter<"link_visits"> | string
    brandId?: StringNullableFilter<"link_visits"> | string | null
    productId?: StringNullableFilter<"link_visits"> | string | null
    benefitId?: StringNullableFilter<"link_visits"> | string | null
    createdAt?: DateTimeFilter<"link_visits"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    product?: XOR<ProductsNullableRelationFilter, productsWhereInput> | null
    benefit?: XOR<BenefitsNullableRelationFilter, benefitsWhereInput> | null
  }, "id">

  export type link_visitsOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    createdAt?: SortOrder
    _count?: link_visitsCountOrderByAggregateInput
    _max?: link_visitsMaxOrderByAggregateInput
    _min?: link_visitsMinOrderByAggregateInput
  }

  export type link_visitsScalarWhereWithAggregatesInput = {
    AND?: link_visitsScalarWhereWithAggregatesInput | link_visitsScalarWhereWithAggregatesInput[]
    OR?: link_visitsScalarWhereWithAggregatesInput[]
    NOT?: link_visitsScalarWhereWithAggregatesInput | link_visitsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"link_visits"> | string
    url?: StringWithAggregatesFilter<"link_visits"> | string
    userId?: StringWithAggregatesFilter<"link_visits"> | string
    brandId?: StringNullableWithAggregatesFilter<"link_visits"> | string | null
    productId?: StringNullableWithAggregatesFilter<"link_visits"> | string | null
    benefitId?: StringNullableWithAggregatesFilter<"link_visits"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"link_visits"> | Date | string
  }

  export type pitch_viewsWhereInput = {
    AND?: pitch_viewsWhereInput | pitch_viewsWhereInput[]
    OR?: pitch_viewsWhereInput[]
    NOT?: pitch_viewsWhereInput | pitch_viewsWhereInput[]
    id?: StringFilter<"pitch_views"> | string
    userId?: StringFilter<"pitch_views"> | string
    brandId?: StringNullableFilter<"pitch_views"> | string | null
    createdAt?: DateTimeFilter<"pitch_views"> | Date | string
    updatedAt?: DateTimeFilter<"pitch_views"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
  }

  export type pitch_viewsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    brand?: brandsOrderByWithRelationInput
  }

  export type pitch_viewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: pitch_viewsWhereInput | pitch_viewsWhereInput[]
    OR?: pitch_viewsWhereInput[]
    NOT?: pitch_viewsWhereInput | pitch_viewsWhereInput[]
    userId?: StringFilter<"pitch_views"> | string
    brandId?: StringNullableFilter<"pitch_views"> | string | null
    createdAt?: DateTimeFilter<"pitch_views"> | Date | string
    updatedAt?: DateTimeFilter<"pitch_views"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
  }, "id">

  export type pitch_viewsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pitch_viewsCountOrderByAggregateInput
    _max?: pitch_viewsMaxOrderByAggregateInput
    _min?: pitch_viewsMinOrderByAggregateInput
  }

  export type pitch_viewsScalarWhereWithAggregatesInput = {
    AND?: pitch_viewsScalarWhereWithAggregatesInput | pitch_viewsScalarWhereWithAggregatesInput[]
    OR?: pitch_viewsScalarWhereWithAggregatesInput[]
    NOT?: pitch_viewsScalarWhereWithAggregatesInput | pitch_viewsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"pitch_views"> | string
    userId?: StringWithAggregatesFilter<"pitch_views"> | string
    brandId?: StringNullableWithAggregatesFilter<"pitch_views"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"pitch_views"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"pitch_views"> | Date | string
  }

  export type postsWhereInput = {
    AND?: postsWhereInput | postsWhereInput[]
    OR?: postsWhereInput[]
    NOT?: postsWhereInput | postsWhereInput[]
    id?: StringFilter<"posts"> | string
    title?: StringFilter<"posts"> | string
    author?: StringNullableFilter<"posts"> | string | null
    content?: StringNullableFilter<"posts"> | string | null
    video?: StringNullableFilter<"posts"> | string | null
    image?: JsonNullableFilter<"posts">
    brandId?: StringNullableFilter<"posts"> | string | null
    userLikesIds?: StringNullableListFilter<"posts">
    createdAt?: DateTimeFilter<"posts"> | Date | string
    updatedAt?: DateTimeFilter<"posts"> | Date | string
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    userLikes?: UsersListRelationFilter
  }

  export type postsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    content?: SortOrder
    video?: SortOrder
    image?: SortOrder
    brandId?: SortOrder
    userLikesIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brand?: brandsOrderByWithRelationInput
    userLikes?: usersOrderByRelationAggregateInput
  }

  export type postsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: postsWhereInput | postsWhereInput[]
    OR?: postsWhereInput[]
    NOT?: postsWhereInput | postsWhereInput[]
    title?: StringFilter<"posts"> | string
    author?: StringNullableFilter<"posts"> | string | null
    content?: StringNullableFilter<"posts"> | string | null
    video?: StringNullableFilter<"posts"> | string | null
    image?: JsonNullableFilter<"posts">
    brandId?: StringNullableFilter<"posts"> | string | null
    userLikesIds?: StringNullableListFilter<"posts">
    createdAt?: DateTimeFilter<"posts"> | Date | string
    updatedAt?: DateTimeFilter<"posts"> | Date | string
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    userLikes?: UsersListRelationFilter
  }, "id">

  export type postsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    content?: SortOrder
    video?: SortOrder
    image?: SortOrder
    brandId?: SortOrder
    userLikesIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: postsCountOrderByAggregateInput
    _max?: postsMaxOrderByAggregateInput
    _min?: postsMinOrderByAggregateInput
  }

  export type postsScalarWhereWithAggregatesInput = {
    AND?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]
    OR?: postsScalarWhereWithAggregatesInput[]
    NOT?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"posts"> | string
    title?: StringWithAggregatesFilter<"posts"> | string
    author?: StringNullableWithAggregatesFilter<"posts"> | string | null
    content?: StringNullableWithAggregatesFilter<"posts"> | string | null
    video?: StringNullableWithAggregatesFilter<"posts"> | string | null
    image?: JsonNullableWithAggregatesFilter<"posts">
    brandId?: StringNullableWithAggregatesFilter<"posts"> | string | null
    userLikesIds?: StringNullableListFilter<"posts">
    createdAt?: DateTimeWithAggregatesFilter<"posts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"posts"> | Date | string
  }

  export type production_submissionsWhereInput = {
    AND?: production_submissionsWhereInput | production_submissionsWhereInput[]
    OR?: production_submissionsWhereInput[]
    NOT?: production_submissionsWhereInput | production_submissionsWhereInput[]
    id?: StringFilter<"production_submissions"> | string
    overlays?: JsonNullableListFilter<"production_submissions">
    videos?: JsonNullableListFilter<"production_submissions">
    status?: StringFilter<"production_submissions"> | string
    createdAt?: DateTimeFilter<"production_submissions"> | Date | string
    updatedAt?: DateTimeFilter<"production_submissions"> | Date | string
    brandId?: StringFilter<"production_submissions"> | string
    userId?: StringFilter<"production_submissions"> | string
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type production_submissionsOrderByWithRelationInput = {
    id?: SortOrder
    overlays?: SortOrder
    videos?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brandId?: SortOrder
    userId?: SortOrder
    brand?: brandsOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type production_submissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: production_submissionsWhereInput | production_submissionsWhereInput[]
    OR?: production_submissionsWhereInput[]
    NOT?: production_submissionsWhereInput | production_submissionsWhereInput[]
    overlays?: JsonNullableListFilter<"production_submissions">
    videos?: JsonNullableListFilter<"production_submissions">
    status?: StringFilter<"production_submissions"> | string
    createdAt?: DateTimeFilter<"production_submissions"> | Date | string
    updatedAt?: DateTimeFilter<"production_submissions"> | Date | string
    brandId?: StringFilter<"production_submissions"> | string
    userId?: StringFilter<"production_submissions"> | string
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type production_submissionsOrderByWithAggregationInput = {
    id?: SortOrder
    overlays?: SortOrder
    videos?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brandId?: SortOrder
    userId?: SortOrder
    _count?: production_submissionsCountOrderByAggregateInput
    _max?: production_submissionsMaxOrderByAggregateInput
    _min?: production_submissionsMinOrderByAggregateInput
  }

  export type production_submissionsScalarWhereWithAggregatesInput = {
    AND?: production_submissionsScalarWhereWithAggregatesInput | production_submissionsScalarWhereWithAggregatesInput[]
    OR?: production_submissionsScalarWhereWithAggregatesInput[]
    NOT?: production_submissionsScalarWhereWithAggregatesInput | production_submissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"production_submissions"> | string
    overlays?: JsonNullableListFilter<"production_submissions">
    videos?: JsonNullableListFilter<"production_submissions">
    status?: StringWithAggregatesFilter<"production_submissions"> | string
    createdAt?: DateTimeWithAggregatesFilter<"production_submissions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"production_submissions"> | Date | string
    brandId?: StringWithAggregatesFilter<"production_submissions"> | string
    userId?: StringWithAggregatesFilter<"production_submissions"> | string
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    id?: StringFilter<"products"> | string
    description?: JsonNullableFilter<"products">
    images?: JsonNullableListFilter<"products">
    regularPrice?: StringNullableFilter<"products"> | string | null
    deal?: StringNullableFilter<"products"> | string | null
    dealPrice?: StringNullableFilter<"products"> | string | null
    purchaseUrl?: StringNullableFilter<"products"> | string | null
    brandId?: StringFilter<"products"> | string
    name?: StringFilter<"products"> | string
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
    uniqueDeal?: BoolNullableFilter<"products"> | boolean | null
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
    linkVisits?: Link_visitsListRelationFilter
    ratings?: RatingsListRelationFilter
  }

  export type productsOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    images?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
    brand?: brandsOrderByWithRelationInput
    linkVisits?: link_visitsOrderByRelationAggregateInput
    ratings?: ratingsOrderByRelationAggregateInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    description?: JsonNullableFilter<"products">
    images?: JsonNullableListFilter<"products">
    regularPrice?: StringNullableFilter<"products"> | string | null
    deal?: StringNullableFilter<"products"> | string | null
    dealPrice?: StringNullableFilter<"products"> | string | null
    purchaseUrl?: StringNullableFilter<"products"> | string | null
    brandId?: StringFilter<"products"> | string
    name?: StringFilter<"products"> | string
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
    uniqueDeal?: BoolNullableFilter<"products"> | boolean | null
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
    linkVisits?: Link_visitsListRelationFilter
    ratings?: RatingsListRelationFilter
  }, "id">

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    images?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
    _count?: productsCountOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"products"> | string
    description?: JsonNullableWithAggregatesFilter<"products">
    images?: JsonNullableListFilter<"products">
    regularPrice?: StringNullableWithAggregatesFilter<"products"> | string | null
    deal?: StringNullableWithAggregatesFilter<"products"> | string | null
    dealPrice?: StringNullableWithAggregatesFilter<"products"> | string | null
    purchaseUrl?: StringNullableWithAggregatesFilter<"products"> | string | null
    brandId?: StringWithAggregatesFilter<"products"> | string
    name?: StringWithAggregatesFilter<"products"> | string
    createdAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
    uniqueDeal?: BoolNullableWithAggregatesFilter<"products"> | boolean | null
  }

  export type push_notificationsWhereInput = {
    AND?: push_notificationsWhereInput | push_notificationsWhereInput[]
    OR?: push_notificationsWhereInput[]
    NOT?: push_notificationsWhereInput | push_notificationsWhereInput[]
    id?: StringFilter<"push_notifications"> | string
    title?: StringNullableFilter<"push_notifications"> | string | null
    content?: StringFilter<"push_notifications"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notifications"> | $Enums.NotificationType | null
    minDaysInactive?: IntNullableFilter<"push_notifications"> | number | null
    oneTimeOnly?: BoolNullableFilter<"push_notifications"> | boolean | null
    sendAfterInactiveDays?: IntNullableFilter<"push_notifications"> | number | null
    repeatAfterDays?: IntNullableFilter<"push_notifications"> | number | null
    daysAfterActivation?: IntNullableFilter<"push_notifications"> | number | null
    daysBeforeExpiry?: IntNullableFilter<"push_notifications"> | number | null
  }

  export type push_notificationsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: push_notificationsWhereInput | push_notificationsWhereInput[]
    OR?: push_notificationsWhereInput[]
    NOT?: push_notificationsWhereInput | push_notificationsWhereInput[]
    title?: StringNullableFilter<"push_notifications"> | string | null
    content?: StringFilter<"push_notifications"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notifications"> | $Enums.NotificationType | null
    minDaysInactive?: IntNullableFilter<"push_notifications"> | number | null
    oneTimeOnly?: BoolNullableFilter<"push_notifications"> | boolean | null
    sendAfterInactiveDays?: IntNullableFilter<"push_notifications"> | number | null
    repeatAfterDays?: IntNullableFilter<"push_notifications"> | number | null
    daysAfterActivation?: IntNullableFilter<"push_notifications"> | number | null
    daysBeforeExpiry?: IntNullableFilter<"push_notifications"> | number | null
  }, "id">

  export type push_notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
    _count?: push_notificationsCountOrderByAggregateInput
    _avg?: push_notificationsAvgOrderByAggregateInput
    _max?: push_notificationsMaxOrderByAggregateInput
    _min?: push_notificationsMinOrderByAggregateInput
    _sum?: push_notificationsSumOrderByAggregateInput
  }

  export type push_notificationsScalarWhereWithAggregatesInput = {
    AND?: push_notificationsScalarWhereWithAggregatesInput | push_notificationsScalarWhereWithAggregatesInput[]
    OR?: push_notificationsScalarWhereWithAggregatesInput[]
    NOT?: push_notificationsScalarWhereWithAggregatesInput | push_notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"push_notifications"> | string
    title?: StringNullableWithAggregatesFilter<"push_notifications"> | string | null
    content?: StringWithAggregatesFilter<"push_notifications"> | string
    type?: EnumNotificationTypeNullableWithAggregatesFilter<"push_notifications"> | $Enums.NotificationType | null
    minDaysInactive?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
    oneTimeOnly?: BoolNullableWithAggregatesFilter<"push_notifications"> | boolean | null
    sendAfterInactiveDays?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
    repeatAfterDays?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
    daysAfterActivation?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
    daysBeforeExpiry?: IntNullableWithAggregatesFilter<"push_notifications"> | number | null
  }

  export type push_notification_historyWhereInput = {
    AND?: push_notification_historyWhereInput | push_notification_historyWhereInput[]
    OR?: push_notification_historyWhereInput[]
    NOT?: push_notification_historyWhereInput | push_notification_historyWhereInput[]
    id?: StringFilter<"push_notification_history"> | string
    userId?: StringFilter<"push_notification_history"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notification_history"> | $Enums.NotificationType | null
    entityId?: StringNullableFilter<"push_notification_history"> | string | null
    content?: StringFilter<"push_notification_history"> | string
    title?: StringFilter<"push_notification_history"> | string
    sentAt?: DateTimeFilter<"push_notification_history"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type push_notification_historyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type push_notification_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: push_notification_historyWhereInput | push_notification_historyWhereInput[]
    OR?: push_notification_historyWhereInput[]
    NOT?: push_notification_historyWhereInput | push_notification_historyWhereInput[]
    userId?: StringFilter<"push_notification_history"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notification_history"> | $Enums.NotificationType | null
    entityId?: StringNullableFilter<"push_notification_history"> | string | null
    content?: StringFilter<"push_notification_history"> | string
    title?: StringFilter<"push_notification_history"> | string
    sentAt?: DateTimeFilter<"push_notification_history"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type push_notification_historyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
    _count?: push_notification_historyCountOrderByAggregateInput
    _max?: push_notification_historyMaxOrderByAggregateInput
    _min?: push_notification_historyMinOrderByAggregateInput
  }

  export type push_notification_historyScalarWhereWithAggregatesInput = {
    AND?: push_notification_historyScalarWhereWithAggregatesInput | push_notification_historyScalarWhereWithAggregatesInput[]
    OR?: push_notification_historyScalarWhereWithAggregatesInput[]
    NOT?: push_notification_historyScalarWhereWithAggregatesInput | push_notification_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"push_notification_history"> | string
    userId?: StringWithAggregatesFilter<"push_notification_history"> | string
    type?: EnumNotificationTypeNullableWithAggregatesFilter<"push_notification_history"> | $Enums.NotificationType | null
    entityId?: StringNullableWithAggregatesFilter<"push_notification_history"> | string | null
    content?: StringWithAggregatesFilter<"push_notification_history"> | string
    title?: StringWithAggregatesFilter<"push_notification_history"> | string
    sentAt?: DateTimeWithAggregatesFilter<"push_notification_history"> | Date | string
  }

  export type questionnairesWhereInput = {
    AND?: questionnairesWhereInput | questionnairesWhereInput[]
    OR?: questionnairesWhereInput[]
    NOT?: questionnairesWhereInput | questionnairesWhereInput[]
    id?: StringFilter<"questionnaires"> | string
    name?: StringFilter<"questionnaires"> | string
    createdAt?: DateTimeFilter<"questionnaires"> | Date | string
    updatedAt?: DateTimeFilter<"questionnaires"> | Date | string
    questions?: QuestionsListRelationFilter
    level?: XOR<LevelsNullableRelationFilter, levelsWhereInput> | null
  }

  export type questionnairesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: questionsOrderByRelationAggregateInput
    level?: levelsOrderByWithRelationInput
  }

  export type questionnairesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: questionnairesWhereInput | questionnairesWhereInput[]
    OR?: questionnairesWhereInput[]
    NOT?: questionnairesWhereInput | questionnairesWhereInput[]
    name?: StringFilter<"questionnaires"> | string
    createdAt?: DateTimeFilter<"questionnaires"> | Date | string
    updatedAt?: DateTimeFilter<"questionnaires"> | Date | string
    questions?: QuestionsListRelationFilter
    level?: XOR<LevelsNullableRelationFilter, levelsWhereInput> | null
  }, "id">

  export type questionnairesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: questionnairesCountOrderByAggregateInput
    _max?: questionnairesMaxOrderByAggregateInput
    _min?: questionnairesMinOrderByAggregateInput
  }

  export type questionnairesScalarWhereWithAggregatesInput = {
    AND?: questionnairesScalarWhereWithAggregatesInput | questionnairesScalarWhereWithAggregatesInput[]
    OR?: questionnairesScalarWhereWithAggregatesInput[]
    NOT?: questionnairesScalarWhereWithAggregatesInput | questionnairesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"questionnaires"> | string
    name?: StringWithAggregatesFilter<"questionnaires"> | string
    createdAt?: DateTimeWithAggregatesFilter<"questionnaires"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"questionnaires"> | Date | string
  }

  export type question_classesWhereInput = {
    AND?: question_classesWhereInput | question_classesWhereInput[]
    OR?: question_classesWhereInput[]
    NOT?: question_classesWhereInput | question_classesWhereInput[]
    id?: StringFilter<"question_classes"> | string
    name?: StringFilter<"question_classes"> | string
    editable?: BoolFilter<"question_classes"> | boolean
    createdAt?: DateTimeFilter<"question_classes"> | Date | string
    updatedAt?: DateTimeFilter<"question_classes"> | Date | string
    questions?: QuestionsListRelationFilter
  }

  export type question_classesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    editable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: questionsOrderByRelationAggregateInput
  }

  export type question_classesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: question_classesWhereInput | question_classesWhereInput[]
    OR?: question_classesWhereInput[]
    NOT?: question_classesWhereInput | question_classesWhereInput[]
    name?: StringFilter<"question_classes"> | string
    editable?: BoolFilter<"question_classes"> | boolean
    createdAt?: DateTimeFilter<"question_classes"> | Date | string
    updatedAt?: DateTimeFilter<"question_classes"> | Date | string
    questions?: QuestionsListRelationFilter
  }, "id">

  export type question_classesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    editable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: question_classesCountOrderByAggregateInput
    _max?: question_classesMaxOrderByAggregateInput
    _min?: question_classesMinOrderByAggregateInput
  }

  export type question_classesScalarWhereWithAggregatesInput = {
    AND?: question_classesScalarWhereWithAggregatesInput | question_classesScalarWhereWithAggregatesInput[]
    OR?: question_classesScalarWhereWithAggregatesInput[]
    NOT?: question_classesScalarWhereWithAggregatesInput | question_classesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"question_classes"> | string
    name?: StringWithAggregatesFilter<"question_classes"> | string
    editable?: BoolWithAggregatesFilter<"question_classes"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"question_classes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"question_classes"> | Date | string
  }

  export type questionsWhereInput = {
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    id?: StringFilter<"questions"> | string
    position?: IntFilter<"questions"> | number
    question?: JsonFilter<"questions">
    type?: StringFilter<"questions"> | string
    options?: JsonNullableListFilter<"questions">
    classId?: StringNullableFilter<"questions"> | string | null
    categoryId?: StringNullableFilter<"questions"> | string | null
    onboarding?: BoolFilter<"questions"> | boolean
    randomizeOptions?: BoolNullableFilter<"questions"> | boolean | null
    fixedOptionSize?: BoolNullableFilter<"questions"> | boolean | null
    hideOptionText?: BoolNullableFilter<"questions"> | boolean | null
    displayImage?: JsonNullableFilter<"questions">
    footnote?: JsonNullableFilter<"questions">
    subtitle?: JsonNullableFilter<"questions">
    products?: JsonNullableFilter<"questions">
    brandId?: StringNullableFilter<"questions"> | string | null
    correctAnswerId?: StringNullableFilter<"questions"> | string | null
    questionnaireId?: StringNullableFilter<"questions"> | string | null
    questionnaireSubCategory?: IntNullableFilter<"questions"> | number | null
    createdAt?: DateTimeFilter<"questions"> | Date | string
    updatedAt?: DateTimeFilter<"questions"> | Date | string
    scaleTopLabel?: JsonNullableFilter<"questions">
    scaleBottomLabel?: JsonNullableFilter<"questions">
    maxOptions?: IntNullableFilter<"questions"> | number | null
    questionClass?: XOR<Question_classesNullableRelationFilter, question_classesWhereInput> | null
    answers?: AnswersListRelationFilter
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    questionnaire?: XOR<QuestionnairesNullableRelationFilter, questionnairesWhereInput> | null
  }

  export type questionsOrderByWithRelationInput = {
    id?: SortOrder
    position?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    displayImage?: SortOrder
    footnote?: SortOrder
    subtitle?: SortOrder
    products?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scaleTopLabel?: SortOrder
    scaleBottomLabel?: SortOrder
    maxOptions?: SortOrder
    questionClass?: question_classesOrderByWithRelationInput
    answers?: answersOrderByRelationAggregateInput
    brand?: brandsOrderByWithRelationInput
    questionnaire?: questionnairesOrderByWithRelationInput
  }

  export type questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    position?: IntFilter<"questions"> | number
    question?: JsonFilter<"questions">
    type?: StringFilter<"questions"> | string
    options?: JsonNullableListFilter<"questions">
    classId?: StringNullableFilter<"questions"> | string | null
    categoryId?: StringNullableFilter<"questions"> | string | null
    onboarding?: BoolFilter<"questions"> | boolean
    randomizeOptions?: BoolNullableFilter<"questions"> | boolean | null
    fixedOptionSize?: BoolNullableFilter<"questions"> | boolean | null
    hideOptionText?: BoolNullableFilter<"questions"> | boolean | null
    displayImage?: JsonNullableFilter<"questions">
    footnote?: JsonNullableFilter<"questions">
    subtitle?: JsonNullableFilter<"questions">
    products?: JsonNullableFilter<"questions">
    brandId?: StringNullableFilter<"questions"> | string | null
    correctAnswerId?: StringNullableFilter<"questions"> | string | null
    questionnaireId?: StringNullableFilter<"questions"> | string | null
    questionnaireSubCategory?: IntNullableFilter<"questions"> | number | null
    createdAt?: DateTimeFilter<"questions"> | Date | string
    updatedAt?: DateTimeFilter<"questions"> | Date | string
    scaleTopLabel?: JsonNullableFilter<"questions">
    scaleBottomLabel?: JsonNullableFilter<"questions">
    maxOptions?: IntNullableFilter<"questions"> | number | null
    questionClass?: XOR<Question_classesNullableRelationFilter, question_classesWhereInput> | null
    answers?: AnswersListRelationFilter
    brand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    questionnaire?: XOR<QuestionnairesNullableRelationFilter, questionnairesWhereInput> | null
  }, "id">

  export type questionsOrderByWithAggregationInput = {
    id?: SortOrder
    position?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    displayImage?: SortOrder
    footnote?: SortOrder
    subtitle?: SortOrder
    products?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scaleTopLabel?: SortOrder
    scaleBottomLabel?: SortOrder
    maxOptions?: SortOrder
    _count?: questionsCountOrderByAggregateInput
    _avg?: questionsAvgOrderByAggregateInput
    _max?: questionsMaxOrderByAggregateInput
    _min?: questionsMinOrderByAggregateInput
    _sum?: questionsSumOrderByAggregateInput
  }

  export type questionsScalarWhereWithAggregatesInput = {
    AND?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    OR?: questionsScalarWhereWithAggregatesInput[]
    NOT?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"questions"> | string
    position?: IntWithAggregatesFilter<"questions"> | number
    question?: JsonWithAggregatesFilter<"questions">
    type?: StringWithAggregatesFilter<"questions"> | string
    options?: JsonNullableListFilter<"questions">
    classId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    onboarding?: BoolWithAggregatesFilter<"questions"> | boolean
    randomizeOptions?: BoolNullableWithAggregatesFilter<"questions"> | boolean | null
    fixedOptionSize?: BoolNullableWithAggregatesFilter<"questions"> | boolean | null
    hideOptionText?: BoolNullableWithAggregatesFilter<"questions"> | boolean | null
    displayImage?: JsonNullableWithAggregatesFilter<"questions">
    footnote?: JsonNullableWithAggregatesFilter<"questions">
    subtitle?: JsonNullableWithAggregatesFilter<"questions">
    products?: JsonNullableWithAggregatesFilter<"questions">
    brandId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    correctAnswerId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    questionnaireId?: StringNullableWithAggregatesFilter<"questions"> | string | null
    questionnaireSubCategory?: IntNullableWithAggregatesFilter<"questions"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"questions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"questions"> | Date | string
    scaleTopLabel?: JsonNullableWithAggregatesFilter<"questions">
    scaleBottomLabel?: JsonNullableWithAggregatesFilter<"questions">
    maxOptions?: IntNullableWithAggregatesFilter<"questions"> | number | null
  }

  export type ratingsWhereInput = {
    AND?: ratingsWhereInput | ratingsWhereInput[]
    OR?: ratingsWhereInput[]
    NOT?: ratingsWhereInput | ratingsWhereInput[]
    id?: StringFilter<"ratings"> | string
    userId?: StringFilter<"ratings"> | string
    productId?: StringNullableFilter<"ratings"> | string | null
    brandId?: StringFilter<"ratings"> | string
    rating?: FloatFilter<"ratings"> | number
    createdAt?: DateTimeFilter<"ratings"> | Date | string
    updatedAt?: DateTimeFilter<"ratings"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    product?: XOR<ProductsNullableRelationFilter, productsWhereInput> | null
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
  }

  export type ratingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    brandId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    product?: productsOrderByWithRelationInput
    brand?: brandsOrderByWithRelationInput
  }

  export type ratingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_brandId?: ratingsUserIdBrandIdCompoundUniqueInput
    AND?: ratingsWhereInput | ratingsWhereInput[]
    OR?: ratingsWhereInput[]
    NOT?: ratingsWhereInput | ratingsWhereInput[]
    userId?: StringFilter<"ratings"> | string
    productId?: StringNullableFilter<"ratings"> | string | null
    brandId?: StringFilter<"ratings"> | string
    rating?: FloatFilter<"ratings"> | number
    createdAt?: DateTimeFilter<"ratings"> | Date | string
    updatedAt?: DateTimeFilter<"ratings"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    product?: XOR<ProductsNullableRelationFilter, productsWhereInput> | null
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
  }, "id" | "userId_brandId">

  export type ratingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    brandId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ratingsCountOrderByAggregateInput
    _avg?: ratingsAvgOrderByAggregateInput
    _max?: ratingsMaxOrderByAggregateInput
    _min?: ratingsMinOrderByAggregateInput
    _sum?: ratingsSumOrderByAggregateInput
  }

  export type ratingsScalarWhereWithAggregatesInput = {
    AND?: ratingsScalarWhereWithAggregatesInput | ratingsScalarWhereWithAggregatesInput[]
    OR?: ratingsScalarWhereWithAggregatesInput[]
    NOT?: ratingsScalarWhereWithAggregatesInput | ratingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ratings"> | string
    userId?: StringWithAggregatesFilter<"ratings"> | string
    productId?: StringNullableWithAggregatesFilter<"ratings"> | string | null
    brandId?: StringWithAggregatesFilter<"ratings"> | string
    rating?: FloatWithAggregatesFilter<"ratings"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ratings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ratings"> | Date | string
  }

  export type settingsWhereInput = {
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    id?: StringFilter<"settings"> | string
    userId?: StringFilter<"settings"> | string
    receiveNotifications?: BoolFilter<"settings"> | boolean
    newBrands?: BoolFilter<"settings"> | boolean
    personalizedOffers?: BoolFilter<"settings"> | boolean
    createdAt?: DateTimeFilter<"settings"> | Date | string
    updatedAt?: DateTimeFilter<"settings"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type settingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    receiveNotifications?: SortOrder
    newBrands?: SortOrder
    personalizedOffers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    receiveNotifications?: BoolFilter<"settings"> | boolean
    newBrands?: BoolFilter<"settings"> | boolean
    personalizedOffers?: BoolFilter<"settings"> | boolean
    createdAt?: DateTimeFilter<"settings"> | Date | string
    updatedAt?: DateTimeFilter<"settings"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type settingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    receiveNotifications?: SortOrder
    newBrands?: SortOrder
    personalizedOffers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: settingsCountOrderByAggregateInput
    _max?: settingsMaxOrderByAggregateInput
    _min?: settingsMinOrderByAggregateInput
  }

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    OR?: settingsScalarWhereWithAggregatesInput[]
    NOT?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"settings"> | string
    userId?: StringWithAggregatesFilter<"settings"> | string
    receiveNotifications?: BoolWithAggregatesFilter<"settings"> | boolean
    newBrands?: BoolWithAggregatesFilter<"settings"> | boolean
    personalizedOffers?: BoolWithAggregatesFilter<"settings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"settings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"settings"> | Date | string
  }

  export type terms_and_conditionsWhereInput = {
    AND?: terms_and_conditionsWhereInput | terms_and_conditionsWhereInput[]
    OR?: terms_and_conditionsWhereInput[]
    NOT?: terms_and_conditionsWhereInput | terms_and_conditionsWhereInput[]
    id?: StringFilter<"terms_and_conditions"> | string
    userId?: StringFilter<"terms_and_conditions"> | string
    userEmailAddress?: StringFilter<"terms_and_conditions"> | string
    acceptanceDate?: DateTimeFilter<"terms_and_conditions"> | Date | string
    createdAt?: DateTimeFilter<"terms_and_conditions"> | Date | string
    updatedAt?: DateTimeFilter<"terms_and_conditions"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type terms_and_conditionsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmailAddress?: SortOrder
    acceptanceDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type terms_and_conditionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: terms_and_conditionsWhereInput | terms_and_conditionsWhereInput[]
    OR?: terms_and_conditionsWhereInput[]
    NOT?: terms_and_conditionsWhereInput | terms_and_conditionsWhereInput[]
    userEmailAddress?: StringFilter<"terms_and_conditions"> | string
    acceptanceDate?: DateTimeFilter<"terms_and_conditions"> | Date | string
    createdAt?: DateTimeFilter<"terms_and_conditions"> | Date | string
    updatedAt?: DateTimeFilter<"terms_and_conditions"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type terms_and_conditionsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmailAddress?: SortOrder
    acceptanceDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: terms_and_conditionsCountOrderByAggregateInput
    _max?: terms_and_conditionsMaxOrderByAggregateInput
    _min?: terms_and_conditionsMinOrderByAggregateInput
  }

  export type terms_and_conditionsScalarWhereWithAggregatesInput = {
    AND?: terms_and_conditionsScalarWhereWithAggregatesInput | terms_and_conditionsScalarWhereWithAggregatesInput[]
    OR?: terms_and_conditionsScalarWhereWithAggregatesInput[]
    NOT?: terms_and_conditionsScalarWhereWithAggregatesInput | terms_and_conditionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"terms_and_conditions"> | string
    userId?: StringWithAggregatesFilter<"terms_and_conditions"> | string
    userEmailAddress?: StringWithAggregatesFilter<"terms_and_conditions"> | string
    acceptanceDate?: DateTimeWithAggregatesFilter<"terms_and_conditions"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"terms_and_conditions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"terms_and_conditions"> | Date | string
  }

  export type feedbackWhereInput = {
    AND?: feedbackWhereInput | feedbackWhereInput[]
    OR?: feedbackWhereInput[]
    NOT?: feedbackWhereInput | feedbackWhereInput[]
    id?: StringFilter<"feedback"> | string
    userId?: StringFilter<"feedback"> | string
    text?: StringFilter<"feedback"> | string
    email?: StringNullableFilter<"feedback"> | string | null
    createdAt?: DateTimeFilter<"feedback"> | Date | string
    updatedAt?: DateTimeFilter<"feedback"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type feedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type feedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: feedbackWhereInput | feedbackWhereInput[]
    OR?: feedbackWhereInput[]
    NOT?: feedbackWhereInput | feedbackWhereInput[]
    userId?: StringFilter<"feedback"> | string
    text?: StringFilter<"feedback"> | string
    email?: StringNullableFilter<"feedback"> | string | null
    createdAt?: DateTimeFilter<"feedback"> | Date | string
    updatedAt?: DateTimeFilter<"feedback"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type feedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: feedbackCountOrderByAggregateInput
    _max?: feedbackMaxOrderByAggregateInput
    _min?: feedbackMinOrderByAggregateInput
  }

  export type feedbackScalarWhereWithAggregatesInput = {
    AND?: feedbackScalarWhereWithAggregatesInput | feedbackScalarWhereWithAggregatesInput[]
    OR?: feedbackScalarWhereWithAggregatesInput[]
    NOT?: feedbackScalarWhereWithAggregatesInput | feedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"feedback"> | string
    userId?: StringWithAggregatesFilter<"feedback"> | string
    text?: StringWithAggregatesFilter<"feedback"> | string
    email?: StringNullableWithAggregatesFilter<"feedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"feedback"> | Date | string
  }

  export type levelsWhereInput = {
    AND?: levelsWhereInput | levelsWhereInput[]
    OR?: levelsWhereInput[]
    NOT?: levelsWhereInput | levelsWhereInput[]
    id?: StringFilter<"levels"> | string
    name?: StringFilter<"levels"> | string
    order?: IntFilter<"levels"> | number
    requiredBrandsExplored?: IntFilter<"levels"> | number
    requiredAnswers?: IntFilter<"levels"> | number
    questionnaireId?: StringNullableFilter<"levels"> | string | null
    createdAt?: DateTimeFilter<"levels"> | Date | string
    updatedAt?: DateTimeFilter<"levels"> | Date | string
    questionnaire?: XOR<QuestionnairesNullableRelationFilter, questionnairesWhereInput> | null
    benefits?: BenefitsListRelationFilter
    users?: UsersListRelationFilter
  }

  export type levelsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    requiredBrandsExplored?: SortOrder
    requiredAnswers?: SortOrder
    questionnaireId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questionnaire?: questionnairesOrderByWithRelationInput
    benefits?: benefitsOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type levelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    order?: number
    questionnaireId?: string
    AND?: levelsWhereInput | levelsWhereInput[]
    OR?: levelsWhereInput[]
    NOT?: levelsWhereInput | levelsWhereInput[]
    requiredBrandsExplored?: IntFilter<"levels"> | number
    requiredAnswers?: IntFilter<"levels"> | number
    createdAt?: DateTimeFilter<"levels"> | Date | string
    updatedAt?: DateTimeFilter<"levels"> | Date | string
    questionnaire?: XOR<QuestionnairesNullableRelationFilter, questionnairesWhereInput> | null
    benefits?: BenefitsListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "name" | "order" | "questionnaireId">

  export type levelsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    requiredBrandsExplored?: SortOrder
    requiredAnswers?: SortOrder
    questionnaireId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: levelsCountOrderByAggregateInput
    _avg?: levelsAvgOrderByAggregateInput
    _max?: levelsMaxOrderByAggregateInput
    _min?: levelsMinOrderByAggregateInput
    _sum?: levelsSumOrderByAggregateInput
  }

  export type levelsScalarWhereWithAggregatesInput = {
    AND?: levelsScalarWhereWithAggregatesInput | levelsScalarWhereWithAggregatesInput[]
    OR?: levelsScalarWhereWithAggregatesInput[]
    NOT?: levelsScalarWhereWithAggregatesInput | levelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"levels"> | string
    name?: StringWithAggregatesFilter<"levels"> | string
    order?: IntWithAggregatesFilter<"levels"> | number
    requiredBrandsExplored?: IntWithAggregatesFilter<"levels"> | number
    requiredAnswers?: IntWithAggregatesFilter<"levels"> | number
    questionnaireId?: StringNullableWithAggregatesFilter<"levels"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"levels"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"levels"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    myFavourites?: JsonNullableListFilter<"users">
    hasAcceptedTermsAndConditions?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    name?: StringNullableFilter<"users"> | string | null
    notificationsToken?: StringNullableFilter<"users"> | string | null
    forYouBrandsIds?: StringNullableListFilter<"users">
    forYouBrandsPoolIds?: StringNullableListFilter<"users">
    notInterestedBrandsIds?: StringNullableListFilter<"users">
    levelId?: StringNullableFilter<"users"> | string | null
    brandsExplored?: IntFilter<"users"> | number
    ownedBrandId?: StringNullableFilter<"users"> | string | null
    foundersReachedLeaderboardId?: StringNullableFilter<"users"> | string | null
    viewedPitches?: StringNullableListFilter<"users">
    targetGender?: EnumGenderPreferenceNullableFilter<"users"> | $Enums.GenderPreference | null
    budgetInterval?: IntNullableFilter<"users"> | number | null
    deletedBrands?: StringNullableListFilter<"users">
    superUser?: BoolNullableFilter<"users"> | boolean | null
    hasNewForYouBrands?: BoolFilter<"users"> | boolean
    likedPostsIds?: StringNullableListFilter<"users">
    lastOpened?: DateTimeNullableFilter<"users"> | Date | string | null
    answers?: AnswersListRelationFilter
    pitchViews?: Pitch_viewsListRelationFilter
    settings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
    ratings?: RatingsListRelationFilter
    forYouBrands?: BrandsListRelationFilter
    forYouBrandsPool?: BrandsListRelationFilter
    notInterestedBrands?: BrandsListRelationFilter
    linkVisits?: Link_visitsListRelationFilter
    brandScreenTimes?: Brand_screen_timesListRelationFilter
    termsAndConditions?: XOR<Terms_and_conditionsNullableRelationFilter, terms_and_conditionsWhereInput> | null
    feedbacks?: FeedbackListRelationFilter
    level?: XOR<LevelsNullableRelationFilter, levelsWhereInput> | null
    ownedBrand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    productionSubmissions?: Production_submissionsListRelationFilter
    foundersReachedLeaderboard?: XOR<FoundersReachedLeaderboardNullableRelationFilter, foundersReachedLeaderboardWhereInput> | null
    dealCodes?: Deal_codesListRelationFilter
    brandUnlockHistory?: Unlocked_brands_historyListRelationFilter
    categoryChoices?: Category_choicesListRelationFilter
    likedPosts?: PostsListRelationFilter
    pushNotificationHistory?: Push_notification_historyListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    myFavourites?: SortOrder
    hasAcceptedTermsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    forYouBrandsIds?: SortOrder
    forYouBrandsPoolIds?: SortOrder
    notInterestedBrandsIds?: SortOrder
    levelId?: SortOrder
    brandsExplored?: SortOrder
    ownedBrandId?: SortOrder
    foundersReachedLeaderboardId?: SortOrder
    viewedPitches?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    deletedBrands?: SortOrder
    superUser?: SortOrder
    hasNewForYouBrands?: SortOrder
    likedPostsIds?: SortOrder
    lastOpened?: SortOrder
    answers?: answersOrderByRelationAggregateInput
    pitchViews?: pitch_viewsOrderByRelationAggregateInput
    settings?: settingsOrderByWithRelationInput
    ratings?: ratingsOrderByRelationAggregateInput
    forYouBrands?: brandsOrderByRelationAggregateInput
    forYouBrandsPool?: brandsOrderByRelationAggregateInput
    notInterestedBrands?: brandsOrderByRelationAggregateInput
    linkVisits?: link_visitsOrderByRelationAggregateInput
    brandScreenTimes?: brand_screen_timesOrderByRelationAggregateInput
    termsAndConditions?: terms_and_conditionsOrderByWithRelationInput
    feedbacks?: feedbackOrderByRelationAggregateInput
    level?: levelsOrderByWithRelationInput
    ownedBrand?: brandsOrderByWithRelationInput
    productionSubmissions?: production_submissionsOrderByRelationAggregateInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardOrderByWithRelationInput
    dealCodes?: deal_codesOrderByRelationAggregateInput
    brandUnlockHistory?: unlocked_brands_historyOrderByRelationAggregateInput
    categoryChoices?: category_choicesOrderByRelationAggregateInput
    likedPosts?: postsOrderByRelationAggregateInput
    pushNotificationHistory?: push_notification_historyOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownedBrandId?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    email?: StringFilter<"users"> | string
    myFavourites?: JsonNullableListFilter<"users">
    hasAcceptedTermsAndConditions?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    name?: StringNullableFilter<"users"> | string | null
    notificationsToken?: StringNullableFilter<"users"> | string | null
    forYouBrandsIds?: StringNullableListFilter<"users">
    forYouBrandsPoolIds?: StringNullableListFilter<"users">
    notInterestedBrandsIds?: StringNullableListFilter<"users">
    levelId?: StringNullableFilter<"users"> | string | null
    brandsExplored?: IntFilter<"users"> | number
    foundersReachedLeaderboardId?: StringNullableFilter<"users"> | string | null
    viewedPitches?: StringNullableListFilter<"users">
    targetGender?: EnumGenderPreferenceNullableFilter<"users"> | $Enums.GenderPreference | null
    budgetInterval?: IntNullableFilter<"users"> | number | null
    deletedBrands?: StringNullableListFilter<"users">
    superUser?: BoolNullableFilter<"users"> | boolean | null
    hasNewForYouBrands?: BoolFilter<"users"> | boolean
    likedPostsIds?: StringNullableListFilter<"users">
    lastOpened?: DateTimeNullableFilter<"users"> | Date | string | null
    answers?: AnswersListRelationFilter
    pitchViews?: Pitch_viewsListRelationFilter
    settings?: XOR<SettingsNullableRelationFilter, settingsWhereInput> | null
    ratings?: RatingsListRelationFilter
    forYouBrands?: BrandsListRelationFilter
    forYouBrandsPool?: BrandsListRelationFilter
    notInterestedBrands?: BrandsListRelationFilter
    linkVisits?: Link_visitsListRelationFilter
    brandScreenTimes?: Brand_screen_timesListRelationFilter
    termsAndConditions?: XOR<Terms_and_conditionsNullableRelationFilter, terms_and_conditionsWhereInput> | null
    feedbacks?: FeedbackListRelationFilter
    level?: XOR<LevelsNullableRelationFilter, levelsWhereInput> | null
    ownedBrand?: XOR<BrandsNullableRelationFilter, brandsWhereInput> | null
    productionSubmissions?: Production_submissionsListRelationFilter
    foundersReachedLeaderboard?: XOR<FoundersReachedLeaderboardNullableRelationFilter, foundersReachedLeaderboardWhereInput> | null
    dealCodes?: Deal_codesListRelationFilter
    brandUnlockHistory?: Unlocked_brands_historyListRelationFilter
    categoryChoices?: Category_choicesListRelationFilter
    likedPosts?: PostsListRelationFilter
    pushNotificationHistory?: Push_notification_historyListRelationFilter
  }, "id" | "ownedBrandId">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    myFavourites?: SortOrder
    hasAcceptedTermsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    forYouBrandsIds?: SortOrder
    forYouBrandsPoolIds?: SortOrder
    notInterestedBrandsIds?: SortOrder
    levelId?: SortOrder
    brandsExplored?: SortOrder
    ownedBrandId?: SortOrder
    foundersReachedLeaderboardId?: SortOrder
    viewedPitches?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    deletedBrands?: SortOrder
    superUser?: SortOrder
    hasNewForYouBrands?: SortOrder
    likedPostsIds?: SortOrder
    lastOpened?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    myFavourites?: JsonNullableListFilter<"users">
    hasAcceptedTermsAndConditions?: BoolWithAggregatesFilter<"users"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    notificationsToken?: StringNullableWithAggregatesFilter<"users"> | string | null
    forYouBrandsIds?: StringNullableListFilter<"users">
    forYouBrandsPoolIds?: StringNullableListFilter<"users">
    notInterestedBrandsIds?: StringNullableListFilter<"users">
    levelId?: StringNullableWithAggregatesFilter<"users"> | string | null
    brandsExplored?: IntWithAggregatesFilter<"users"> | number
    ownedBrandId?: StringNullableWithAggregatesFilter<"users"> | string | null
    foundersReachedLeaderboardId?: StringNullableWithAggregatesFilter<"users"> | string | null
    viewedPitches?: StringNullableListFilter<"users">
    targetGender?: EnumGenderPreferenceNullableWithAggregatesFilter<"users"> | $Enums.GenderPreference | null
    budgetInterval?: IntNullableWithAggregatesFilter<"users"> | number | null
    deletedBrands?: StringNullableListFilter<"users">
    superUser?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    hasNewForYouBrands?: BoolWithAggregatesFilter<"users"> | boolean
    likedPostsIds?: StringNullableListFilter<"users">
    lastOpened?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type deal_codesWhereInput = {
    AND?: deal_codesWhereInput | deal_codesWhereInput[]
    OR?: deal_codesWhereInput[]
    NOT?: deal_codesWhereInput | deal_codesWhereInput[]
    id?: StringFilter<"deal_codes"> | string
    code?: StringFilter<"deal_codes"> | string
    isUsed?: BoolFilter<"deal_codes"> | boolean
    userId?: StringNullableFilter<"deal_codes"> | string | null
    groupId?: StringFilter<"deal_codes"> | string
    userExpireDate?: DateTimeNullableFilter<"deal_codes"> | Date | string | null
    unlockedAt?: DateTimeNullableFilter<"deal_codes"> | Date | string | null
    createdAt?: DateTimeFilter<"deal_codes"> | Date | string
    updatedAt?: DateTimeFilter<"deal_codes"> | Date | string
    user?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    group?: XOR<Deal_code_groupsRelationFilter, deal_code_groupsWhereInput>
  }

  export type deal_codesOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    userExpireDate?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    group?: deal_code_groupsOrderByWithRelationInput
  }

  export type deal_codesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: deal_codesWhereInput | deal_codesWhereInput[]
    OR?: deal_codesWhereInput[]
    NOT?: deal_codesWhereInput | deal_codesWhereInput[]
    code?: StringFilter<"deal_codes"> | string
    isUsed?: BoolFilter<"deal_codes"> | boolean
    userId?: StringNullableFilter<"deal_codes"> | string | null
    groupId?: StringFilter<"deal_codes"> | string
    userExpireDate?: DateTimeNullableFilter<"deal_codes"> | Date | string | null
    unlockedAt?: DateTimeNullableFilter<"deal_codes"> | Date | string | null
    createdAt?: DateTimeFilter<"deal_codes"> | Date | string
    updatedAt?: DateTimeFilter<"deal_codes"> | Date | string
    user?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    group?: XOR<Deal_code_groupsRelationFilter, deal_code_groupsWhereInput>
  }, "id">

  export type deal_codesOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    userExpireDate?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: deal_codesCountOrderByAggregateInput
    _max?: deal_codesMaxOrderByAggregateInput
    _min?: deal_codesMinOrderByAggregateInput
  }

  export type deal_codesScalarWhereWithAggregatesInput = {
    AND?: deal_codesScalarWhereWithAggregatesInput | deal_codesScalarWhereWithAggregatesInput[]
    OR?: deal_codesScalarWhereWithAggregatesInput[]
    NOT?: deal_codesScalarWhereWithAggregatesInput | deal_codesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"deal_codes"> | string
    code?: StringWithAggregatesFilter<"deal_codes"> | string
    isUsed?: BoolWithAggregatesFilter<"deal_codes"> | boolean
    userId?: StringNullableWithAggregatesFilter<"deal_codes"> | string | null
    groupId?: StringWithAggregatesFilter<"deal_codes"> | string
    userExpireDate?: DateTimeNullableWithAggregatesFilter<"deal_codes"> | Date | string | null
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"deal_codes"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"deal_codes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"deal_codes"> | Date | string
  }

  export type deal_code_groupsWhereInput = {
    AND?: deal_code_groupsWhereInput | deal_code_groupsWhereInput[]
    OR?: deal_code_groupsWhereInput[]
    NOT?: deal_code_groupsWhereInput | deal_code_groupsWhereInput[]
    id?: StringFilter<"deal_code_groups"> | string
    description?: JsonFilter<"deal_code_groups">
    shortDescription?: JsonNullableFilter<"deal_code_groups">
    codesState?: StringNullableFilter<"deal_code_groups"> | string | null
    brandId?: StringFilter<"deal_code_groups"> | string
    generalExpireDate?: DateTimeNullableFilter<"deal_code_groups"> | Date | string | null
    createdAt?: DateTimeFilter<"deal_code_groups"> | Date | string
    updatedAt?: DateTimeFilter<"deal_code_groups"> | Date | string
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
    dealCodes?: Deal_codesListRelationFilter
  }

  export type deal_code_groupsOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    codesState?: SortOrder
    brandId?: SortOrder
    generalExpireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brand?: brandsOrderByWithRelationInput
    dealCodes?: deal_codesOrderByRelationAggregateInput
  }

  export type deal_code_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: deal_code_groupsWhereInput | deal_code_groupsWhereInput[]
    OR?: deal_code_groupsWhereInput[]
    NOT?: deal_code_groupsWhereInput | deal_code_groupsWhereInput[]
    description?: JsonFilter<"deal_code_groups">
    shortDescription?: JsonNullableFilter<"deal_code_groups">
    codesState?: StringNullableFilter<"deal_code_groups"> | string | null
    brandId?: StringFilter<"deal_code_groups"> | string
    generalExpireDate?: DateTimeNullableFilter<"deal_code_groups"> | Date | string | null
    createdAt?: DateTimeFilter<"deal_code_groups"> | Date | string
    updatedAt?: DateTimeFilter<"deal_code_groups"> | Date | string
    brand?: XOR<BrandsRelationFilter, brandsWhereInput>
    dealCodes?: Deal_codesListRelationFilter
  }, "id">

  export type deal_code_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    codesState?: SortOrder
    brandId?: SortOrder
    generalExpireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: deal_code_groupsCountOrderByAggregateInput
    _max?: deal_code_groupsMaxOrderByAggregateInput
    _min?: deal_code_groupsMinOrderByAggregateInput
  }

  export type deal_code_groupsScalarWhereWithAggregatesInput = {
    AND?: deal_code_groupsScalarWhereWithAggregatesInput | deal_code_groupsScalarWhereWithAggregatesInput[]
    OR?: deal_code_groupsScalarWhereWithAggregatesInput[]
    NOT?: deal_code_groupsScalarWhereWithAggregatesInput | deal_code_groupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"deal_code_groups"> | string
    description?: JsonWithAggregatesFilter<"deal_code_groups">
    shortDescription?: JsonNullableWithAggregatesFilter<"deal_code_groups">
    codesState?: StringNullableWithAggregatesFilter<"deal_code_groups"> | string | null
    brandId?: StringWithAggregatesFilter<"deal_code_groups"> | string
    generalExpireDate?: DateTimeNullableWithAggregatesFilter<"deal_code_groups"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"deal_code_groups"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"deal_code_groups"> | Date | string
  }

  export type order_historyCreateInput = {
    id?: string
    brandId: string
    brandName: string
    dealCodes?: order_historyCreatedealCodesInput | string[]
    orderJson: InputJsonValue
    createdAt?: Date | string
  }

  export type order_historyUncheckedCreateInput = {
    id?: string
    brandId: string
    brandName: string
    dealCodes?: order_historyCreatedealCodesInput | string[]
    orderJson: InputJsonValue
    createdAt?: Date | string
  }

  export type order_historyUpdateInput = {
    brandId?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    dealCodes?: order_historyUpdatedealCodesInput | string[]
    orderJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_historyUncheckedUpdateInput = {
    brandId?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    dealCodes?: order_historyUpdatedealCodesInput | string[]
    orderJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_historyCreateManyInput = {
    id?: string
    brandId: string
    brandName: string
    dealCodes?: order_historyCreatedealCodesInput | string[]
    orderJson: InputJsonValue
    createdAt?: Date | string
  }

  export type order_historyUpdateManyMutationInput = {
    brandId?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    dealCodes?: order_historyUpdatedealCodesInput | string[]
    orderJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_historyUncheckedUpdateManyInput = {
    brandId?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    dealCodes?: order_historyUpdatedealCodesInput | string[]
    orderJson?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersCreateInput = {
    id?: string
    questionText: InputJsonValue
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutAnswersInput
    question?: questionsCreateNestedOneWithoutAnswersInput
    productFeedbackBrand?: brandsCreateNestedOneWithoutProductFeedbackAnswersInput
    pitchExitBrand?: brandsCreateNestedOneWithoutPitchExitBrandAnswersInput
  }

  export type answersUncheckedCreateInput = {
    id?: string
    userId: string
    questionId?: string | null
    questionText: InputJsonValue
    answer: InputJsonValue
    productFeedbackBrandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pitchExitBrandId?: string | null
  }

  export type answersUpdateInput = {
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAnswersNestedInput
    question?: questionsUpdateOneWithoutAnswersNestedInput
    productFeedbackBrand?: brandsUpdateOneWithoutProductFeedbackAnswersNestedInput
    pitchExitBrand?: brandsUpdateOneWithoutPitchExitBrandAnswersNestedInput
  }

  export type answersUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    productFeedbackBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pitchExitBrandId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type answersCreateManyInput = {
    id?: string
    userId: string
    questionId?: string | null
    questionText: InputJsonValue
    answer: InputJsonValue
    productFeedbackBrandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pitchExitBrandId?: string | null
  }

  export type answersUpdateManyMutationInput = {
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    productFeedbackBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pitchExitBrandId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type app_versionsCreateInput = {
    id?: string
    version: string
    critical: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type app_versionsUncheckedCreateInput = {
    id?: string
    version: string
    critical: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type app_versionsUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    critical?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_versionsUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    critical?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_versionsCreateManyInput = {
    id?: string
    version: string
    critical: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type app_versionsUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    critical?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type app_versionsUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    critical?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type benefitsCreateInput = {
    id?: string
    title: string
    subtitle: InputJsonValue
    description: InputJsonValue
    logo?: InputJsonValue | null
    image?: InputJsonValue | null
    redeemLink: string
    tags?: benefitsCreatetagsInput | InputJsonValue[]
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: levelsCreateNestedOneWithoutBenefitsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBenefitInput
  }

  export type benefitsUncheckedCreateInput = {
    id?: string
    title: string
    subtitle: InputJsonValue
    description: InputJsonValue
    logo?: InputJsonValue | null
    image?: InputJsonValue | null
    redeemLink: string
    levelId?: string | null
    tags?: benefitsCreatetagsInput | InputJsonValue[]
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBenefitInput
  }

  export type benefitsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: levelsUpdateOneWithoutBenefitsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBenefitNestedInput
  }

  export type benefitsUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBenefitNestedInput
  }

  export type benefitsCreateManyInput = {
    id?: string
    title: string
    subtitle: InputJsonValue
    description: InputJsonValue
    logo?: InputJsonValue | null
    image?: InputJsonValue | null
    redeemLink: string
    levelId?: string | null
    tags?: benefitsCreatetagsInput | InputJsonValue[]
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type benefitsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type benefitsUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsCreateInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUpdateInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsCreateManyInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
  }

  export type brandsUpdateManyMutationInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type brandsUncheckedUpdateManyInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type unlocked_brands_historyCreateInput = {
    id?: string
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutBrandUnlockHistoryInput
    brand?: brandsCreateNestedOneWithoutUnlockHistoryInput
  }

  export type unlocked_brands_historyUncheckedCreateInput = {
    id?: string
    userId: string
    brandId?: string | null
    createdAt?: Date | string
  }

  export type unlocked_brands_historyUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutBrandUnlockHistoryNestedInput
    brand?: brandsUpdateOneWithoutUnlockHistoryNestedInput
  }

  export type unlocked_brands_historyUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unlocked_brands_historyCreateManyInput = {
    id?: string
    userId: string
    brandId?: string | null
    createdAt?: Date | string
  }

  export type unlocked_brands_historyUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unlocked_brands_historyUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brand_screen_timesCreateInput = {
    id?: string
    time: number
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutBrandScreenTimesInput
    brand?: brandsCreateNestedOneWithoutBrandScreenTimesInput
  }

  export type brand_screen_timesUncheckedCreateInput = {
    id?: string
    time: number
    userId: string
    brandId?: string | null
    createdAt?: Date | string
  }

  export type brand_screen_timesUpdateInput = {
    time?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutBrandScreenTimesNestedInput
    brand?: brandsUpdateOneWithoutBrandScreenTimesNestedInput
  }

  export type brand_screen_timesUncheckedUpdateInput = {
    time?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brand_screen_timesCreateManyInput = {
    id?: string
    time: number
    userId: string
    brandId?: string | null
    createdAt?: Date | string
  }

  export type brand_screen_timesUpdateManyMutationInput = {
    time?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brand_screen_timesUncheckedUpdateManyInput = {
    time?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriesCreateInput = {
    id?: string
    name: InputJsonValue
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brands?: brandsCreateNestedManyWithoutCategoryInput
    userChoices?: category_choicesCreateNestedManyWithoutCategoryInput
  }

  export type categoriesUncheckedCreateInput = {
    id?: string
    name: InputJsonValue
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brands?: brandsUncheckedCreateNestedManyWithoutCategoryInput
    userChoices?: category_choicesUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoriesUpdateInput = {
    name?: InputJsonValue | InputJsonValue
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brands?: brandsUpdateManyWithoutCategoryNestedInput
    userChoices?: category_choicesUpdateManyWithoutCategoryNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    name?: InputJsonValue | InputJsonValue
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brands?: brandsUncheckedUpdateManyWithoutCategoryNestedInput
    userChoices?: category_choicesUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoriesCreateManyInput = {
    id?: string
    name: InputJsonValue
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type categoriesUpdateManyMutationInput = {
    name?: InputJsonValue | InputJsonValue
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriesUncheckedUpdateManyInput = {
    name?: InputJsonValue | InputJsonValue
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_choicesCreateInput = {
    id?: string
    like: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: categoriesCreateNestedOneWithoutUserChoicesInput
    user: usersCreateNestedOneWithoutCategoryChoicesInput
  }

  export type category_choicesUncheckedCreateInput = {
    id?: string
    like: boolean
    categoryId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type category_choicesUpdateInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: categoriesUpdateOneRequiredWithoutUserChoicesNestedInput
    user?: usersUpdateOneRequiredWithoutCategoryChoicesNestedInput
  }

  export type category_choicesUncheckedUpdateInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_choicesCreateManyInput = {
    id?: string
    like: boolean
    categoryId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type category_choicesUpdateManyMutationInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_choicesUncheckedUpdateManyInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type foundersReachedLeaderboardCreateInput = {
    id?: string
    amount: number
    users?: usersCreateNestedManyWithoutFoundersReachedLeaderboardInput
  }

  export type foundersReachedLeaderboardUncheckedCreateInput = {
    id?: string
    amount: number
    users?: usersUncheckedCreateNestedManyWithoutFoundersReachedLeaderboardInput
  }

  export type foundersReachedLeaderboardUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    users?: usersUpdateManyWithoutFoundersReachedLeaderboardNestedInput
  }

  export type foundersReachedLeaderboardUncheckedUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    users?: usersUncheckedUpdateManyWithoutFoundersReachedLeaderboardNestedInput
  }

  export type foundersReachedLeaderboardCreateManyInput = {
    id?: string
    amount: number
  }

  export type foundersReachedLeaderboardUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type foundersReachedLeaderboardUncheckedUpdateManyInput = {
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type link_visitsCreateInput = {
    id?: string
    url: string
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutLinkVisitsInput
    brand?: brandsCreateNestedOneWithoutLinkVisitsInput
    product?: productsCreateNestedOneWithoutLinkVisitsInput
    benefit?: benefitsCreateNestedOneWithoutLinkVisitsInput
  }

  export type link_visitsUncheckedCreateInput = {
    id?: string
    url: string
    userId: string
    brandId?: string | null
    productId?: string | null
    benefitId?: string | null
    createdAt?: Date | string
  }

  export type link_visitsUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutLinkVisitsNestedInput
    brand?: brandsUpdateOneWithoutLinkVisitsNestedInput
    product?: productsUpdateOneWithoutLinkVisitsNestedInput
    benefit?: benefitsUpdateOneWithoutLinkVisitsNestedInput
  }

  export type link_visitsUncheckedUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    benefitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsCreateManyInput = {
    id?: string
    url: string
    userId: string
    brandId?: string | null
    productId?: string | null
    benefitId?: string | null
    createdAt?: Date | string
  }

  export type link_visitsUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsUncheckedUpdateManyInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    benefitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pitch_viewsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutPitchViewsInput
    brand?: brandsCreateNestedOneWithoutPitchViewsInput
  }

  export type pitch_viewsUncheckedCreateInput = {
    id?: string
    userId: string
    brandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pitch_viewsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutPitchViewsNestedInput
    brand?: brandsUpdateOneWithoutPitchViewsNestedInput
  }

  export type pitch_viewsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pitch_viewsCreateManyInput = {
    id?: string
    userId: string
    brandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pitch_viewsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pitch_viewsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type postsCreateInput = {
    id?: string
    title: string
    author?: string | null
    content?: string | null
    video?: string | null
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brand?: brandsCreateNestedOneWithoutPostsInput
    userLikes?: usersCreateNestedManyWithoutLikedPostsInput
  }

  export type postsUncheckedCreateInput = {
    id?: string
    title: string
    author?: string | null
    content?: string | null
    video?: string | null
    image?: InputJsonValue | null
    brandId?: string | null
    userLikesIds?: postsCreateuserLikesIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userLikes?: usersUncheckedCreateNestedManyWithoutLikedPostsInput
  }

  export type postsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneWithoutPostsNestedInput
    userLikes?: usersUpdateManyWithoutLikedPostsNestedInput
  }

  export type postsUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    userLikesIds?: postsUpdateuserLikesIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userLikes?: usersUncheckedUpdateManyWithoutLikedPostsNestedInput
  }

  export type postsCreateManyInput = {
    id?: string
    title: string
    author?: string | null
    content?: string | null
    video?: string | null
    image?: InputJsonValue | null
    brandId?: string | null
    userLikesIds?: postsCreateuserLikesIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type postsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type postsUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    userLikesIds?: postsUpdateuserLikesIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsCreateInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutProductionSubmissionsInput
    user: usersCreateNestedOneWithoutProductionSubmissionsInput
  }

  export type production_submissionsUncheckedCreateInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brandId: string
    userId: string
  }

  export type production_submissionsUpdateInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutProductionSubmissionsNestedInput
    user?: usersUpdateOneRequiredWithoutProductionSubmissionsNestedInput
  }

  export type production_submissionsUncheckedUpdateInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type production_submissionsCreateManyInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brandId: string
    userId: string
  }

  export type production_submissionsUpdateManyMutationInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsUncheckedUpdateManyInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type productsCreateInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    brand: brandsCreateNestedOneWithoutProductsInput
    linkVisits?: link_visitsCreateNestedManyWithoutProductInput
    ratings?: ratingsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutProductInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsUpdateInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: brandsUpdateOneRequiredWithoutProductsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutProductNestedInput
    ratings?: ratingsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productsCreateManyInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
  }

  export type productsUpdateManyMutationInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type productsUncheckedUpdateManyInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type push_notificationsCreateInput = {
    id?: string
    title?: string | null
    content: string
    type?: $Enums.NotificationType | null
    minDaysInactive?: number | null
    oneTimeOnly?: boolean | null
    sendAfterInactiveDays?: number | null
    repeatAfterDays?: number | null
    daysAfterActivation?: number | null
    daysBeforeExpiry?: number | null
  }

  export type push_notificationsUncheckedCreateInput = {
    id?: string
    title?: string | null
    content: string
    type?: $Enums.NotificationType | null
    minDaysInactive?: number | null
    oneTimeOnly?: boolean | null
    sendAfterInactiveDays?: number | null
    repeatAfterDays?: number | null
    daysAfterActivation?: number | null
    daysBeforeExpiry?: number | null
  }

  export type push_notificationsUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    minDaysInactive?: NullableIntFieldUpdateOperationsInput | number | null
    oneTimeOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAfterInactiveDays?: NullableIntFieldUpdateOperationsInput | number | null
    repeatAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    daysAfterActivation?: NullableIntFieldUpdateOperationsInput | number | null
    daysBeforeExpiry?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type push_notificationsUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    minDaysInactive?: NullableIntFieldUpdateOperationsInput | number | null
    oneTimeOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAfterInactiveDays?: NullableIntFieldUpdateOperationsInput | number | null
    repeatAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    daysAfterActivation?: NullableIntFieldUpdateOperationsInput | number | null
    daysBeforeExpiry?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type push_notificationsCreateManyInput = {
    id?: string
    title?: string | null
    content: string
    type?: $Enums.NotificationType | null
    minDaysInactive?: number | null
    oneTimeOnly?: boolean | null
    sendAfterInactiveDays?: number | null
    repeatAfterDays?: number | null
    daysAfterActivation?: number | null
    daysBeforeExpiry?: number | null
  }

  export type push_notificationsUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    minDaysInactive?: NullableIntFieldUpdateOperationsInput | number | null
    oneTimeOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAfterInactiveDays?: NullableIntFieldUpdateOperationsInput | number | null
    repeatAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    daysAfterActivation?: NullableIntFieldUpdateOperationsInput | number | null
    daysBeforeExpiry?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type push_notificationsUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    minDaysInactive?: NullableIntFieldUpdateOperationsInput | number | null
    oneTimeOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAfterInactiveDays?: NullableIntFieldUpdateOperationsInput | number | null
    repeatAfterDays?: NullableIntFieldUpdateOperationsInput | number | null
    daysAfterActivation?: NullableIntFieldUpdateOperationsInput | number | null
    daysBeforeExpiry?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type push_notification_historyCreateInput = {
    id?: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
    user: usersCreateNestedOneWithoutPushNotificationHistoryInput
  }

  export type push_notification_historyUncheckedCreateInput = {
    id?: string
    userId: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type push_notification_historyUpdateInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutPushNotificationHistoryNestedInput
  }

  export type push_notification_historyUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyCreateManyInput = {
    id?: string
    userId: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type push_notification_historyUpdateManyMutationInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionnairesCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsCreateNestedManyWithoutQuestionnaireInput
    level?: levelsCreateNestedOneWithoutQuestionnaireInput
  }

  export type questionnairesUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsUncheckedCreateNestedManyWithoutQuestionnaireInput
    level?: levelsUncheckedCreateNestedOneWithoutQuestionnaireInput
  }

  export type questionnairesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUpdateManyWithoutQuestionnaireNestedInput
    level?: levelsUpdateOneWithoutQuestionnaireNestedInput
  }

  export type questionnairesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutQuestionnaireNestedInput
    level?: levelsUncheckedUpdateOneWithoutQuestionnaireNestedInput
  }

  export type questionnairesCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionnairesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionnairesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_classesCreateInput = {
    id?: string
    name: string
    editable: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsCreateNestedManyWithoutQuestionClassInput
  }

  export type question_classesUncheckedCreateInput = {
    id?: string
    name: string
    editable: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsUncheckedCreateNestedManyWithoutQuestionClassInput
  }

  export type question_classesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    editable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUpdateManyWithoutQuestionClassNestedInput
  }

  export type question_classesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    editable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutQuestionClassNestedInput
  }

  export type question_classesCreateManyInput = {
    id?: string
    name: string
    editable: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type question_classesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    editable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_classesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    editable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionsCreateInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    questionClass?: question_classesCreateNestedOneWithoutQuestionsInput
    answers?: answersCreateNestedManyWithoutQuestionInput
    brand?: brandsCreateNestedOneWithoutPitchQuestionsInput
    questionnaire?: questionnairesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    questionClass?: question_classesUpdateOneWithoutQuestionsNestedInput
    answers?: answersUpdateManyWithoutQuestionNestedInput
    brand?: brandsUpdateOneWithoutPitchQuestionsNestedInput
    questionnaire?: questionnairesUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsCreateManyInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type questionsUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questionsUncheckedUpdateManyInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ratingsCreateInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutRatingsInput
    product?: productsCreateNestedOneWithoutRatingsInput
    brand: brandsCreateNestedOneWithoutRatingsInput
  }

  export type ratingsUncheckedCreateInput = {
    id?: string
    userId: string
    productId?: string | null
    brandId: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsUpdateInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutRatingsNestedInput
    product?: productsUpdateOneWithoutRatingsNestedInput
    brand?: brandsUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ratingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsCreateManyInput = {
    id?: string
    userId: string
    productId?: string | null
    brandId: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsUpdateManyMutationInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsCreateInput = {
    id?: string
    receiveNotifications: boolean
    newBrands: boolean
    personalizedOffers: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateInput = {
    id?: string
    userId: string
    receiveNotifications: boolean
    newBrands: boolean
    personalizedOffers: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type settingsUpdateInput = {
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    newBrands?: BoolFieldUpdateOperationsInput | boolean
    personalizedOffers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    newBrands?: BoolFieldUpdateOperationsInput | boolean
    personalizedOffers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsCreateManyInput = {
    id?: string
    userId: string
    receiveNotifications: boolean
    newBrands: boolean
    personalizedOffers: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type settingsUpdateManyMutationInput = {
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    newBrands?: BoolFieldUpdateOperationsInput | boolean
    personalizedOffers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    newBrands?: BoolFieldUpdateOperationsInput | boolean
    personalizedOffers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type terms_and_conditionsCreateInput = {
    id?: string
    userEmailAddress: string
    acceptanceDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutTermsAndConditionsInput
  }

  export type terms_and_conditionsUncheckedCreateInput = {
    id?: string
    userId: string
    userEmailAddress: string
    acceptanceDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type terms_and_conditionsUpdateInput = {
    userEmailAddress?: StringFieldUpdateOperationsInput | string
    acceptanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutTermsAndConditionsNestedInput
  }

  export type terms_and_conditionsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userEmailAddress?: StringFieldUpdateOperationsInput | string
    acceptanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type terms_and_conditionsCreateManyInput = {
    id?: string
    userId: string
    userEmailAddress: string
    acceptanceDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type terms_and_conditionsUpdateManyMutationInput = {
    userEmailAddress?: StringFieldUpdateOperationsInput | string
    acceptanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type terms_and_conditionsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userEmailAddress?: StringFieldUpdateOperationsInput | string
    acceptanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackCreateInput = {
    id?: string
    text: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutFeedbacksInput
  }

  export type feedbackUncheckedCreateInput = {
    id?: string
    userId: string
    text: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbackUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type feedbackUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackCreateManyInput = {
    id?: string
    userId: string
    text: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbackUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type levelsCreateInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questionnaire?: questionnairesCreateNestedOneWithoutLevelInput
    benefits?: benefitsCreateNestedManyWithoutLevelInput
    users?: usersCreateNestedManyWithoutLevelInput
  }

  export type levelsUncheckedCreateInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    questionnaireId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    benefits?: benefitsUncheckedCreateNestedManyWithoutLevelInput
    users?: usersUncheckedCreateNestedManyWithoutLevelInput
  }

  export type levelsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionnaire?: questionnairesUpdateOneWithoutLevelNestedInput
    benefits?: benefitsUpdateManyWithoutLevelNestedInput
    users?: usersUpdateManyWithoutLevelNestedInput
  }

  export type levelsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: benefitsUncheckedUpdateManyWithoutLevelNestedInput
    users?: usersUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type levelsCreateManyInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    questionnaireId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type levelsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type levelsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type deal_codesCreateInput = {
    id?: string
    code: string
    isUsed?: boolean
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: usersCreateNestedOneWithoutDealCodesInput
    group: deal_code_groupsCreateNestedOneWithoutDealCodesInput
  }

  export type deal_codesUncheckedCreateInput = {
    id?: string
    code: string
    isUsed?: boolean
    userId?: string | null
    groupId: string
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deal_codesUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneWithoutDealCodesNestedInput
    group?: deal_code_groupsUpdateOneRequiredWithoutDealCodesNestedInput
  }

  export type deal_codesUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deal_codesCreateManyInput = {
    id?: string
    code: string
    isUsed?: boolean
    userId?: string | null
    groupId: string
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deal_codesUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deal_codesUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: StringFieldUpdateOperationsInput | string
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deal_code_groupsCreateInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    codesState?: string | null
    generalExpireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutDealCodeGroupsInput
    dealCodes?: deal_codesCreateNestedManyWithoutGroupInput
  }

  export type deal_code_groupsUncheckedCreateInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    codesState?: string | null
    brandId: string
    generalExpireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutGroupInput
  }

  export type deal_code_groupsUpdateInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutDealCodeGroupsNestedInput
    dealCodes?: deal_codesUpdateManyWithoutGroupNestedInput
  }

  export type deal_code_groupsUncheckedUpdateInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealCodes?: deal_codesUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type deal_code_groupsCreateManyInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    codesState?: string | null
    brandId: string
    generalExpireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deal_code_groupsUpdateManyMutationInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deal_code_groupsUncheckedUpdateManyInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type order_historyCountOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    brandName?: SortOrder
    dealCodes?: SortOrder
    orderJson?: SortOrder
    createdAt?: SortOrder
  }

  export type order_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    brandName?: SortOrder
    createdAt?: SortOrder
  }

  export type order_historyMinOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    brandName?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type QuestionsNullableRelationFilter = {
    is?: questionsWhereInput | null
    isNot?: questionsWhereInput | null
  }

  export type BrandsNullableRelationFilter = {
    is?: brandsWhereInput | null
    isNot?: brandsWhereInput | null
  }

  export type answersUserIdQuestionIdCompoundUniqueInput = {
    userId: string
    questionId: string
  }

  export type answersCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    questionText?: SortOrder
    answer?: SortOrder
    productFeedbackBrandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pitchExitBrandId?: SortOrder
  }

  export type answersMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    productFeedbackBrandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pitchExitBrandId?: SortOrder
  }

  export type answersMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    productFeedbackBrandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pitchExitBrandId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type app_versionsCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type app_versionsMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type app_versionsMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    critical?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type LevelsNullableRelationFilter = {
    is?: levelsWhereInput | null
    isNot?: levelsWhereInput | null
  }

  export type Link_visitsListRelationFilter = {
    every?: link_visitsWhereInput
    some?: link_visitsWhereInput
    none?: link_visitsWhereInput
  }

  export type link_visitsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type benefitsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    image?: SortOrder
    redeemLink?: SortOrder
    levelId?: SortOrder
    tags?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type benefitsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    redeemLink?: SortOrder
    levelId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type benefitsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    redeemLink?: SortOrder
    levelId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumGenderPreferenceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderPreference | EnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderPreference[] | ListEnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderPreference[] | ListEnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderPreferenceNullableFilter<$PrismaModel> | $Enums.GenderPreference | null
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type QuestionsListRelationFilter = {
    every?: questionsWhereInput
    some?: questionsWhereInput
    none?: questionsWhereInput
  }

  export type Pitch_viewsListRelationFilter = {
    every?: pitch_viewsWhereInput
    some?: pitch_viewsWhereInput
    none?: pitch_viewsWhereInput
  }

  export type ProductsListRelationFilter = {
    every?: productsWhereInput
    some?: productsWhereInput
    none?: productsWhereInput
  }

  export type CategoriesNullableRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type RatingsListRelationFilter = {
    every?: ratingsWhereInput
    some?: ratingsWhereInput
    none?: ratingsWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type Brand_screen_timesListRelationFilter = {
    every?: brand_screen_timesWhereInput
    some?: brand_screen_timesWhereInput
    none?: brand_screen_timesWhereInput
  }

  export type Production_submissionsListRelationFilter = {
    every?: production_submissionsWhereInput
    some?: production_submissionsWhereInput
    none?: production_submissionsWhereInput
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type PostsListRelationFilter = {
    every?: postsWhereInput
    some?: postsWhereInput
    none?: postsWhereInput
  }

  export type Deal_code_groupsListRelationFilter = {
    every?: deal_code_groupsWhereInput
    some?: deal_code_groupsWhereInput
    none?: deal_code_groupsWhereInput
  }

  export type Unlocked_brands_historyListRelationFilter = {
    every?: unlocked_brands_historyWhereInput
    some?: unlocked_brands_historyWhereInput
    none?: unlocked_brands_historyWhereInput
  }

  export type AnswersListRelationFilter = {
    every?: answersWhereInput
    some?: answersWhereInput
    none?: answersWhereInput
  }

  export type questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pitch_viewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ratingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type brand_screen_timesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type production_submissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type postsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deal_code_groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type unlocked_brands_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type brandsCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    name?: SortOrder
    pitchVideo?: SortOrder
    pitchCaptions?: SortOrder
    pitchSections?: SortOrder
    updatedAt?: SortOrder
    brandLogo?: SortOrder
    email?: SortOrder
    managerEmail?: SortOrder
    managerName?: SortOrder
    managerPhone?: SortOrder
    labels?: SortOrder
    teamPicture?: SortOrder
    website?: SortOrder
    categoryId?: SortOrder
    teaser?: SortOrder
    mainPhrase?: SortOrder
    founders?: SortOrder
    image?: SortOrder
    usersForYouIds?: SortOrder
    usersForYouPoolIds?: SortOrder
    usersNotInterestedBrandsIds?: SortOrder
    images?: SortOrder
    usersFeedback?: SortOrder
    selectedFeedback?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    shopifyDomain?: SortOrder
    shopifyKeyName?: SortOrder
    ledgeRating?: SortOrder
    showTeamPictureInRating?: SortOrder
  }

  export type brandsAvgOrderByAggregateInput = {
    budgetInterval?: SortOrder
    ledgeRating?: SortOrder
  }

  export type brandsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pitchVideo?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    managerEmail?: SortOrder
    managerName?: SortOrder
    managerPhone?: SortOrder
    website?: SortOrder
    categoryId?: SortOrder
    teaser?: SortOrder
    mainPhrase?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    shopifyDomain?: SortOrder
    shopifyKeyName?: SortOrder
    ledgeRating?: SortOrder
    showTeamPictureInRating?: SortOrder
  }

  export type brandsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pitchVideo?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    managerEmail?: SortOrder
    managerName?: SortOrder
    managerPhone?: SortOrder
    website?: SortOrder
    categoryId?: SortOrder
    teaser?: SortOrder
    mainPhrase?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    shopifyDomain?: SortOrder
    shopifyKeyName?: SortOrder
    ledgeRating?: SortOrder
    showTeamPictureInRating?: SortOrder
  }

  export type brandsSumOrderByAggregateInput = {
    budgetInterval?: SortOrder
    ledgeRating?: SortOrder
  }

  export type EnumGenderPreferenceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderPreference | EnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderPreference[] | ListEnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderPreference[] | ListEnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderPreferenceNullableWithAggregatesFilter<$PrismaModel> | $Enums.GenderPreference | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderPreferenceNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderPreferenceNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type unlocked_brands_historyUserIdBrandIdCompoundUniqueInput = {
    userId: string
    brandId: string
  }

  export type unlocked_brands_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type unlocked_brands_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type unlocked_brands_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type brand_screen_timesUserIdBrandIdCompoundUniqueInput = {
    userId: string
    brandId: string
  }

  export type brand_screen_timesCountOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type brand_screen_timesAvgOrderByAggregateInput = {
    time?: SortOrder
  }

  export type brand_screen_timesMaxOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type brand_screen_timesMinOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type brand_screen_timesSumOrderByAggregateInput = {
    time?: SortOrder
  }

  export type BrandsListRelationFilter = {
    every?: brandsWhereInput
    some?: brandsWhereInput
    none?: brandsWhereInput
  }

  export type Category_choicesListRelationFilter = {
    every?: category_choicesWhereInput
    some?: category_choicesWhereInput
    none?: category_choicesWhereInput
  }

  export type brandsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type category_choicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoriesRelationFilter = {
    is?: categoriesWhereInput
    isNot?: categoriesWhereInput
  }

  export type category_choicesCountOrderByAggregateInput = {
    id?: SortOrder
    like?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type category_choicesMaxOrderByAggregateInput = {
    id?: SortOrder
    like?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type category_choicesMinOrderByAggregateInput = {
    id?: SortOrder
    like?: SortOrder
    categoryId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type foundersReachedLeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type foundersReachedLeaderboardAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type foundersReachedLeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type foundersReachedLeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type foundersReachedLeaderboardSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProductsNullableRelationFilter = {
    is?: productsWhereInput | null
    isNot?: productsWhereInput | null
  }

  export type BenefitsNullableRelationFilter = {
    is?: benefitsWhereInput | null
    isNot?: benefitsWhereInput | null
  }

  export type link_visitsCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    createdAt?: SortOrder
  }

  export type link_visitsMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    createdAt?: SortOrder
  }

  export type link_visitsMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    productId?: SortOrder
    benefitId?: SortOrder
    createdAt?: SortOrder
  }

  export type pitch_viewsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pitch_viewsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pitch_viewsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type postsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    content?: SortOrder
    video?: SortOrder
    image?: SortOrder
    brandId?: SortOrder
    userLikesIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type postsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    content?: SortOrder
    video?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type postsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    content?: SortOrder
    video?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandsRelationFilter = {
    is?: brandsWhereInput
    isNot?: brandsWhereInput
  }

  export type production_submissionsCountOrderByAggregateInput = {
    id?: SortOrder
    overlays?: SortOrder
    videos?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brandId?: SortOrder
    userId?: SortOrder
  }

  export type production_submissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brandId?: SortOrder
    userId?: SortOrder
  }

  export type production_submissionsMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brandId?: SortOrder
    userId?: SortOrder
  }

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    images?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder
    regularPrice?: SortOrder
    deal?: SortOrder
    dealPrice?: SortOrder
    purchaseUrl?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueDeal?: SortOrder
  }

  export type EnumNotificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableFilter<$PrismaModel> | $Enums.NotificationType | null
    isSet?: boolean
  }

  export type push_notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsAvgOrderByAggregateInput = {
    minDaysInactive?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    minDaysInactive?: SortOrder
    oneTimeOnly?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type push_notificationsSumOrderByAggregateInput = {
    minDaysInactive?: SortOrder
    sendAfterInactiveDays?: SortOrder
    repeatAfterDays?: SortOrder
    daysAfterActivation?: SortOrder
    daysBeforeExpiry?: SortOrder
  }

  export type EnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type push_notification_historyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
  }

  export type push_notification_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
  }

  export type push_notification_historyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    sentAt?: SortOrder
  }

  export type questionnairesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionnairesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionnairesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type question_classesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    editable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type question_classesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    editable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type question_classesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    editable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Question_classesNullableRelationFilter = {
    is?: question_classesWhereInput | null
    isNot?: question_classesWhereInput | null
  }

  export type QuestionnairesNullableRelationFilter = {
    is?: questionnairesWhereInput | null
    isNot?: questionnairesWhereInput | null
  }

  export type questionsCountOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    displayImage?: SortOrder
    footnote?: SortOrder
    subtitle?: SortOrder
    products?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scaleTopLabel?: SortOrder
    scaleBottomLabel?: SortOrder
    maxOptions?: SortOrder
  }

  export type questionsAvgOrderByAggregateInput = {
    position?: SortOrder
    questionnaireSubCategory?: SortOrder
    maxOptions?: SortOrder
  }

  export type questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    type?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxOptions?: SortOrder
  }

  export type questionsMinOrderByAggregateInput = {
    id?: SortOrder
    position?: SortOrder
    type?: SortOrder
    classId?: SortOrder
    categoryId?: SortOrder
    onboarding?: SortOrder
    randomizeOptions?: SortOrder
    fixedOptionSize?: SortOrder
    hideOptionText?: SortOrder
    brandId?: SortOrder
    correctAnswerId?: SortOrder
    questionnaireId?: SortOrder
    questionnaireSubCategory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    maxOptions?: SortOrder
  }

  export type questionsSumOrderByAggregateInput = {
    position?: SortOrder
    questionnaireSubCategory?: SortOrder
    maxOptions?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ratingsUserIdBrandIdCompoundUniqueInput = {
    userId: string
    brandId: string
  }

  export type ratingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    brandId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ratingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    brandId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    brandId?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ratingsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type settingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    receiveNotifications?: SortOrder
    newBrands?: SortOrder
    personalizedOffers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    receiveNotifications?: SortOrder
    newBrands?: SortOrder
    personalizedOffers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type settingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    receiveNotifications?: SortOrder
    newBrands?: SortOrder
    personalizedOffers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type terms_and_conditionsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmailAddress?: SortOrder
    acceptanceDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type terms_and_conditionsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmailAddress?: SortOrder
    acceptanceDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type terms_and_conditionsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmailAddress?: SortOrder
    acceptanceDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BenefitsListRelationFilter = {
    every?: benefitsWhereInput
    some?: benefitsWhereInput
    none?: benefitsWhereInput
  }

  export type benefitsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type levelsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    requiredBrandsExplored?: SortOrder
    requiredAnswers?: SortOrder
    questionnaireId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type levelsAvgOrderByAggregateInput = {
    order?: SortOrder
    requiredBrandsExplored?: SortOrder
    requiredAnswers?: SortOrder
  }

  export type levelsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    requiredBrandsExplored?: SortOrder
    requiredAnswers?: SortOrder
    questionnaireId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type levelsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    order?: SortOrder
    requiredBrandsExplored?: SortOrder
    requiredAnswers?: SortOrder
    questionnaireId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type levelsSumOrderByAggregateInput = {
    order?: SortOrder
    requiredBrandsExplored?: SortOrder
    requiredAnswers?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type SettingsNullableRelationFilter = {
    is?: settingsWhereInput | null
    isNot?: settingsWhereInput | null
  }

  export type Terms_and_conditionsNullableRelationFilter = {
    is?: terms_and_conditionsWhereInput | null
    isNot?: terms_and_conditionsWhereInput | null
  }

  export type FeedbackListRelationFilter = {
    every?: feedbackWhereInput
    some?: feedbackWhereInput
    none?: feedbackWhereInput
  }

  export type FoundersReachedLeaderboardNullableRelationFilter = {
    is?: foundersReachedLeaderboardWhereInput | null
    isNot?: foundersReachedLeaderboardWhereInput | null
  }

  export type Deal_codesListRelationFilter = {
    every?: deal_codesWhereInput
    some?: deal_codesWhereInput
    none?: deal_codesWhereInput
  }

  export type Push_notification_historyListRelationFilter = {
    every?: push_notification_historyWhereInput
    some?: push_notification_historyWhereInput
    none?: push_notification_historyWhereInput
  }

  export type feedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deal_codesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type push_notification_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    myFavourites?: SortOrder
    hasAcceptedTermsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    forYouBrandsIds?: SortOrder
    forYouBrandsPoolIds?: SortOrder
    notInterestedBrandsIds?: SortOrder
    levelId?: SortOrder
    brandsExplored?: SortOrder
    ownedBrandId?: SortOrder
    foundersReachedLeaderboardId?: SortOrder
    viewedPitches?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    deletedBrands?: SortOrder
    superUser?: SortOrder
    hasNewForYouBrands?: SortOrder
    likedPostsIds?: SortOrder
    lastOpened?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    brandsExplored?: SortOrder
    budgetInterval?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    hasAcceptedTermsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    levelId?: SortOrder
    brandsExplored?: SortOrder
    ownedBrandId?: SortOrder
    foundersReachedLeaderboardId?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    superUser?: SortOrder
    hasNewForYouBrands?: SortOrder
    lastOpened?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    hasAcceptedTermsAndConditions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    notificationsToken?: SortOrder
    levelId?: SortOrder
    brandsExplored?: SortOrder
    ownedBrandId?: SortOrder
    foundersReachedLeaderboardId?: SortOrder
    targetGender?: SortOrder
    budgetInterval?: SortOrder
    superUser?: SortOrder
    hasNewForYouBrands?: SortOrder
    lastOpened?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    brandsExplored?: SortOrder
    budgetInterval?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type Deal_code_groupsRelationFilter = {
    is?: deal_code_groupsWhereInput
    isNot?: deal_code_groupsWhereInput
  }

  export type deal_codesCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    userExpireDate?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type deal_codesMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    userExpireDate?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type deal_codesMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    isUsed?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    userExpireDate?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type deal_code_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    codesState?: SortOrder
    brandId?: SortOrder
    generalExpireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type deal_code_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    codesState?: SortOrder
    brandId?: SortOrder
    generalExpireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type deal_code_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    codesState?: SortOrder
    brandId?: SortOrder
    generalExpireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type order_historyCreatedealCodesInput = {
    set: string[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type order_historyUpdatedealCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usersCreateNestedOneWithoutAnswersInput = {
    create?: XOR<usersCreateWithoutAnswersInput, usersUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnswersInput
    connect?: usersWhereUniqueInput
  }

  export type questionsCreateNestedOneWithoutAnswersInput = {
    create?: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: questionsCreateOrConnectWithoutAnswersInput
    connect?: questionsWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutProductFeedbackAnswersInput = {
    create?: XOR<brandsCreateWithoutProductFeedbackAnswersInput, brandsUncheckedCreateWithoutProductFeedbackAnswersInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductFeedbackAnswersInput
    connect?: brandsWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutPitchExitBrandAnswersInput = {
    create?: XOR<brandsCreateWithoutPitchExitBrandAnswersInput, brandsUncheckedCreateWithoutPitchExitBrandAnswersInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPitchExitBrandAnswersInput
    connect?: brandsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<usersCreateWithoutAnswersInput, usersUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: usersCreateOrConnectWithoutAnswersInput
    upsert?: usersUpsertWithoutAnswersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAnswersInput, usersUpdateWithoutAnswersInput>, usersUncheckedUpdateWithoutAnswersInput>
  }

  export type questionsUpdateOneWithoutAnswersNestedInput = {
    create?: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: questionsCreateOrConnectWithoutAnswersInput
    upsert?: questionsUpsertWithoutAnswersInput
    disconnect?: boolean
    delete?: questionsWhereInput | boolean
    connect?: questionsWhereUniqueInput
    update?: XOR<XOR<questionsUpdateToOneWithWhereWithoutAnswersInput, questionsUpdateWithoutAnswersInput>, questionsUncheckedUpdateWithoutAnswersInput>
  }

  export type brandsUpdateOneWithoutProductFeedbackAnswersNestedInput = {
    create?: XOR<brandsCreateWithoutProductFeedbackAnswersInput, brandsUncheckedCreateWithoutProductFeedbackAnswersInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductFeedbackAnswersInput
    upsert?: brandsUpsertWithoutProductFeedbackAnswersInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutProductFeedbackAnswersInput, brandsUpdateWithoutProductFeedbackAnswersInput>, brandsUncheckedUpdateWithoutProductFeedbackAnswersInput>
  }

  export type brandsUpdateOneWithoutPitchExitBrandAnswersNestedInput = {
    create?: XOR<brandsCreateWithoutPitchExitBrandAnswersInput, brandsUncheckedCreateWithoutPitchExitBrandAnswersInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPitchExitBrandAnswersInput
    upsert?: brandsUpsertWithoutPitchExitBrandAnswersInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutPitchExitBrandAnswersInput, brandsUpdateWithoutPitchExitBrandAnswersInput>, brandsUncheckedUpdateWithoutPitchExitBrandAnswersInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type benefitsCreatetagsInput = {
    set: InputJsonValue[]
  }

  export type levelsCreateNestedOneWithoutBenefitsInput = {
    create?: XOR<levelsCreateWithoutBenefitsInput, levelsUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: levelsCreateOrConnectWithoutBenefitsInput
    connect?: levelsWhereUniqueInput
  }

  export type link_visitsCreateNestedManyWithoutBenefitInput = {
    create?: XOR<link_visitsCreateWithoutBenefitInput, link_visitsUncheckedCreateWithoutBenefitInput> | link_visitsCreateWithoutBenefitInput[] | link_visitsUncheckedCreateWithoutBenefitInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutBenefitInput | link_visitsCreateOrConnectWithoutBenefitInput[]
    createMany?: link_visitsCreateManyBenefitInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type link_visitsUncheckedCreateNestedManyWithoutBenefitInput = {
    create?: XOR<link_visitsCreateWithoutBenefitInput, link_visitsUncheckedCreateWithoutBenefitInput> | link_visitsCreateWithoutBenefitInput[] | link_visitsUncheckedCreateWithoutBenefitInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutBenefitInput | link_visitsCreateOrConnectWithoutBenefitInput[]
    createMany?: link_visitsCreateManyBenefitInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type benefitsUpdatetagsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type levelsUpdateOneWithoutBenefitsNestedInput = {
    create?: XOR<levelsCreateWithoutBenefitsInput, levelsUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: levelsCreateOrConnectWithoutBenefitsInput
    upsert?: levelsUpsertWithoutBenefitsInput
    disconnect?: boolean
    delete?: levelsWhereInput | boolean
    connect?: levelsWhereUniqueInput
    update?: XOR<XOR<levelsUpdateToOneWithWhereWithoutBenefitsInput, levelsUpdateWithoutBenefitsInput>, levelsUncheckedUpdateWithoutBenefitsInput>
  }

  export type link_visitsUpdateManyWithoutBenefitNestedInput = {
    create?: XOR<link_visitsCreateWithoutBenefitInput, link_visitsUncheckedCreateWithoutBenefitInput> | link_visitsCreateWithoutBenefitInput[] | link_visitsUncheckedCreateWithoutBenefitInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutBenefitInput | link_visitsCreateOrConnectWithoutBenefitInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutBenefitInput | link_visitsUpsertWithWhereUniqueWithoutBenefitInput[]
    createMany?: link_visitsCreateManyBenefitInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutBenefitInput | link_visitsUpdateWithWhereUniqueWithoutBenefitInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutBenefitInput | link_visitsUpdateManyWithWhereWithoutBenefitInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type link_visitsUncheckedUpdateManyWithoutBenefitNestedInput = {
    create?: XOR<link_visitsCreateWithoutBenefitInput, link_visitsUncheckedCreateWithoutBenefitInput> | link_visitsCreateWithoutBenefitInput[] | link_visitsUncheckedCreateWithoutBenefitInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutBenefitInput | link_visitsCreateOrConnectWithoutBenefitInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutBenefitInput | link_visitsUpsertWithWhereUniqueWithoutBenefitInput[]
    createMany?: link_visitsCreateManyBenefitInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutBenefitInput | link_visitsUpdateWithWhereUniqueWithoutBenefitInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutBenefitInput | link_visitsUpdateManyWithWhereWithoutBenefitInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type brandsCreatelabelsInput = {
    set: InputJsonValue[]
  }

  export type brandsCreatefoundersInput = {
    set: InputJsonValue[]
  }

  export type brandsCreateimagesInput = {
    set: InputJsonValue[]
  }

  export type questionsCreateNestedManyWithoutBrandInput = {
    create?: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput> | questionsCreateWithoutBrandInput[] | questionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutBrandInput | questionsCreateOrConnectWithoutBrandInput[]
    createMany?: questionsCreateManyBrandInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type pitch_viewsCreateNestedManyWithoutBrandInput = {
    create?: XOR<pitch_viewsCreateWithoutBrandInput, pitch_viewsUncheckedCreateWithoutBrandInput> | pitch_viewsCreateWithoutBrandInput[] | pitch_viewsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: pitch_viewsCreateOrConnectWithoutBrandInput | pitch_viewsCreateOrConnectWithoutBrandInput[]
    createMany?: pitch_viewsCreateManyBrandInputEnvelope
    connect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
  }

  export type productsCreateNestedManyWithoutBrandInput = {
    create?: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput> | productsCreateWithoutBrandInput[] | productsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandInput | productsCreateOrConnectWithoutBrandInput[]
    createMany?: productsCreateManyBrandInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type categoriesCreateNestedOneWithoutBrandsInput = {
    create?: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutBrandsInput
    connect?: categoriesWhereUniqueInput
  }

  export type ratingsCreateNestedManyWithoutBrandInput = {
    create?: XOR<ratingsCreateWithoutBrandInput, ratingsUncheckedCreateWithoutBrandInput> | ratingsCreateWithoutBrandInput[] | ratingsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutBrandInput | ratingsCreateOrConnectWithoutBrandInput[]
    createMany?: ratingsCreateManyBrandInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutForYouBrandsInput = {
    create?: XOR<usersCreateWithoutForYouBrandsInput, usersUncheckedCreateWithoutForYouBrandsInput> | usersCreateWithoutForYouBrandsInput[] | usersUncheckedCreateWithoutForYouBrandsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutForYouBrandsInput | usersCreateOrConnectWithoutForYouBrandsInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutForYouBrandsPoolInput = {
    create?: XOR<usersCreateWithoutForYouBrandsPoolInput, usersUncheckedCreateWithoutForYouBrandsPoolInput> | usersCreateWithoutForYouBrandsPoolInput[] | usersUncheckedCreateWithoutForYouBrandsPoolInput[]
    connectOrCreate?: usersCreateOrConnectWithoutForYouBrandsPoolInput | usersCreateOrConnectWithoutForYouBrandsPoolInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutNotInterestedBrandsInput = {
    create?: XOR<usersCreateWithoutNotInterestedBrandsInput, usersUncheckedCreateWithoutNotInterestedBrandsInput> | usersCreateWithoutNotInterestedBrandsInput[] | usersUncheckedCreateWithoutNotInterestedBrandsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutNotInterestedBrandsInput | usersCreateOrConnectWithoutNotInterestedBrandsInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type link_visitsCreateNestedManyWithoutBrandInput = {
    create?: XOR<link_visitsCreateWithoutBrandInput, link_visitsUncheckedCreateWithoutBrandInput> | link_visitsCreateWithoutBrandInput[] | link_visitsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutBrandInput | link_visitsCreateOrConnectWithoutBrandInput[]
    createMany?: link_visitsCreateManyBrandInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type brand_screen_timesCreateNestedManyWithoutBrandInput = {
    create?: XOR<brand_screen_timesCreateWithoutBrandInput, brand_screen_timesUncheckedCreateWithoutBrandInput> | brand_screen_timesCreateWithoutBrandInput[] | brand_screen_timesUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: brand_screen_timesCreateOrConnectWithoutBrandInput | brand_screen_timesCreateOrConnectWithoutBrandInput[]
    createMany?: brand_screen_timesCreateManyBrandInputEnvelope
    connect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
  }

  export type production_submissionsCreateNestedManyWithoutBrandInput = {
    create?: XOR<production_submissionsCreateWithoutBrandInput, production_submissionsUncheckedCreateWithoutBrandInput> | production_submissionsCreateWithoutBrandInput[] | production_submissionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutBrandInput | production_submissionsCreateOrConnectWithoutBrandInput[]
    createMany?: production_submissionsCreateManyBrandInputEnvelope
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutOwnedBrandInput = {
    create?: XOR<usersCreateWithoutOwnedBrandInput, usersUncheckedCreateWithoutOwnedBrandInput>
    connectOrCreate?: usersCreateOrConnectWithoutOwnedBrandInput
    connect?: usersWhereUniqueInput
  }

  export type postsCreateNestedManyWithoutBrandInput = {
    create?: XOR<postsCreateWithoutBrandInput, postsUncheckedCreateWithoutBrandInput> | postsCreateWithoutBrandInput[] | postsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: postsCreateOrConnectWithoutBrandInput | postsCreateOrConnectWithoutBrandInput[]
    createMany?: postsCreateManyBrandInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type deal_code_groupsCreateNestedManyWithoutBrandInput = {
    create?: XOR<deal_code_groupsCreateWithoutBrandInput, deal_code_groupsUncheckedCreateWithoutBrandInput> | deal_code_groupsCreateWithoutBrandInput[] | deal_code_groupsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: deal_code_groupsCreateOrConnectWithoutBrandInput | deal_code_groupsCreateOrConnectWithoutBrandInput[]
    createMany?: deal_code_groupsCreateManyBrandInputEnvelope
    connect?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
  }

  export type unlocked_brands_historyCreateNestedManyWithoutBrandInput = {
    create?: XOR<unlocked_brands_historyCreateWithoutBrandInput, unlocked_brands_historyUncheckedCreateWithoutBrandInput> | unlocked_brands_historyCreateWithoutBrandInput[] | unlocked_brands_historyUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: unlocked_brands_historyCreateOrConnectWithoutBrandInput | unlocked_brands_historyCreateOrConnectWithoutBrandInput[]
    createMany?: unlocked_brands_historyCreateManyBrandInputEnvelope
    connect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
  }

  export type answersCreateNestedManyWithoutPitchExitBrandInput = {
    create?: XOR<answersCreateWithoutPitchExitBrandInput, answersUncheckedCreateWithoutPitchExitBrandInput> | answersCreateWithoutPitchExitBrandInput[] | answersUncheckedCreateWithoutPitchExitBrandInput[]
    connectOrCreate?: answersCreateOrConnectWithoutPitchExitBrandInput | answersCreateOrConnectWithoutPitchExitBrandInput[]
    createMany?: answersCreateManyPitchExitBrandInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type answersCreateNestedManyWithoutProductFeedbackBrandInput = {
    create?: XOR<answersCreateWithoutProductFeedbackBrandInput, answersUncheckedCreateWithoutProductFeedbackBrandInput> | answersCreateWithoutProductFeedbackBrandInput[] | answersUncheckedCreateWithoutProductFeedbackBrandInput[]
    connectOrCreate?: answersCreateOrConnectWithoutProductFeedbackBrandInput | answersCreateOrConnectWithoutProductFeedbackBrandInput[]
    createMany?: answersCreateManyProductFeedbackBrandInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type brandsCreateusersForYouIdsInput = {
    set: string[]
  }

  export type brandsCreateusersForYouPoolIdsInput = {
    set: string[]
  }

  export type brandsCreateusersNotInterestedBrandsIdsInput = {
    set: string[]
  }

  export type questionsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput> | questionsCreateWithoutBrandInput[] | questionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutBrandInput | questionsCreateOrConnectWithoutBrandInput[]
    createMany?: questionsCreateManyBrandInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type pitch_viewsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<pitch_viewsCreateWithoutBrandInput, pitch_viewsUncheckedCreateWithoutBrandInput> | pitch_viewsCreateWithoutBrandInput[] | pitch_viewsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: pitch_viewsCreateOrConnectWithoutBrandInput | pitch_viewsCreateOrConnectWithoutBrandInput[]
    createMany?: pitch_viewsCreateManyBrandInputEnvelope
    connect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput> | productsCreateWithoutBrandInput[] | productsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandInput | productsCreateOrConnectWithoutBrandInput[]
    createMany?: productsCreateManyBrandInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type ratingsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ratingsCreateWithoutBrandInput, ratingsUncheckedCreateWithoutBrandInput> | ratingsCreateWithoutBrandInput[] | ratingsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutBrandInput | ratingsCreateOrConnectWithoutBrandInput[]
    createMany?: ratingsCreateManyBrandInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutForYouBrandsInput = {
    create?: XOR<usersCreateWithoutForYouBrandsInput, usersUncheckedCreateWithoutForYouBrandsInput> | usersCreateWithoutForYouBrandsInput[] | usersUncheckedCreateWithoutForYouBrandsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutForYouBrandsInput | usersCreateOrConnectWithoutForYouBrandsInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput = {
    create?: XOR<usersCreateWithoutForYouBrandsPoolInput, usersUncheckedCreateWithoutForYouBrandsPoolInput> | usersCreateWithoutForYouBrandsPoolInput[] | usersUncheckedCreateWithoutForYouBrandsPoolInput[]
    connectOrCreate?: usersCreateOrConnectWithoutForYouBrandsPoolInput | usersCreateOrConnectWithoutForYouBrandsPoolInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput = {
    create?: XOR<usersCreateWithoutNotInterestedBrandsInput, usersUncheckedCreateWithoutNotInterestedBrandsInput> | usersCreateWithoutNotInterestedBrandsInput[] | usersUncheckedCreateWithoutNotInterestedBrandsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutNotInterestedBrandsInput | usersCreateOrConnectWithoutNotInterestedBrandsInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type link_visitsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<link_visitsCreateWithoutBrandInput, link_visitsUncheckedCreateWithoutBrandInput> | link_visitsCreateWithoutBrandInput[] | link_visitsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutBrandInput | link_visitsCreateOrConnectWithoutBrandInput[]
    createMany?: link_visitsCreateManyBrandInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<brand_screen_timesCreateWithoutBrandInput, brand_screen_timesUncheckedCreateWithoutBrandInput> | brand_screen_timesCreateWithoutBrandInput[] | brand_screen_timesUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: brand_screen_timesCreateOrConnectWithoutBrandInput | brand_screen_timesCreateOrConnectWithoutBrandInput[]
    createMany?: brand_screen_timesCreateManyBrandInputEnvelope
    connect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
  }

  export type production_submissionsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<production_submissionsCreateWithoutBrandInput, production_submissionsUncheckedCreateWithoutBrandInput> | production_submissionsCreateWithoutBrandInput[] | production_submissionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutBrandInput | production_submissionsCreateOrConnectWithoutBrandInput[]
    createMany?: production_submissionsCreateManyBrandInputEnvelope
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedOneWithoutOwnedBrandInput = {
    create?: XOR<usersCreateWithoutOwnedBrandInput, usersUncheckedCreateWithoutOwnedBrandInput>
    connectOrCreate?: usersCreateOrConnectWithoutOwnedBrandInput
    connect?: usersWhereUniqueInput
  }

  export type postsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<postsCreateWithoutBrandInput, postsUncheckedCreateWithoutBrandInput> | postsCreateWithoutBrandInput[] | postsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: postsCreateOrConnectWithoutBrandInput | postsCreateOrConnectWithoutBrandInput[]
    createMany?: postsCreateManyBrandInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<deal_code_groupsCreateWithoutBrandInput, deal_code_groupsUncheckedCreateWithoutBrandInput> | deal_code_groupsCreateWithoutBrandInput[] | deal_code_groupsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: deal_code_groupsCreateOrConnectWithoutBrandInput | deal_code_groupsCreateOrConnectWithoutBrandInput[]
    createMany?: deal_code_groupsCreateManyBrandInputEnvelope
    connect?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
  }

  export type unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<unlocked_brands_historyCreateWithoutBrandInput, unlocked_brands_historyUncheckedCreateWithoutBrandInput> | unlocked_brands_historyCreateWithoutBrandInput[] | unlocked_brands_historyUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: unlocked_brands_historyCreateOrConnectWithoutBrandInput | unlocked_brands_historyCreateOrConnectWithoutBrandInput[]
    createMany?: unlocked_brands_historyCreateManyBrandInputEnvelope
    connect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
  }

  export type answersUncheckedCreateNestedManyWithoutPitchExitBrandInput = {
    create?: XOR<answersCreateWithoutPitchExitBrandInput, answersUncheckedCreateWithoutPitchExitBrandInput> | answersCreateWithoutPitchExitBrandInput[] | answersUncheckedCreateWithoutPitchExitBrandInput[]
    connectOrCreate?: answersCreateOrConnectWithoutPitchExitBrandInput | answersCreateOrConnectWithoutPitchExitBrandInput[]
    createMany?: answersCreateManyPitchExitBrandInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput = {
    create?: XOR<answersCreateWithoutProductFeedbackBrandInput, answersUncheckedCreateWithoutProductFeedbackBrandInput> | answersCreateWithoutProductFeedbackBrandInput[] | answersUncheckedCreateWithoutProductFeedbackBrandInput[]
    connectOrCreate?: answersCreateOrConnectWithoutProductFeedbackBrandInput | answersCreateOrConnectWithoutProductFeedbackBrandInput[]
    createMany?: answersCreateManyProductFeedbackBrandInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type brandsUpdatelabelsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type brandsUpdatefoundersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type brandsUpdateimagesInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type NullableEnumGenderPreferenceFieldUpdateOperationsInput = {
    set?: $Enums.GenderPreference | null
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type questionsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput> | questionsCreateWithoutBrandInput[] | questionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutBrandInput | questionsCreateOrConnectWithoutBrandInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutBrandInput | questionsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: questionsCreateManyBrandInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutBrandInput | questionsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutBrandInput | questionsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type pitch_viewsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<pitch_viewsCreateWithoutBrandInput, pitch_viewsUncheckedCreateWithoutBrandInput> | pitch_viewsCreateWithoutBrandInput[] | pitch_viewsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: pitch_viewsCreateOrConnectWithoutBrandInput | pitch_viewsCreateOrConnectWithoutBrandInput[]
    upsert?: pitch_viewsUpsertWithWhereUniqueWithoutBrandInput | pitch_viewsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: pitch_viewsCreateManyBrandInputEnvelope
    set?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    disconnect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    delete?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    connect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    update?: pitch_viewsUpdateWithWhereUniqueWithoutBrandInput | pitch_viewsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: pitch_viewsUpdateManyWithWhereWithoutBrandInput | pitch_viewsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: pitch_viewsScalarWhereInput | pitch_viewsScalarWhereInput[]
  }

  export type productsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput> | productsCreateWithoutBrandInput[] | productsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandInput | productsCreateOrConnectWithoutBrandInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutBrandInput | productsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: productsCreateManyBrandInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutBrandInput | productsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: productsUpdateManyWithWhereWithoutBrandInput | productsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type categoriesUpdateOneWithoutBrandsNestedInput = {
    create?: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutBrandsInput
    upsert?: categoriesUpsertWithoutBrandsInput
    disconnect?: boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutBrandsInput, categoriesUpdateWithoutBrandsInput>, categoriesUncheckedUpdateWithoutBrandsInput>
  }

  export type ratingsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ratingsCreateWithoutBrandInput, ratingsUncheckedCreateWithoutBrandInput> | ratingsCreateWithoutBrandInput[] | ratingsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutBrandInput | ratingsCreateOrConnectWithoutBrandInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutBrandInput | ratingsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ratingsCreateManyBrandInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutBrandInput | ratingsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutBrandInput | ratingsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutForYouBrandsNestedInput = {
    create?: XOR<usersCreateWithoutForYouBrandsInput, usersUncheckedCreateWithoutForYouBrandsInput> | usersCreateWithoutForYouBrandsInput[] | usersUncheckedCreateWithoutForYouBrandsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutForYouBrandsInput | usersCreateOrConnectWithoutForYouBrandsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutForYouBrandsInput | usersUpsertWithWhereUniqueWithoutForYouBrandsInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutForYouBrandsInput | usersUpdateWithWhereUniqueWithoutForYouBrandsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutForYouBrandsInput | usersUpdateManyWithWhereWithoutForYouBrandsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUpdateManyWithoutForYouBrandsPoolNestedInput = {
    create?: XOR<usersCreateWithoutForYouBrandsPoolInput, usersUncheckedCreateWithoutForYouBrandsPoolInput> | usersCreateWithoutForYouBrandsPoolInput[] | usersUncheckedCreateWithoutForYouBrandsPoolInput[]
    connectOrCreate?: usersCreateOrConnectWithoutForYouBrandsPoolInput | usersCreateOrConnectWithoutForYouBrandsPoolInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutForYouBrandsPoolInput | usersUpsertWithWhereUniqueWithoutForYouBrandsPoolInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutForYouBrandsPoolInput | usersUpdateWithWhereUniqueWithoutForYouBrandsPoolInput[]
    updateMany?: usersUpdateManyWithWhereWithoutForYouBrandsPoolInput | usersUpdateManyWithWhereWithoutForYouBrandsPoolInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUpdateManyWithoutNotInterestedBrandsNestedInput = {
    create?: XOR<usersCreateWithoutNotInterestedBrandsInput, usersUncheckedCreateWithoutNotInterestedBrandsInput> | usersCreateWithoutNotInterestedBrandsInput[] | usersUncheckedCreateWithoutNotInterestedBrandsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutNotInterestedBrandsInput | usersCreateOrConnectWithoutNotInterestedBrandsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutNotInterestedBrandsInput | usersUpsertWithWhereUniqueWithoutNotInterestedBrandsInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutNotInterestedBrandsInput | usersUpdateWithWhereUniqueWithoutNotInterestedBrandsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutNotInterestedBrandsInput | usersUpdateManyWithWhereWithoutNotInterestedBrandsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type link_visitsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<link_visitsCreateWithoutBrandInput, link_visitsUncheckedCreateWithoutBrandInput> | link_visitsCreateWithoutBrandInput[] | link_visitsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutBrandInput | link_visitsCreateOrConnectWithoutBrandInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutBrandInput | link_visitsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: link_visitsCreateManyBrandInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutBrandInput | link_visitsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutBrandInput | link_visitsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type brand_screen_timesUpdateManyWithoutBrandNestedInput = {
    create?: XOR<brand_screen_timesCreateWithoutBrandInput, brand_screen_timesUncheckedCreateWithoutBrandInput> | brand_screen_timesCreateWithoutBrandInput[] | brand_screen_timesUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: brand_screen_timesCreateOrConnectWithoutBrandInput | brand_screen_timesCreateOrConnectWithoutBrandInput[]
    upsert?: brand_screen_timesUpsertWithWhereUniqueWithoutBrandInput | brand_screen_timesUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: brand_screen_timesCreateManyBrandInputEnvelope
    set?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    disconnect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    delete?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    connect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    update?: brand_screen_timesUpdateWithWhereUniqueWithoutBrandInput | brand_screen_timesUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: brand_screen_timesUpdateManyWithWhereWithoutBrandInput | brand_screen_timesUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: brand_screen_timesScalarWhereInput | brand_screen_timesScalarWhereInput[]
  }

  export type production_submissionsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<production_submissionsCreateWithoutBrandInput, production_submissionsUncheckedCreateWithoutBrandInput> | production_submissionsCreateWithoutBrandInput[] | production_submissionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutBrandInput | production_submissionsCreateOrConnectWithoutBrandInput[]
    upsert?: production_submissionsUpsertWithWhereUniqueWithoutBrandInput | production_submissionsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: production_submissionsCreateManyBrandInputEnvelope
    set?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    disconnect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    delete?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    update?: production_submissionsUpdateWithWhereUniqueWithoutBrandInput | production_submissionsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: production_submissionsUpdateManyWithWhereWithoutBrandInput | production_submissionsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
  }

  export type usersUpdateOneWithoutOwnedBrandNestedInput = {
    create?: XOR<usersCreateWithoutOwnedBrandInput, usersUncheckedCreateWithoutOwnedBrandInput>
    connectOrCreate?: usersCreateOrConnectWithoutOwnedBrandInput
    upsert?: usersUpsertWithoutOwnedBrandInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOwnedBrandInput, usersUpdateWithoutOwnedBrandInput>, usersUncheckedUpdateWithoutOwnedBrandInput>
  }

  export type postsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<postsCreateWithoutBrandInput, postsUncheckedCreateWithoutBrandInput> | postsCreateWithoutBrandInput[] | postsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: postsCreateOrConnectWithoutBrandInput | postsCreateOrConnectWithoutBrandInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutBrandInput | postsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: postsCreateManyBrandInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutBrandInput | postsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: postsUpdateManyWithWhereWithoutBrandInput | postsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type deal_code_groupsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<deal_code_groupsCreateWithoutBrandInput, deal_code_groupsUncheckedCreateWithoutBrandInput> | deal_code_groupsCreateWithoutBrandInput[] | deal_code_groupsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: deal_code_groupsCreateOrConnectWithoutBrandInput | deal_code_groupsCreateOrConnectWithoutBrandInput[]
    upsert?: deal_code_groupsUpsertWithWhereUniqueWithoutBrandInput | deal_code_groupsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: deal_code_groupsCreateManyBrandInputEnvelope
    set?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
    disconnect?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
    delete?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
    connect?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
    update?: deal_code_groupsUpdateWithWhereUniqueWithoutBrandInput | deal_code_groupsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: deal_code_groupsUpdateManyWithWhereWithoutBrandInput | deal_code_groupsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: deal_code_groupsScalarWhereInput | deal_code_groupsScalarWhereInput[]
  }

  export type unlocked_brands_historyUpdateManyWithoutBrandNestedInput = {
    create?: XOR<unlocked_brands_historyCreateWithoutBrandInput, unlocked_brands_historyUncheckedCreateWithoutBrandInput> | unlocked_brands_historyCreateWithoutBrandInput[] | unlocked_brands_historyUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: unlocked_brands_historyCreateOrConnectWithoutBrandInput | unlocked_brands_historyCreateOrConnectWithoutBrandInput[]
    upsert?: unlocked_brands_historyUpsertWithWhereUniqueWithoutBrandInput | unlocked_brands_historyUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: unlocked_brands_historyCreateManyBrandInputEnvelope
    set?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    disconnect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    delete?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    connect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    update?: unlocked_brands_historyUpdateWithWhereUniqueWithoutBrandInput | unlocked_brands_historyUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: unlocked_brands_historyUpdateManyWithWhereWithoutBrandInput | unlocked_brands_historyUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: unlocked_brands_historyScalarWhereInput | unlocked_brands_historyScalarWhereInput[]
  }

  export type answersUpdateManyWithoutPitchExitBrandNestedInput = {
    create?: XOR<answersCreateWithoutPitchExitBrandInput, answersUncheckedCreateWithoutPitchExitBrandInput> | answersCreateWithoutPitchExitBrandInput[] | answersUncheckedCreateWithoutPitchExitBrandInput[]
    connectOrCreate?: answersCreateOrConnectWithoutPitchExitBrandInput | answersCreateOrConnectWithoutPitchExitBrandInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutPitchExitBrandInput | answersUpsertWithWhereUniqueWithoutPitchExitBrandInput[]
    createMany?: answersCreateManyPitchExitBrandInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutPitchExitBrandInput | answersUpdateWithWhereUniqueWithoutPitchExitBrandInput[]
    updateMany?: answersUpdateManyWithWhereWithoutPitchExitBrandInput | answersUpdateManyWithWhereWithoutPitchExitBrandInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type answersUpdateManyWithoutProductFeedbackBrandNestedInput = {
    create?: XOR<answersCreateWithoutProductFeedbackBrandInput, answersUncheckedCreateWithoutProductFeedbackBrandInput> | answersCreateWithoutProductFeedbackBrandInput[] | answersUncheckedCreateWithoutProductFeedbackBrandInput[]
    connectOrCreate?: answersCreateOrConnectWithoutProductFeedbackBrandInput | answersCreateOrConnectWithoutProductFeedbackBrandInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutProductFeedbackBrandInput | answersUpsertWithWhereUniqueWithoutProductFeedbackBrandInput[]
    createMany?: answersCreateManyProductFeedbackBrandInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutProductFeedbackBrandInput | answersUpdateWithWhereUniqueWithoutProductFeedbackBrandInput[]
    updateMany?: answersUpdateManyWithWhereWithoutProductFeedbackBrandInput | answersUpdateManyWithWhereWithoutProductFeedbackBrandInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type brandsUpdateusersForYouIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type brandsUpdateusersForYouPoolIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type brandsUpdateusersNotInterestedBrandsIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type questionsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput> | questionsCreateWithoutBrandInput[] | questionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutBrandInput | questionsCreateOrConnectWithoutBrandInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutBrandInput | questionsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: questionsCreateManyBrandInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutBrandInput | questionsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutBrandInput | questionsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<pitch_viewsCreateWithoutBrandInput, pitch_viewsUncheckedCreateWithoutBrandInput> | pitch_viewsCreateWithoutBrandInput[] | pitch_viewsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: pitch_viewsCreateOrConnectWithoutBrandInput | pitch_viewsCreateOrConnectWithoutBrandInput[]
    upsert?: pitch_viewsUpsertWithWhereUniqueWithoutBrandInput | pitch_viewsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: pitch_viewsCreateManyBrandInputEnvelope
    set?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    disconnect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    delete?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    connect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    update?: pitch_viewsUpdateWithWhereUniqueWithoutBrandInput | pitch_viewsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: pitch_viewsUpdateManyWithWhereWithoutBrandInput | pitch_viewsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: pitch_viewsScalarWhereInput | pitch_viewsScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput> | productsCreateWithoutBrandInput[] | productsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productsCreateOrConnectWithoutBrandInput | productsCreateOrConnectWithoutBrandInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutBrandInput | productsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: productsCreateManyBrandInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutBrandInput | productsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: productsUpdateManyWithWhereWithoutBrandInput | productsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type ratingsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ratingsCreateWithoutBrandInput, ratingsUncheckedCreateWithoutBrandInput> | ratingsCreateWithoutBrandInput[] | ratingsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutBrandInput | ratingsCreateOrConnectWithoutBrandInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutBrandInput | ratingsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ratingsCreateManyBrandInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutBrandInput | ratingsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutBrandInput | ratingsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutForYouBrandsNestedInput = {
    create?: XOR<usersCreateWithoutForYouBrandsInput, usersUncheckedCreateWithoutForYouBrandsInput> | usersCreateWithoutForYouBrandsInput[] | usersUncheckedCreateWithoutForYouBrandsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutForYouBrandsInput | usersCreateOrConnectWithoutForYouBrandsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutForYouBrandsInput | usersUpsertWithWhereUniqueWithoutForYouBrandsInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutForYouBrandsInput | usersUpdateWithWhereUniqueWithoutForYouBrandsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutForYouBrandsInput | usersUpdateManyWithWhereWithoutForYouBrandsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput = {
    create?: XOR<usersCreateWithoutForYouBrandsPoolInput, usersUncheckedCreateWithoutForYouBrandsPoolInput> | usersCreateWithoutForYouBrandsPoolInput[] | usersUncheckedCreateWithoutForYouBrandsPoolInput[]
    connectOrCreate?: usersCreateOrConnectWithoutForYouBrandsPoolInput | usersCreateOrConnectWithoutForYouBrandsPoolInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutForYouBrandsPoolInput | usersUpsertWithWhereUniqueWithoutForYouBrandsPoolInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutForYouBrandsPoolInput | usersUpdateWithWhereUniqueWithoutForYouBrandsPoolInput[]
    updateMany?: usersUpdateManyWithWhereWithoutForYouBrandsPoolInput | usersUpdateManyWithWhereWithoutForYouBrandsPoolInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput = {
    create?: XOR<usersCreateWithoutNotInterestedBrandsInput, usersUncheckedCreateWithoutNotInterestedBrandsInput> | usersCreateWithoutNotInterestedBrandsInput[] | usersUncheckedCreateWithoutNotInterestedBrandsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutNotInterestedBrandsInput | usersCreateOrConnectWithoutNotInterestedBrandsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutNotInterestedBrandsInput | usersUpsertWithWhereUniqueWithoutNotInterestedBrandsInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutNotInterestedBrandsInput | usersUpdateWithWhereUniqueWithoutNotInterestedBrandsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutNotInterestedBrandsInput | usersUpdateManyWithWhereWithoutNotInterestedBrandsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type link_visitsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<link_visitsCreateWithoutBrandInput, link_visitsUncheckedCreateWithoutBrandInput> | link_visitsCreateWithoutBrandInput[] | link_visitsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutBrandInput | link_visitsCreateOrConnectWithoutBrandInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutBrandInput | link_visitsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: link_visitsCreateManyBrandInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutBrandInput | link_visitsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutBrandInput | link_visitsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<brand_screen_timesCreateWithoutBrandInput, brand_screen_timesUncheckedCreateWithoutBrandInput> | brand_screen_timesCreateWithoutBrandInput[] | brand_screen_timesUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: brand_screen_timesCreateOrConnectWithoutBrandInput | brand_screen_timesCreateOrConnectWithoutBrandInput[]
    upsert?: brand_screen_timesUpsertWithWhereUniqueWithoutBrandInput | brand_screen_timesUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: brand_screen_timesCreateManyBrandInputEnvelope
    set?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    disconnect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    delete?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    connect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    update?: brand_screen_timesUpdateWithWhereUniqueWithoutBrandInput | brand_screen_timesUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: brand_screen_timesUpdateManyWithWhereWithoutBrandInput | brand_screen_timesUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: brand_screen_timesScalarWhereInput | brand_screen_timesScalarWhereInput[]
  }

  export type production_submissionsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<production_submissionsCreateWithoutBrandInput, production_submissionsUncheckedCreateWithoutBrandInput> | production_submissionsCreateWithoutBrandInput[] | production_submissionsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutBrandInput | production_submissionsCreateOrConnectWithoutBrandInput[]
    upsert?: production_submissionsUpsertWithWhereUniqueWithoutBrandInput | production_submissionsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: production_submissionsCreateManyBrandInputEnvelope
    set?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    disconnect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    delete?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    update?: production_submissionsUpdateWithWhereUniqueWithoutBrandInput | production_submissionsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: production_submissionsUpdateManyWithWhereWithoutBrandInput | production_submissionsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
  }

  export type usersUncheckedUpdateOneWithoutOwnedBrandNestedInput = {
    create?: XOR<usersCreateWithoutOwnedBrandInput, usersUncheckedCreateWithoutOwnedBrandInput>
    connectOrCreate?: usersCreateOrConnectWithoutOwnedBrandInput
    upsert?: usersUpsertWithoutOwnedBrandInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOwnedBrandInput, usersUpdateWithoutOwnedBrandInput>, usersUncheckedUpdateWithoutOwnedBrandInput>
  }

  export type postsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<postsCreateWithoutBrandInput, postsUncheckedCreateWithoutBrandInput> | postsCreateWithoutBrandInput[] | postsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: postsCreateOrConnectWithoutBrandInput | postsCreateOrConnectWithoutBrandInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutBrandInput | postsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: postsCreateManyBrandInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutBrandInput | postsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: postsUpdateManyWithWhereWithoutBrandInput | postsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<deal_code_groupsCreateWithoutBrandInput, deal_code_groupsUncheckedCreateWithoutBrandInput> | deal_code_groupsCreateWithoutBrandInput[] | deal_code_groupsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: deal_code_groupsCreateOrConnectWithoutBrandInput | deal_code_groupsCreateOrConnectWithoutBrandInput[]
    upsert?: deal_code_groupsUpsertWithWhereUniqueWithoutBrandInput | deal_code_groupsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: deal_code_groupsCreateManyBrandInputEnvelope
    set?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
    disconnect?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
    delete?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
    connect?: deal_code_groupsWhereUniqueInput | deal_code_groupsWhereUniqueInput[]
    update?: deal_code_groupsUpdateWithWhereUniqueWithoutBrandInput | deal_code_groupsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: deal_code_groupsUpdateManyWithWhereWithoutBrandInput | deal_code_groupsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: deal_code_groupsScalarWhereInput | deal_code_groupsScalarWhereInput[]
  }

  export type unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<unlocked_brands_historyCreateWithoutBrandInput, unlocked_brands_historyUncheckedCreateWithoutBrandInput> | unlocked_brands_historyCreateWithoutBrandInput[] | unlocked_brands_historyUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: unlocked_brands_historyCreateOrConnectWithoutBrandInput | unlocked_brands_historyCreateOrConnectWithoutBrandInput[]
    upsert?: unlocked_brands_historyUpsertWithWhereUniqueWithoutBrandInput | unlocked_brands_historyUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: unlocked_brands_historyCreateManyBrandInputEnvelope
    set?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    disconnect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    delete?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    connect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    update?: unlocked_brands_historyUpdateWithWhereUniqueWithoutBrandInput | unlocked_brands_historyUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: unlocked_brands_historyUpdateManyWithWhereWithoutBrandInput | unlocked_brands_historyUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: unlocked_brands_historyScalarWhereInput | unlocked_brands_historyScalarWhereInput[]
  }

  export type answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput = {
    create?: XOR<answersCreateWithoutPitchExitBrandInput, answersUncheckedCreateWithoutPitchExitBrandInput> | answersCreateWithoutPitchExitBrandInput[] | answersUncheckedCreateWithoutPitchExitBrandInput[]
    connectOrCreate?: answersCreateOrConnectWithoutPitchExitBrandInput | answersCreateOrConnectWithoutPitchExitBrandInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutPitchExitBrandInput | answersUpsertWithWhereUniqueWithoutPitchExitBrandInput[]
    createMany?: answersCreateManyPitchExitBrandInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutPitchExitBrandInput | answersUpdateWithWhereUniqueWithoutPitchExitBrandInput[]
    updateMany?: answersUpdateManyWithWhereWithoutPitchExitBrandInput | answersUpdateManyWithWhereWithoutPitchExitBrandInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput = {
    create?: XOR<answersCreateWithoutProductFeedbackBrandInput, answersUncheckedCreateWithoutProductFeedbackBrandInput> | answersCreateWithoutProductFeedbackBrandInput[] | answersUncheckedCreateWithoutProductFeedbackBrandInput[]
    connectOrCreate?: answersCreateOrConnectWithoutProductFeedbackBrandInput | answersCreateOrConnectWithoutProductFeedbackBrandInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutProductFeedbackBrandInput | answersUpsertWithWhereUniqueWithoutProductFeedbackBrandInput[]
    createMany?: answersCreateManyProductFeedbackBrandInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutProductFeedbackBrandInput | answersUpdateWithWhereUniqueWithoutProductFeedbackBrandInput[]
    updateMany?: answersUpdateManyWithWhereWithoutProductFeedbackBrandInput | answersUpdateManyWithWhereWithoutProductFeedbackBrandInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutBrandUnlockHistoryInput = {
    create?: XOR<usersCreateWithoutBrandUnlockHistoryInput, usersUncheckedCreateWithoutBrandUnlockHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutBrandUnlockHistoryInput
    connect?: usersWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutUnlockHistoryInput = {
    create?: XOR<brandsCreateWithoutUnlockHistoryInput, brandsUncheckedCreateWithoutUnlockHistoryInput>
    connectOrCreate?: brandsCreateOrConnectWithoutUnlockHistoryInput
    connect?: brandsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutBrandUnlockHistoryNestedInput = {
    create?: XOR<usersCreateWithoutBrandUnlockHistoryInput, usersUncheckedCreateWithoutBrandUnlockHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutBrandUnlockHistoryInput
    upsert?: usersUpsertWithoutBrandUnlockHistoryInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBrandUnlockHistoryInput, usersUpdateWithoutBrandUnlockHistoryInput>, usersUncheckedUpdateWithoutBrandUnlockHistoryInput>
  }

  export type brandsUpdateOneWithoutUnlockHistoryNestedInput = {
    create?: XOR<brandsCreateWithoutUnlockHistoryInput, brandsUncheckedCreateWithoutUnlockHistoryInput>
    connectOrCreate?: brandsCreateOrConnectWithoutUnlockHistoryInput
    upsert?: brandsUpsertWithoutUnlockHistoryInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutUnlockHistoryInput, brandsUpdateWithoutUnlockHistoryInput>, brandsUncheckedUpdateWithoutUnlockHistoryInput>
  }

  export type usersCreateNestedOneWithoutBrandScreenTimesInput = {
    create?: XOR<usersCreateWithoutBrandScreenTimesInput, usersUncheckedCreateWithoutBrandScreenTimesInput>
    connectOrCreate?: usersCreateOrConnectWithoutBrandScreenTimesInput
    connect?: usersWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutBrandScreenTimesInput = {
    create?: XOR<brandsCreateWithoutBrandScreenTimesInput, brandsUncheckedCreateWithoutBrandScreenTimesInput>
    connectOrCreate?: brandsCreateOrConnectWithoutBrandScreenTimesInput
    connect?: brandsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutBrandScreenTimesNestedInput = {
    create?: XOR<usersCreateWithoutBrandScreenTimesInput, usersUncheckedCreateWithoutBrandScreenTimesInput>
    connectOrCreate?: usersCreateOrConnectWithoutBrandScreenTimesInput
    upsert?: usersUpsertWithoutBrandScreenTimesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBrandScreenTimesInput, usersUpdateWithoutBrandScreenTimesInput>, usersUncheckedUpdateWithoutBrandScreenTimesInput>
  }

  export type brandsUpdateOneWithoutBrandScreenTimesNestedInput = {
    create?: XOR<brandsCreateWithoutBrandScreenTimesInput, brandsUncheckedCreateWithoutBrandScreenTimesInput>
    connectOrCreate?: brandsCreateOrConnectWithoutBrandScreenTimesInput
    upsert?: brandsUpsertWithoutBrandScreenTimesInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutBrandScreenTimesInput, brandsUpdateWithoutBrandScreenTimesInput>, brandsUncheckedUpdateWithoutBrandScreenTimesInput>
  }

  export type brandsCreateNestedManyWithoutCategoryInput = {
    create?: XOR<brandsCreateWithoutCategoryInput, brandsUncheckedCreateWithoutCategoryInput> | brandsCreateWithoutCategoryInput[] | brandsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutCategoryInput | brandsCreateOrConnectWithoutCategoryInput[]
    createMany?: brandsCreateManyCategoryInputEnvelope
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type category_choicesCreateNestedManyWithoutCategoryInput = {
    create?: XOR<category_choicesCreateWithoutCategoryInput, category_choicesUncheckedCreateWithoutCategoryInput> | category_choicesCreateWithoutCategoryInput[] | category_choicesUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: category_choicesCreateOrConnectWithoutCategoryInput | category_choicesCreateOrConnectWithoutCategoryInput[]
    createMany?: category_choicesCreateManyCategoryInputEnvelope
    connect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
  }

  export type brandsUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<brandsCreateWithoutCategoryInput, brandsUncheckedCreateWithoutCategoryInput> | brandsCreateWithoutCategoryInput[] | brandsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutCategoryInput | brandsCreateOrConnectWithoutCategoryInput[]
    createMany?: brandsCreateManyCategoryInputEnvelope
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type category_choicesUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<category_choicesCreateWithoutCategoryInput, category_choicesUncheckedCreateWithoutCategoryInput> | category_choicesCreateWithoutCategoryInput[] | category_choicesUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: category_choicesCreateOrConnectWithoutCategoryInput | category_choicesCreateOrConnectWithoutCategoryInput[]
    createMany?: category_choicesCreateManyCategoryInputEnvelope
    connect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
  }

  export type brandsUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<brandsCreateWithoutCategoryInput, brandsUncheckedCreateWithoutCategoryInput> | brandsCreateWithoutCategoryInput[] | brandsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutCategoryInput | brandsCreateOrConnectWithoutCategoryInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutCategoryInput | brandsUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: brandsCreateManyCategoryInputEnvelope
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutCategoryInput | brandsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutCategoryInput | brandsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type category_choicesUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<category_choicesCreateWithoutCategoryInput, category_choicesUncheckedCreateWithoutCategoryInput> | category_choicesCreateWithoutCategoryInput[] | category_choicesUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: category_choicesCreateOrConnectWithoutCategoryInput | category_choicesCreateOrConnectWithoutCategoryInput[]
    upsert?: category_choicesUpsertWithWhereUniqueWithoutCategoryInput | category_choicesUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: category_choicesCreateManyCategoryInputEnvelope
    set?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    disconnect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    delete?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    connect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    update?: category_choicesUpdateWithWhereUniqueWithoutCategoryInput | category_choicesUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: category_choicesUpdateManyWithWhereWithoutCategoryInput | category_choicesUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: category_choicesScalarWhereInput | category_choicesScalarWhereInput[]
  }

  export type brandsUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<brandsCreateWithoutCategoryInput, brandsUncheckedCreateWithoutCategoryInput> | brandsCreateWithoutCategoryInput[] | brandsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutCategoryInput | brandsCreateOrConnectWithoutCategoryInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutCategoryInput | brandsUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: brandsCreateManyCategoryInputEnvelope
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutCategoryInput | brandsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutCategoryInput | brandsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type category_choicesUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<category_choicesCreateWithoutCategoryInput, category_choicesUncheckedCreateWithoutCategoryInput> | category_choicesCreateWithoutCategoryInput[] | category_choicesUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: category_choicesCreateOrConnectWithoutCategoryInput | category_choicesCreateOrConnectWithoutCategoryInput[]
    upsert?: category_choicesUpsertWithWhereUniqueWithoutCategoryInput | category_choicesUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: category_choicesCreateManyCategoryInputEnvelope
    set?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    disconnect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    delete?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    connect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    update?: category_choicesUpdateWithWhereUniqueWithoutCategoryInput | category_choicesUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: category_choicesUpdateManyWithWhereWithoutCategoryInput | category_choicesUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: category_choicesScalarWhereInput | category_choicesScalarWhereInput[]
  }

  export type categoriesCreateNestedOneWithoutUserChoicesInput = {
    create?: XOR<categoriesCreateWithoutUserChoicesInput, categoriesUncheckedCreateWithoutUserChoicesInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutUserChoicesInput
    connect?: categoriesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCategoryChoicesInput = {
    create?: XOR<usersCreateWithoutCategoryChoicesInput, usersUncheckedCreateWithoutCategoryChoicesInput>
    connectOrCreate?: usersCreateOrConnectWithoutCategoryChoicesInput
    connect?: usersWhereUniqueInput
  }

  export type categoriesUpdateOneRequiredWithoutUserChoicesNestedInput = {
    create?: XOR<categoriesCreateWithoutUserChoicesInput, categoriesUncheckedCreateWithoutUserChoicesInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutUserChoicesInput
    upsert?: categoriesUpsertWithoutUserChoicesInput
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutUserChoicesInput, categoriesUpdateWithoutUserChoicesInput>, categoriesUncheckedUpdateWithoutUserChoicesInput>
  }

  export type usersUpdateOneRequiredWithoutCategoryChoicesNestedInput = {
    create?: XOR<usersCreateWithoutCategoryChoicesInput, usersUncheckedCreateWithoutCategoryChoicesInput>
    connectOrCreate?: usersCreateOrConnectWithoutCategoryChoicesInput
    upsert?: usersUpsertWithoutCategoryChoicesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCategoryChoicesInput, usersUpdateWithoutCategoryChoicesInput>, usersUncheckedUpdateWithoutCategoryChoicesInput>
  }

  export type usersCreateNestedManyWithoutFoundersReachedLeaderboardInput = {
    create?: XOR<usersCreateWithoutFoundersReachedLeaderboardInput, usersUncheckedCreateWithoutFoundersReachedLeaderboardInput> | usersCreateWithoutFoundersReachedLeaderboardInput[] | usersUncheckedCreateWithoutFoundersReachedLeaderboardInput[]
    connectOrCreate?: usersCreateOrConnectWithoutFoundersReachedLeaderboardInput | usersCreateOrConnectWithoutFoundersReachedLeaderboardInput[]
    createMany?: usersCreateManyFoundersReachedLeaderboardInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutFoundersReachedLeaderboardInput = {
    create?: XOR<usersCreateWithoutFoundersReachedLeaderboardInput, usersUncheckedCreateWithoutFoundersReachedLeaderboardInput> | usersCreateWithoutFoundersReachedLeaderboardInput[] | usersUncheckedCreateWithoutFoundersReachedLeaderboardInput[]
    connectOrCreate?: usersCreateOrConnectWithoutFoundersReachedLeaderboardInput | usersCreateOrConnectWithoutFoundersReachedLeaderboardInput[]
    createMany?: usersCreateManyFoundersReachedLeaderboardInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutFoundersReachedLeaderboardNestedInput = {
    create?: XOR<usersCreateWithoutFoundersReachedLeaderboardInput, usersUncheckedCreateWithoutFoundersReachedLeaderboardInput> | usersCreateWithoutFoundersReachedLeaderboardInput[] | usersUncheckedCreateWithoutFoundersReachedLeaderboardInput[]
    connectOrCreate?: usersCreateOrConnectWithoutFoundersReachedLeaderboardInput | usersCreateOrConnectWithoutFoundersReachedLeaderboardInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutFoundersReachedLeaderboardInput | usersUpsertWithWhereUniqueWithoutFoundersReachedLeaderboardInput[]
    createMany?: usersCreateManyFoundersReachedLeaderboardInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutFoundersReachedLeaderboardInput | usersUpdateWithWhereUniqueWithoutFoundersReachedLeaderboardInput[]
    updateMany?: usersUpdateManyWithWhereWithoutFoundersReachedLeaderboardInput | usersUpdateManyWithWhereWithoutFoundersReachedLeaderboardInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutFoundersReachedLeaderboardNestedInput = {
    create?: XOR<usersCreateWithoutFoundersReachedLeaderboardInput, usersUncheckedCreateWithoutFoundersReachedLeaderboardInput> | usersCreateWithoutFoundersReachedLeaderboardInput[] | usersUncheckedCreateWithoutFoundersReachedLeaderboardInput[]
    connectOrCreate?: usersCreateOrConnectWithoutFoundersReachedLeaderboardInput | usersCreateOrConnectWithoutFoundersReachedLeaderboardInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutFoundersReachedLeaderboardInput | usersUpsertWithWhereUniqueWithoutFoundersReachedLeaderboardInput[]
    createMany?: usersCreateManyFoundersReachedLeaderboardInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutFoundersReachedLeaderboardInput | usersUpdateWithWhereUniqueWithoutFoundersReachedLeaderboardInput[]
    updateMany?: usersUpdateManyWithWhereWithoutFoundersReachedLeaderboardInput | usersUpdateManyWithWhereWithoutFoundersReachedLeaderboardInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutLinkVisitsInput = {
    create?: XOR<usersCreateWithoutLinkVisitsInput, usersUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLinkVisitsInput
    connect?: usersWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutLinkVisitsInput = {
    create?: XOR<brandsCreateWithoutLinkVisitsInput, brandsUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutLinkVisitsInput
    connect?: brandsWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutLinkVisitsInput = {
    create?: XOR<productsCreateWithoutLinkVisitsInput, productsUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: productsCreateOrConnectWithoutLinkVisitsInput
    connect?: productsWhereUniqueInput
  }

  export type benefitsCreateNestedOneWithoutLinkVisitsInput = {
    create?: XOR<benefitsCreateWithoutLinkVisitsInput, benefitsUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: benefitsCreateOrConnectWithoutLinkVisitsInput
    connect?: benefitsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutLinkVisitsNestedInput = {
    create?: XOR<usersCreateWithoutLinkVisitsInput, usersUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: usersCreateOrConnectWithoutLinkVisitsInput
    upsert?: usersUpsertWithoutLinkVisitsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLinkVisitsInput, usersUpdateWithoutLinkVisitsInput>, usersUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type brandsUpdateOneWithoutLinkVisitsNestedInput = {
    create?: XOR<brandsCreateWithoutLinkVisitsInput, brandsUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutLinkVisitsInput
    upsert?: brandsUpsertWithoutLinkVisitsInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutLinkVisitsInput, brandsUpdateWithoutLinkVisitsInput>, brandsUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type productsUpdateOneWithoutLinkVisitsNestedInput = {
    create?: XOR<productsCreateWithoutLinkVisitsInput, productsUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: productsCreateOrConnectWithoutLinkVisitsInput
    upsert?: productsUpsertWithoutLinkVisitsInput
    disconnect?: boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutLinkVisitsInput, productsUpdateWithoutLinkVisitsInput>, productsUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type benefitsUpdateOneWithoutLinkVisitsNestedInput = {
    create?: XOR<benefitsCreateWithoutLinkVisitsInput, benefitsUncheckedCreateWithoutLinkVisitsInput>
    connectOrCreate?: benefitsCreateOrConnectWithoutLinkVisitsInput
    upsert?: benefitsUpsertWithoutLinkVisitsInput
    disconnect?: boolean
    delete?: benefitsWhereInput | boolean
    connect?: benefitsWhereUniqueInput
    update?: XOR<XOR<benefitsUpdateToOneWithWhereWithoutLinkVisitsInput, benefitsUpdateWithoutLinkVisitsInput>, benefitsUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type usersCreateNestedOneWithoutPitchViewsInput = {
    create?: XOR<usersCreateWithoutPitchViewsInput, usersUncheckedCreateWithoutPitchViewsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPitchViewsInput
    connect?: usersWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutPitchViewsInput = {
    create?: XOR<brandsCreateWithoutPitchViewsInput, brandsUncheckedCreateWithoutPitchViewsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPitchViewsInput
    connect?: brandsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPitchViewsNestedInput = {
    create?: XOR<usersCreateWithoutPitchViewsInput, usersUncheckedCreateWithoutPitchViewsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPitchViewsInput
    upsert?: usersUpsertWithoutPitchViewsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPitchViewsInput, usersUpdateWithoutPitchViewsInput>, usersUncheckedUpdateWithoutPitchViewsInput>
  }

  export type brandsUpdateOneWithoutPitchViewsNestedInput = {
    create?: XOR<brandsCreateWithoutPitchViewsInput, brandsUncheckedCreateWithoutPitchViewsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPitchViewsInput
    upsert?: brandsUpsertWithoutPitchViewsInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutPitchViewsInput, brandsUpdateWithoutPitchViewsInput>, brandsUncheckedUpdateWithoutPitchViewsInput>
  }

  export type brandsCreateNestedOneWithoutPostsInput = {
    create?: XOR<brandsCreateWithoutPostsInput, brandsUncheckedCreateWithoutPostsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPostsInput
    connect?: brandsWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutLikedPostsInput = {
    create?: XOR<usersCreateWithoutLikedPostsInput, usersUncheckedCreateWithoutLikedPostsInput> | usersCreateWithoutLikedPostsInput[] | usersUncheckedCreateWithoutLikedPostsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLikedPostsInput | usersCreateOrConnectWithoutLikedPostsInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type postsCreateuserLikesIdsInput = {
    set: string[]
  }

  export type usersUncheckedCreateNestedManyWithoutLikedPostsInput = {
    create?: XOR<usersCreateWithoutLikedPostsInput, usersUncheckedCreateWithoutLikedPostsInput> | usersCreateWithoutLikedPostsInput[] | usersUncheckedCreateWithoutLikedPostsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLikedPostsInput | usersCreateOrConnectWithoutLikedPostsInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type brandsUpdateOneWithoutPostsNestedInput = {
    create?: XOR<brandsCreateWithoutPostsInput, brandsUncheckedCreateWithoutPostsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPostsInput
    upsert?: brandsUpsertWithoutPostsInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutPostsInput, brandsUpdateWithoutPostsInput>, brandsUncheckedUpdateWithoutPostsInput>
  }

  export type usersUpdateManyWithoutLikedPostsNestedInput = {
    create?: XOR<usersCreateWithoutLikedPostsInput, usersUncheckedCreateWithoutLikedPostsInput> | usersCreateWithoutLikedPostsInput[] | usersUncheckedCreateWithoutLikedPostsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLikedPostsInput | usersCreateOrConnectWithoutLikedPostsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutLikedPostsInput | usersUpsertWithWhereUniqueWithoutLikedPostsInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutLikedPostsInput | usersUpdateWithWhereUniqueWithoutLikedPostsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutLikedPostsInput | usersUpdateManyWithWhereWithoutLikedPostsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type postsUpdateuserLikesIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUncheckedUpdateManyWithoutLikedPostsNestedInput = {
    create?: XOR<usersCreateWithoutLikedPostsInput, usersUncheckedCreateWithoutLikedPostsInput> | usersCreateWithoutLikedPostsInput[] | usersUncheckedCreateWithoutLikedPostsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLikedPostsInput | usersCreateOrConnectWithoutLikedPostsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutLikedPostsInput | usersUpsertWithWhereUniqueWithoutLikedPostsInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutLikedPostsInput | usersUpdateWithWhereUniqueWithoutLikedPostsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutLikedPostsInput | usersUpdateManyWithWhereWithoutLikedPostsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type production_submissionsCreateoverlaysInput = {
    set: InputJsonValue[]
  }

  export type production_submissionsCreatevideosInput = {
    set: InputJsonValue[]
  }

  export type brandsCreateNestedOneWithoutProductionSubmissionsInput = {
    create?: XOR<brandsCreateWithoutProductionSubmissionsInput, brandsUncheckedCreateWithoutProductionSubmissionsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductionSubmissionsInput
    connect?: brandsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutProductionSubmissionsInput = {
    create?: XOR<usersCreateWithoutProductionSubmissionsInput, usersUncheckedCreateWithoutProductionSubmissionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutProductionSubmissionsInput
    connect?: usersWhereUniqueInput
  }

  export type production_submissionsUpdateoverlaysInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type production_submissionsUpdatevideosInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type brandsUpdateOneRequiredWithoutProductionSubmissionsNestedInput = {
    create?: XOR<brandsCreateWithoutProductionSubmissionsInput, brandsUncheckedCreateWithoutProductionSubmissionsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductionSubmissionsInput
    upsert?: brandsUpsertWithoutProductionSubmissionsInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutProductionSubmissionsInput, brandsUpdateWithoutProductionSubmissionsInput>, brandsUncheckedUpdateWithoutProductionSubmissionsInput>
  }

  export type usersUpdateOneRequiredWithoutProductionSubmissionsNestedInput = {
    create?: XOR<usersCreateWithoutProductionSubmissionsInput, usersUncheckedCreateWithoutProductionSubmissionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutProductionSubmissionsInput
    upsert?: usersUpsertWithoutProductionSubmissionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProductionSubmissionsInput, usersUpdateWithoutProductionSubmissionsInput>, usersUncheckedUpdateWithoutProductionSubmissionsInput>
  }

  export type productsCreateimagesInput = {
    set: InputJsonValue[]
  }

  export type brandsCreateNestedOneWithoutProductsInput = {
    create?: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductsInput
    connect?: brandsWhereUniqueInput
  }

  export type link_visitsCreateNestedManyWithoutProductInput = {
    create?: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput> | link_visitsCreateWithoutProductInput[] | link_visitsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutProductInput | link_visitsCreateOrConnectWithoutProductInput[]
    createMany?: link_visitsCreateManyProductInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type ratingsCreateNestedManyWithoutProductInput = {
    create?: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput> | ratingsCreateWithoutProductInput[] | ratingsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutProductInput | ratingsCreateOrConnectWithoutProductInput[]
    createMany?: ratingsCreateManyProductInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type link_visitsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput> | link_visitsCreateWithoutProductInput[] | link_visitsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutProductInput | link_visitsCreateOrConnectWithoutProductInput[]
    createMany?: link_visitsCreateManyProductInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type ratingsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput> | ratingsCreateWithoutProductInput[] | ratingsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutProductInput | ratingsCreateOrConnectWithoutProductInput[]
    createMany?: ratingsCreateManyProductInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type productsUpdateimagesInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type brandsUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutProductsInput
    upsert?: brandsUpsertWithoutProductsInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutProductsInput, brandsUpdateWithoutProductsInput>, brandsUncheckedUpdateWithoutProductsInput>
  }

  export type link_visitsUpdateManyWithoutProductNestedInput = {
    create?: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput> | link_visitsCreateWithoutProductInput[] | link_visitsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutProductInput | link_visitsCreateOrConnectWithoutProductInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutProductInput | link_visitsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: link_visitsCreateManyProductInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutProductInput | link_visitsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutProductInput | link_visitsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type ratingsUpdateManyWithoutProductNestedInput = {
    create?: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput> | ratingsCreateWithoutProductInput[] | ratingsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutProductInput | ratingsCreateOrConnectWithoutProductInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutProductInput | ratingsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ratingsCreateManyProductInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutProductInput | ratingsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutProductInput | ratingsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type link_visitsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput> | link_visitsCreateWithoutProductInput[] | link_visitsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutProductInput | link_visitsCreateOrConnectWithoutProductInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutProductInput | link_visitsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: link_visitsCreateManyProductInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutProductInput | link_visitsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutProductInput | link_visitsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type ratingsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput> | ratingsCreateWithoutProductInput[] | ratingsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutProductInput | ratingsCreateOrConnectWithoutProductInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutProductInput | ratingsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ratingsCreateManyProductInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutProductInput | ratingsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutProductInput | ratingsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type NullableEnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType | null
    unset?: boolean
  }

  export type usersCreateNestedOneWithoutPushNotificationHistoryInput = {
    create?: XOR<usersCreateWithoutPushNotificationHistoryInput, usersUncheckedCreateWithoutPushNotificationHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutPushNotificationHistoryInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPushNotificationHistoryNestedInput = {
    create?: XOR<usersCreateWithoutPushNotificationHistoryInput, usersUncheckedCreateWithoutPushNotificationHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutPushNotificationHistoryInput
    upsert?: usersUpsertWithoutPushNotificationHistoryInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPushNotificationHistoryInput, usersUpdateWithoutPushNotificationHistoryInput>, usersUncheckedUpdateWithoutPushNotificationHistoryInput>
  }

  export type questionsCreateNestedManyWithoutQuestionnaireInput = {
    create?: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput> | questionsCreateWithoutQuestionnaireInput[] | questionsUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionnaireInput | questionsCreateOrConnectWithoutQuestionnaireInput[]
    createMany?: questionsCreateManyQuestionnaireInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type levelsCreateNestedOneWithoutQuestionnaireInput = {
    create?: XOR<levelsCreateWithoutQuestionnaireInput, levelsUncheckedCreateWithoutQuestionnaireInput>
    connectOrCreate?: levelsCreateOrConnectWithoutQuestionnaireInput
    connect?: levelsWhereUniqueInput
  }

  export type questionsUncheckedCreateNestedManyWithoutQuestionnaireInput = {
    create?: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput> | questionsCreateWithoutQuestionnaireInput[] | questionsUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionnaireInput | questionsCreateOrConnectWithoutQuestionnaireInput[]
    createMany?: questionsCreateManyQuestionnaireInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type levelsUncheckedCreateNestedOneWithoutQuestionnaireInput = {
    create?: XOR<levelsCreateWithoutQuestionnaireInput, levelsUncheckedCreateWithoutQuestionnaireInput>
    connectOrCreate?: levelsCreateOrConnectWithoutQuestionnaireInput
    connect?: levelsWhereUniqueInput
  }

  export type questionsUpdateManyWithoutQuestionnaireNestedInput = {
    create?: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput> | questionsCreateWithoutQuestionnaireInput[] | questionsUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionnaireInput | questionsCreateOrConnectWithoutQuestionnaireInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestionnaireInput | questionsUpsertWithWhereUniqueWithoutQuestionnaireInput[]
    createMany?: questionsCreateManyQuestionnaireInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestionnaireInput | questionsUpdateWithWhereUniqueWithoutQuestionnaireInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestionnaireInput | questionsUpdateManyWithWhereWithoutQuestionnaireInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type levelsUpdateOneWithoutQuestionnaireNestedInput = {
    create?: XOR<levelsCreateWithoutQuestionnaireInput, levelsUncheckedCreateWithoutQuestionnaireInput>
    connectOrCreate?: levelsCreateOrConnectWithoutQuestionnaireInput
    upsert?: levelsUpsertWithoutQuestionnaireInput
    disconnect?: levelsWhereInput | boolean
    delete?: levelsWhereInput | boolean
    connect?: levelsWhereUniqueInput
    update?: XOR<XOR<levelsUpdateToOneWithWhereWithoutQuestionnaireInput, levelsUpdateWithoutQuestionnaireInput>, levelsUncheckedUpdateWithoutQuestionnaireInput>
  }

  export type questionsUncheckedUpdateManyWithoutQuestionnaireNestedInput = {
    create?: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput> | questionsCreateWithoutQuestionnaireInput[] | questionsUncheckedCreateWithoutQuestionnaireInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionnaireInput | questionsCreateOrConnectWithoutQuestionnaireInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestionnaireInput | questionsUpsertWithWhereUniqueWithoutQuestionnaireInput[]
    createMany?: questionsCreateManyQuestionnaireInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestionnaireInput | questionsUpdateWithWhereUniqueWithoutQuestionnaireInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestionnaireInput | questionsUpdateManyWithWhereWithoutQuestionnaireInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type levelsUncheckedUpdateOneWithoutQuestionnaireNestedInput = {
    create?: XOR<levelsCreateWithoutQuestionnaireInput, levelsUncheckedCreateWithoutQuestionnaireInput>
    connectOrCreate?: levelsCreateOrConnectWithoutQuestionnaireInput
    upsert?: levelsUpsertWithoutQuestionnaireInput
    disconnect?: levelsWhereInput | boolean
    delete?: levelsWhereInput | boolean
    connect?: levelsWhereUniqueInput
    update?: XOR<XOR<levelsUpdateToOneWithWhereWithoutQuestionnaireInput, levelsUpdateWithoutQuestionnaireInput>, levelsUncheckedUpdateWithoutQuestionnaireInput>
  }

  export type questionsCreateNestedManyWithoutQuestionClassInput = {
    create?: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput> | questionsCreateWithoutQuestionClassInput[] | questionsUncheckedCreateWithoutQuestionClassInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionClassInput | questionsCreateOrConnectWithoutQuestionClassInput[]
    createMany?: questionsCreateManyQuestionClassInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUncheckedCreateNestedManyWithoutQuestionClassInput = {
    create?: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput> | questionsCreateWithoutQuestionClassInput[] | questionsUncheckedCreateWithoutQuestionClassInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionClassInput | questionsCreateOrConnectWithoutQuestionClassInput[]
    createMany?: questionsCreateManyQuestionClassInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUpdateManyWithoutQuestionClassNestedInput = {
    create?: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput> | questionsCreateWithoutQuestionClassInput[] | questionsUncheckedCreateWithoutQuestionClassInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionClassInput | questionsCreateOrConnectWithoutQuestionClassInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestionClassInput | questionsUpsertWithWhereUniqueWithoutQuestionClassInput[]
    createMany?: questionsCreateManyQuestionClassInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestionClassInput | questionsUpdateWithWhereUniqueWithoutQuestionClassInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestionClassInput | questionsUpdateManyWithWhereWithoutQuestionClassInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type questionsUncheckedUpdateManyWithoutQuestionClassNestedInput = {
    create?: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput> | questionsCreateWithoutQuestionClassInput[] | questionsUncheckedCreateWithoutQuestionClassInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuestionClassInput | questionsCreateOrConnectWithoutQuestionClassInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuestionClassInput | questionsUpsertWithWhereUniqueWithoutQuestionClassInput[]
    createMany?: questionsCreateManyQuestionClassInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuestionClassInput | questionsUpdateWithWhereUniqueWithoutQuestionClassInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuestionClassInput | questionsUpdateManyWithWhereWithoutQuestionClassInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type questionsCreateoptionsInput = {
    set: InputJsonValue[]
  }

  export type question_classesCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<question_classesCreateWithoutQuestionsInput, question_classesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: question_classesCreateOrConnectWithoutQuestionsInput
    connect?: question_classesWhereUniqueInput
  }

  export type answersCreateNestedManyWithoutQuestionInput = {
    create?: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput> | answersCreateWithoutQuestionInput[] | answersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionInput | answersCreateOrConnectWithoutQuestionInput[]
    createMany?: answersCreateManyQuestionInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type brandsCreateNestedOneWithoutPitchQuestionsInput = {
    create?: XOR<brandsCreateWithoutPitchQuestionsInput, brandsUncheckedCreateWithoutPitchQuestionsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPitchQuestionsInput
    connect?: brandsWhereUniqueInput
  }

  export type questionnairesCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<questionnairesCreateWithoutQuestionsInput, questionnairesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: questionnairesCreateOrConnectWithoutQuestionsInput
    connect?: questionnairesWhereUniqueInput
  }

  export type answersUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput> | answersCreateWithoutQuestionInput[] | answersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionInput | answersCreateOrConnectWithoutQuestionInput[]
    createMany?: answersCreateManyQuestionInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type questionsUpdateoptionsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type question_classesUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<question_classesCreateWithoutQuestionsInput, question_classesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: question_classesCreateOrConnectWithoutQuestionsInput
    upsert?: question_classesUpsertWithoutQuestionsInput
    disconnect?: boolean
    delete?: question_classesWhereInput | boolean
    connect?: question_classesWhereUniqueInput
    update?: XOR<XOR<question_classesUpdateToOneWithWhereWithoutQuestionsInput, question_classesUpdateWithoutQuestionsInput>, question_classesUncheckedUpdateWithoutQuestionsInput>
  }

  export type answersUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput> | answersCreateWithoutQuestionInput[] | answersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionInput | answersCreateOrConnectWithoutQuestionInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutQuestionInput | answersUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: answersCreateManyQuestionInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutQuestionInput | answersUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: answersUpdateManyWithWhereWithoutQuestionInput | answersUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type brandsUpdateOneWithoutPitchQuestionsNestedInput = {
    create?: XOR<brandsCreateWithoutPitchQuestionsInput, brandsUncheckedCreateWithoutPitchQuestionsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutPitchQuestionsInput
    upsert?: brandsUpsertWithoutPitchQuestionsInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutPitchQuestionsInput, brandsUpdateWithoutPitchQuestionsInput>, brandsUncheckedUpdateWithoutPitchQuestionsInput>
  }

  export type questionnairesUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<questionnairesCreateWithoutQuestionsInput, questionnairesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: questionnairesCreateOrConnectWithoutQuestionsInput
    upsert?: questionnairesUpsertWithoutQuestionsInput
    disconnect?: boolean
    delete?: questionnairesWhereInput | boolean
    connect?: questionnairesWhereUniqueInput
    update?: XOR<XOR<questionnairesUpdateToOneWithWhereWithoutQuestionsInput, questionnairesUpdateWithoutQuestionsInput>, questionnairesUncheckedUpdateWithoutQuestionsInput>
  }

  export type answersUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput> | answersCreateWithoutQuestionInput[] | answersUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionInput | answersCreateOrConnectWithoutQuestionInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutQuestionInput | answersUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: answersCreateManyQuestionInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutQuestionInput | answersUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: answersUpdateManyWithWhereWithoutQuestionInput | answersUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutRatingsInput = {
    create?: XOR<usersCreateWithoutRatingsInput, usersUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRatingsInput
    connect?: usersWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutRatingsInput = {
    create?: XOR<productsCreateWithoutRatingsInput, productsUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: productsCreateOrConnectWithoutRatingsInput
    connect?: productsWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutRatingsInput = {
    create?: XOR<brandsCreateWithoutRatingsInput, brandsUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutRatingsInput
    connect?: brandsWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<usersCreateWithoutRatingsInput, usersUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRatingsInput
    upsert?: usersUpsertWithoutRatingsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRatingsInput, usersUpdateWithoutRatingsInput>, usersUncheckedUpdateWithoutRatingsInput>
  }

  export type productsUpdateOneWithoutRatingsNestedInput = {
    create?: XOR<productsCreateWithoutRatingsInput, productsUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: productsCreateOrConnectWithoutRatingsInput
    upsert?: productsUpsertWithoutRatingsInput
    disconnect?: boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutRatingsInput, productsUpdateWithoutRatingsInput>, productsUncheckedUpdateWithoutRatingsInput>
  }

  export type brandsUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<brandsCreateWithoutRatingsInput, brandsUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutRatingsInput
    upsert?: brandsUpsertWithoutRatingsInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutRatingsInput, brandsUpdateWithoutRatingsInput>, brandsUncheckedUpdateWithoutRatingsInput>
  }

  export type usersCreateNestedOneWithoutSettingsInput = {
    create?: XOR<usersCreateWithoutSettingsInput, usersUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSettingsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<usersCreateWithoutSettingsInput, usersUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSettingsInput
    upsert?: usersUpsertWithoutSettingsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSettingsInput, usersUpdateWithoutSettingsInput>, usersUncheckedUpdateWithoutSettingsInput>
  }

  export type usersCreateNestedOneWithoutTermsAndConditionsInput = {
    create?: XOR<usersCreateWithoutTermsAndConditionsInput, usersUncheckedCreateWithoutTermsAndConditionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTermsAndConditionsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutTermsAndConditionsNestedInput = {
    create?: XOR<usersCreateWithoutTermsAndConditionsInput, usersUncheckedCreateWithoutTermsAndConditionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTermsAndConditionsInput
    upsert?: usersUpsertWithoutTermsAndConditionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTermsAndConditionsInput, usersUpdateWithoutTermsAndConditionsInput>, usersUncheckedUpdateWithoutTermsAndConditionsInput>
  }

  export type usersCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<usersCreateWithoutFeedbacksInput, usersUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: usersCreateOrConnectWithoutFeedbacksInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<usersCreateWithoutFeedbacksInput, usersUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: usersCreateOrConnectWithoutFeedbacksInput
    upsert?: usersUpsertWithoutFeedbacksInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFeedbacksInput, usersUpdateWithoutFeedbacksInput>, usersUncheckedUpdateWithoutFeedbacksInput>
  }

  export type questionnairesCreateNestedOneWithoutLevelInput = {
    create?: XOR<questionnairesCreateWithoutLevelInput, questionnairesUncheckedCreateWithoutLevelInput>
    connectOrCreate?: questionnairesCreateOrConnectWithoutLevelInput
    connect?: questionnairesWhereUniqueInput
  }

  export type benefitsCreateNestedManyWithoutLevelInput = {
    create?: XOR<benefitsCreateWithoutLevelInput, benefitsUncheckedCreateWithoutLevelInput> | benefitsCreateWithoutLevelInput[] | benefitsUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: benefitsCreateOrConnectWithoutLevelInput | benefitsCreateOrConnectWithoutLevelInput[]
    createMany?: benefitsCreateManyLevelInputEnvelope
    connect?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutLevelInput = {
    create?: XOR<usersCreateWithoutLevelInput, usersUncheckedCreateWithoutLevelInput> | usersCreateWithoutLevelInput[] | usersUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLevelInput | usersCreateOrConnectWithoutLevelInput[]
    createMany?: usersCreateManyLevelInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type benefitsUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<benefitsCreateWithoutLevelInput, benefitsUncheckedCreateWithoutLevelInput> | benefitsCreateWithoutLevelInput[] | benefitsUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: benefitsCreateOrConnectWithoutLevelInput | benefitsCreateOrConnectWithoutLevelInput[]
    createMany?: benefitsCreateManyLevelInputEnvelope
    connect?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<usersCreateWithoutLevelInput, usersUncheckedCreateWithoutLevelInput> | usersCreateWithoutLevelInput[] | usersUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLevelInput | usersCreateOrConnectWithoutLevelInput[]
    createMany?: usersCreateManyLevelInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type questionnairesUpdateOneWithoutLevelNestedInput = {
    create?: XOR<questionnairesCreateWithoutLevelInput, questionnairesUncheckedCreateWithoutLevelInput>
    connectOrCreate?: questionnairesCreateOrConnectWithoutLevelInput
    upsert?: questionnairesUpsertWithoutLevelInput
    disconnect?: boolean
    delete?: questionnairesWhereInput | boolean
    connect?: questionnairesWhereUniqueInput
    update?: XOR<XOR<questionnairesUpdateToOneWithWhereWithoutLevelInput, questionnairesUpdateWithoutLevelInput>, questionnairesUncheckedUpdateWithoutLevelInput>
  }

  export type benefitsUpdateManyWithoutLevelNestedInput = {
    create?: XOR<benefitsCreateWithoutLevelInput, benefitsUncheckedCreateWithoutLevelInput> | benefitsCreateWithoutLevelInput[] | benefitsUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: benefitsCreateOrConnectWithoutLevelInput | benefitsCreateOrConnectWithoutLevelInput[]
    upsert?: benefitsUpsertWithWhereUniqueWithoutLevelInput | benefitsUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: benefitsCreateManyLevelInputEnvelope
    set?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
    disconnect?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
    delete?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
    connect?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
    update?: benefitsUpdateWithWhereUniqueWithoutLevelInput | benefitsUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: benefitsUpdateManyWithWhereWithoutLevelInput | benefitsUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: benefitsScalarWhereInput | benefitsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutLevelNestedInput = {
    create?: XOR<usersCreateWithoutLevelInput, usersUncheckedCreateWithoutLevelInput> | usersCreateWithoutLevelInput[] | usersUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLevelInput | usersCreateOrConnectWithoutLevelInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutLevelInput | usersUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: usersCreateManyLevelInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutLevelInput | usersUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: usersUpdateManyWithWhereWithoutLevelInput | usersUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type benefitsUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<benefitsCreateWithoutLevelInput, benefitsUncheckedCreateWithoutLevelInput> | benefitsCreateWithoutLevelInput[] | benefitsUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: benefitsCreateOrConnectWithoutLevelInput | benefitsCreateOrConnectWithoutLevelInput[]
    upsert?: benefitsUpsertWithWhereUniqueWithoutLevelInput | benefitsUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: benefitsCreateManyLevelInputEnvelope
    set?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
    disconnect?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
    delete?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
    connect?: benefitsWhereUniqueInput | benefitsWhereUniqueInput[]
    update?: benefitsUpdateWithWhereUniqueWithoutLevelInput | benefitsUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: benefitsUpdateManyWithWhereWithoutLevelInput | benefitsUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: benefitsScalarWhereInput | benefitsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<usersCreateWithoutLevelInput, usersUncheckedCreateWithoutLevelInput> | usersCreateWithoutLevelInput[] | usersUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: usersCreateOrConnectWithoutLevelInput | usersCreateOrConnectWithoutLevelInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutLevelInput | usersUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: usersCreateManyLevelInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutLevelInput | usersUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: usersUpdateManyWithWhereWithoutLevelInput | usersUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreatemyFavouritesInput = {
    set: InputJsonValue[]
  }

  export type usersCreateviewedPitchesInput = {
    set: string[]
  }

  export type usersCreatedeletedBrandsInput = {
    set: string[]
  }

  export type answersCreateNestedManyWithoutUserInput = {
    create?: XOR<answersCreateWithoutUserInput, answersUncheckedCreateWithoutUserInput> | answersCreateWithoutUserInput[] | answersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: answersCreateOrConnectWithoutUserInput | answersCreateOrConnectWithoutUserInput[]
    createMany?: answersCreateManyUserInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type pitch_viewsCreateNestedManyWithoutUserInput = {
    create?: XOR<pitch_viewsCreateWithoutUserInput, pitch_viewsUncheckedCreateWithoutUserInput> | pitch_viewsCreateWithoutUserInput[] | pitch_viewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pitch_viewsCreateOrConnectWithoutUserInput | pitch_viewsCreateOrConnectWithoutUserInput[]
    createMany?: pitch_viewsCreateManyUserInputEnvelope
    connect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
  }

  export type settingsCreateNestedOneWithoutUserInput = {
    create?: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: settingsCreateOrConnectWithoutUserInput
    connect?: settingsWhereUniqueInput
  }

  export type ratingsCreateNestedManyWithoutUserInput = {
    create?: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput> | ratingsCreateWithoutUserInput[] | ratingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutUserInput | ratingsCreateOrConnectWithoutUserInput[]
    createMany?: ratingsCreateManyUserInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type brandsCreateNestedManyWithoutUsersForYouInput = {
    create?: XOR<brandsCreateWithoutUsersForYouInput, brandsUncheckedCreateWithoutUsersForYouInput> | brandsCreateWithoutUsersForYouInput[] | brandsUncheckedCreateWithoutUsersForYouInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersForYouInput | brandsCreateOrConnectWithoutUsersForYouInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type brandsCreateNestedManyWithoutUsersForYouPoolInput = {
    create?: XOR<brandsCreateWithoutUsersForYouPoolInput, brandsUncheckedCreateWithoutUsersForYouPoolInput> | brandsCreateWithoutUsersForYouPoolInput[] | brandsUncheckedCreateWithoutUsersForYouPoolInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersForYouPoolInput | brandsCreateOrConnectWithoutUsersForYouPoolInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput = {
    create?: XOR<brandsCreateWithoutUsersNotInterestedBrandsInput, brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput> | brandsCreateWithoutUsersNotInterestedBrandsInput[] | brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput | brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type link_visitsCreateNestedManyWithoutUserInput = {
    create?: XOR<link_visitsCreateWithoutUserInput, link_visitsUncheckedCreateWithoutUserInput> | link_visitsCreateWithoutUserInput[] | link_visitsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutUserInput | link_visitsCreateOrConnectWithoutUserInput[]
    createMany?: link_visitsCreateManyUserInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type brand_screen_timesCreateNestedManyWithoutUserInput = {
    create?: XOR<brand_screen_timesCreateWithoutUserInput, brand_screen_timesUncheckedCreateWithoutUserInput> | brand_screen_timesCreateWithoutUserInput[] | brand_screen_timesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: brand_screen_timesCreateOrConnectWithoutUserInput | brand_screen_timesCreateOrConnectWithoutUserInput[]
    createMany?: brand_screen_timesCreateManyUserInputEnvelope
    connect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
  }

  export type terms_and_conditionsCreateNestedOneWithoutUserInput = {
    create?: XOR<terms_and_conditionsCreateWithoutUserInput, terms_and_conditionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: terms_and_conditionsCreateOrConnectWithoutUserInput
    connect?: terms_and_conditionsWhereUniqueInput
  }

  export type feedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput> | feedbackCreateWithoutUserInput[] | feedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: feedbackCreateOrConnectWithoutUserInput | feedbackCreateOrConnectWithoutUserInput[]
    createMany?: feedbackCreateManyUserInputEnvelope
    connect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
  }

  export type levelsCreateNestedOneWithoutUsersInput = {
    create?: XOR<levelsCreateWithoutUsersInput, levelsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: levelsCreateOrConnectWithoutUsersInput
    connect?: levelsWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutOwnerInput = {
    create?: XOR<brandsCreateWithoutOwnerInput, brandsUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: brandsCreateOrConnectWithoutOwnerInput
    connect?: brandsWhereUniqueInput
  }

  export type production_submissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput> | production_submissionsCreateWithoutUserInput[] | production_submissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutUserInput | production_submissionsCreateOrConnectWithoutUserInput[]
    createMany?: production_submissionsCreateManyUserInputEnvelope
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
  }

  export type foundersReachedLeaderboardCreateNestedOneWithoutUsersInput = {
    create?: XOR<foundersReachedLeaderboardCreateWithoutUsersInput, foundersReachedLeaderboardUncheckedCreateWithoutUsersInput>
    connectOrCreate?: foundersReachedLeaderboardCreateOrConnectWithoutUsersInput
    connect?: foundersReachedLeaderboardWhereUniqueInput
  }

  export type deal_codesCreateNestedManyWithoutUserInput = {
    create?: XOR<deal_codesCreateWithoutUserInput, deal_codesUncheckedCreateWithoutUserInput> | deal_codesCreateWithoutUserInput[] | deal_codesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: deal_codesCreateOrConnectWithoutUserInput | deal_codesCreateOrConnectWithoutUserInput[]
    createMany?: deal_codesCreateManyUserInputEnvelope
    connect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
  }

  export type unlocked_brands_historyCreateNestedManyWithoutUserInput = {
    create?: XOR<unlocked_brands_historyCreateWithoutUserInput, unlocked_brands_historyUncheckedCreateWithoutUserInput> | unlocked_brands_historyCreateWithoutUserInput[] | unlocked_brands_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: unlocked_brands_historyCreateOrConnectWithoutUserInput | unlocked_brands_historyCreateOrConnectWithoutUserInput[]
    createMany?: unlocked_brands_historyCreateManyUserInputEnvelope
    connect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
  }

  export type category_choicesCreateNestedManyWithoutUserInput = {
    create?: XOR<category_choicesCreateWithoutUserInput, category_choicesUncheckedCreateWithoutUserInput> | category_choicesCreateWithoutUserInput[] | category_choicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: category_choicesCreateOrConnectWithoutUserInput | category_choicesCreateOrConnectWithoutUserInput[]
    createMany?: category_choicesCreateManyUserInputEnvelope
    connect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
  }

  export type postsCreateNestedManyWithoutUserLikesInput = {
    create?: XOR<postsCreateWithoutUserLikesInput, postsUncheckedCreateWithoutUserLikesInput> | postsCreateWithoutUserLikesInput[] | postsUncheckedCreateWithoutUserLikesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUserLikesInput | postsCreateOrConnectWithoutUserLikesInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type push_notification_historyCreateNestedManyWithoutUserInput = {
    create?: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput> | push_notification_historyCreateWithoutUserInput[] | push_notification_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: push_notification_historyCreateOrConnectWithoutUserInput | push_notification_historyCreateOrConnectWithoutUserInput[]
    createMany?: push_notification_historyCreateManyUserInputEnvelope
    connect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
  }

  export type usersCreateforYouBrandsIdsInput = {
    set: string[]
  }

  export type usersCreateforYouBrandsPoolIdsInput = {
    set: string[]
  }

  export type usersCreatenotInterestedBrandsIdsInput = {
    set: string[]
  }

  export type usersCreatelikedPostsIdsInput = {
    set: string[]
  }

  export type answersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<answersCreateWithoutUserInput, answersUncheckedCreateWithoutUserInput> | answersCreateWithoutUserInput[] | answersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: answersCreateOrConnectWithoutUserInput | answersCreateOrConnectWithoutUserInput[]
    createMany?: answersCreateManyUserInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type pitch_viewsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<pitch_viewsCreateWithoutUserInput, pitch_viewsUncheckedCreateWithoutUserInput> | pitch_viewsCreateWithoutUserInput[] | pitch_viewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pitch_viewsCreateOrConnectWithoutUserInput | pitch_viewsCreateOrConnectWithoutUserInput[]
    createMany?: pitch_viewsCreateManyUserInputEnvelope
    connect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
  }

  export type settingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: settingsCreateOrConnectWithoutUserInput
    connect?: settingsWhereUniqueInput
  }

  export type ratingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput> | ratingsCreateWithoutUserInput[] | ratingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutUserInput | ratingsCreateOrConnectWithoutUserInput[]
    createMany?: ratingsCreateManyUserInputEnvelope
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
  }

  export type brandsUncheckedCreateNestedManyWithoutUsersForYouInput = {
    create?: XOR<brandsCreateWithoutUsersForYouInput, brandsUncheckedCreateWithoutUsersForYouInput> | brandsCreateWithoutUsersForYouInput[] | brandsUncheckedCreateWithoutUsersForYouInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersForYouInput | brandsCreateOrConnectWithoutUsersForYouInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput = {
    create?: XOR<brandsCreateWithoutUsersForYouPoolInput, brandsUncheckedCreateWithoutUsersForYouPoolInput> | brandsCreateWithoutUsersForYouPoolInput[] | brandsUncheckedCreateWithoutUsersForYouPoolInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersForYouPoolInput | brandsCreateOrConnectWithoutUsersForYouPoolInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput = {
    create?: XOR<brandsCreateWithoutUsersNotInterestedBrandsInput, brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput> | brandsCreateWithoutUsersNotInterestedBrandsInput[] | brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput | brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
  }

  export type link_visitsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<link_visitsCreateWithoutUserInput, link_visitsUncheckedCreateWithoutUserInput> | link_visitsCreateWithoutUserInput[] | link_visitsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutUserInput | link_visitsCreateOrConnectWithoutUserInput[]
    createMany?: link_visitsCreateManyUserInputEnvelope
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
  }

  export type brand_screen_timesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<brand_screen_timesCreateWithoutUserInput, brand_screen_timesUncheckedCreateWithoutUserInput> | brand_screen_timesCreateWithoutUserInput[] | brand_screen_timesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: brand_screen_timesCreateOrConnectWithoutUserInput | brand_screen_timesCreateOrConnectWithoutUserInput[]
    createMany?: brand_screen_timesCreateManyUserInputEnvelope
    connect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
  }

  export type terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<terms_and_conditionsCreateWithoutUserInput, terms_and_conditionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: terms_and_conditionsCreateOrConnectWithoutUserInput
    connect?: terms_and_conditionsWhereUniqueInput
  }

  export type feedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput> | feedbackCreateWithoutUserInput[] | feedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: feedbackCreateOrConnectWithoutUserInput | feedbackCreateOrConnectWithoutUserInput[]
    createMany?: feedbackCreateManyUserInputEnvelope
    connect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
  }

  export type production_submissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput> | production_submissionsCreateWithoutUserInput[] | production_submissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutUserInput | production_submissionsCreateOrConnectWithoutUserInput[]
    createMany?: production_submissionsCreateManyUserInputEnvelope
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
  }

  export type deal_codesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<deal_codesCreateWithoutUserInput, deal_codesUncheckedCreateWithoutUserInput> | deal_codesCreateWithoutUserInput[] | deal_codesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: deal_codesCreateOrConnectWithoutUserInput | deal_codesCreateOrConnectWithoutUserInput[]
    createMany?: deal_codesCreateManyUserInputEnvelope
    connect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
  }

  export type unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<unlocked_brands_historyCreateWithoutUserInput, unlocked_brands_historyUncheckedCreateWithoutUserInput> | unlocked_brands_historyCreateWithoutUserInput[] | unlocked_brands_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: unlocked_brands_historyCreateOrConnectWithoutUserInput | unlocked_brands_historyCreateOrConnectWithoutUserInput[]
    createMany?: unlocked_brands_historyCreateManyUserInputEnvelope
    connect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
  }

  export type category_choicesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<category_choicesCreateWithoutUserInput, category_choicesUncheckedCreateWithoutUserInput> | category_choicesCreateWithoutUserInput[] | category_choicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: category_choicesCreateOrConnectWithoutUserInput | category_choicesCreateOrConnectWithoutUserInput[]
    createMany?: category_choicesCreateManyUserInputEnvelope
    connect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
  }

  export type postsUncheckedCreateNestedManyWithoutUserLikesInput = {
    create?: XOR<postsCreateWithoutUserLikesInput, postsUncheckedCreateWithoutUserLikesInput> | postsCreateWithoutUserLikesInput[] | postsUncheckedCreateWithoutUserLikesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUserLikesInput | postsCreateOrConnectWithoutUserLikesInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type push_notification_historyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput> | push_notification_historyCreateWithoutUserInput[] | push_notification_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: push_notification_historyCreateOrConnectWithoutUserInput | push_notification_historyCreateOrConnectWithoutUserInput[]
    createMany?: push_notification_historyCreateManyUserInputEnvelope
    connect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
  }

  export type usersUpdatemyFavouritesInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type usersUpdateviewedPitchesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdatedeletedBrandsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type answersUpdateManyWithoutUserNestedInput = {
    create?: XOR<answersCreateWithoutUserInput, answersUncheckedCreateWithoutUserInput> | answersCreateWithoutUserInput[] | answersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: answersCreateOrConnectWithoutUserInput | answersCreateOrConnectWithoutUserInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutUserInput | answersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: answersCreateManyUserInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutUserInput | answersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: answersUpdateManyWithWhereWithoutUserInput | answersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type pitch_viewsUpdateManyWithoutUserNestedInput = {
    create?: XOR<pitch_viewsCreateWithoutUserInput, pitch_viewsUncheckedCreateWithoutUserInput> | pitch_viewsCreateWithoutUserInput[] | pitch_viewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pitch_viewsCreateOrConnectWithoutUserInput | pitch_viewsCreateOrConnectWithoutUserInput[]
    upsert?: pitch_viewsUpsertWithWhereUniqueWithoutUserInput | pitch_viewsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pitch_viewsCreateManyUserInputEnvelope
    set?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    disconnect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    delete?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    connect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    update?: pitch_viewsUpdateWithWhereUniqueWithoutUserInput | pitch_viewsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pitch_viewsUpdateManyWithWhereWithoutUserInput | pitch_viewsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pitch_viewsScalarWhereInput | pitch_viewsScalarWhereInput[]
  }

  export type settingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: settingsCreateOrConnectWithoutUserInput
    upsert?: settingsUpsertWithoutUserInput
    disconnect?: settingsWhereInput | boolean
    delete?: settingsWhereInput | boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<XOR<settingsUpdateToOneWithWhereWithoutUserInput, settingsUpdateWithoutUserInput>, settingsUncheckedUpdateWithoutUserInput>
  }

  export type ratingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput> | ratingsCreateWithoutUserInput[] | ratingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutUserInput | ratingsCreateOrConnectWithoutUserInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutUserInput | ratingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ratingsCreateManyUserInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutUserInput | ratingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutUserInput | ratingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type brandsUpdateManyWithoutUsersForYouNestedInput = {
    create?: XOR<brandsCreateWithoutUsersForYouInput, brandsUncheckedCreateWithoutUsersForYouInput> | brandsCreateWithoutUsersForYouInput[] | brandsUncheckedCreateWithoutUsersForYouInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersForYouInput | brandsCreateOrConnectWithoutUsersForYouInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutUsersForYouInput | brandsUpsertWithWhereUniqueWithoutUsersForYouInput[]
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutUsersForYouInput | brandsUpdateWithWhereUniqueWithoutUsersForYouInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutUsersForYouInput | brandsUpdateManyWithWhereWithoutUsersForYouInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type brandsUpdateManyWithoutUsersForYouPoolNestedInput = {
    create?: XOR<brandsCreateWithoutUsersForYouPoolInput, brandsUncheckedCreateWithoutUsersForYouPoolInput> | brandsCreateWithoutUsersForYouPoolInput[] | brandsUncheckedCreateWithoutUsersForYouPoolInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersForYouPoolInput | brandsCreateOrConnectWithoutUsersForYouPoolInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutUsersForYouPoolInput | brandsUpsertWithWhereUniqueWithoutUsersForYouPoolInput[]
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutUsersForYouPoolInput | brandsUpdateWithWhereUniqueWithoutUsersForYouPoolInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutUsersForYouPoolInput | brandsUpdateManyWithWhereWithoutUsersForYouPoolInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput = {
    create?: XOR<brandsCreateWithoutUsersNotInterestedBrandsInput, brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput> | brandsCreateWithoutUsersNotInterestedBrandsInput[] | brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput | brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutUsersNotInterestedBrandsInput | brandsUpsertWithWhereUniqueWithoutUsersNotInterestedBrandsInput[]
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutUsersNotInterestedBrandsInput | brandsUpdateWithWhereUniqueWithoutUsersNotInterestedBrandsInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutUsersNotInterestedBrandsInput | brandsUpdateManyWithWhereWithoutUsersNotInterestedBrandsInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type link_visitsUpdateManyWithoutUserNestedInput = {
    create?: XOR<link_visitsCreateWithoutUserInput, link_visitsUncheckedCreateWithoutUserInput> | link_visitsCreateWithoutUserInput[] | link_visitsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutUserInput | link_visitsCreateOrConnectWithoutUserInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutUserInput | link_visitsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: link_visitsCreateManyUserInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutUserInput | link_visitsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutUserInput | link_visitsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type brand_screen_timesUpdateManyWithoutUserNestedInput = {
    create?: XOR<brand_screen_timesCreateWithoutUserInput, brand_screen_timesUncheckedCreateWithoutUserInput> | brand_screen_timesCreateWithoutUserInput[] | brand_screen_timesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: brand_screen_timesCreateOrConnectWithoutUserInput | brand_screen_timesCreateOrConnectWithoutUserInput[]
    upsert?: brand_screen_timesUpsertWithWhereUniqueWithoutUserInput | brand_screen_timesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: brand_screen_timesCreateManyUserInputEnvelope
    set?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    disconnect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    delete?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    connect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    update?: brand_screen_timesUpdateWithWhereUniqueWithoutUserInput | brand_screen_timesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: brand_screen_timesUpdateManyWithWhereWithoutUserInput | brand_screen_timesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: brand_screen_timesScalarWhereInput | brand_screen_timesScalarWhereInput[]
  }

  export type terms_and_conditionsUpdateOneWithoutUserNestedInput = {
    create?: XOR<terms_and_conditionsCreateWithoutUserInput, terms_and_conditionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: terms_and_conditionsCreateOrConnectWithoutUserInput
    upsert?: terms_and_conditionsUpsertWithoutUserInput
    disconnect?: terms_and_conditionsWhereInput | boolean
    delete?: terms_and_conditionsWhereInput | boolean
    connect?: terms_and_conditionsWhereUniqueInput
    update?: XOR<XOR<terms_and_conditionsUpdateToOneWithWhereWithoutUserInput, terms_and_conditionsUpdateWithoutUserInput>, terms_and_conditionsUncheckedUpdateWithoutUserInput>
  }

  export type feedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput> | feedbackCreateWithoutUserInput[] | feedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: feedbackCreateOrConnectWithoutUserInput | feedbackCreateOrConnectWithoutUserInput[]
    upsert?: feedbackUpsertWithWhereUniqueWithoutUserInput | feedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: feedbackCreateManyUserInputEnvelope
    set?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    disconnect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    delete?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    connect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    update?: feedbackUpdateWithWhereUniqueWithoutUserInput | feedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: feedbackUpdateManyWithWhereWithoutUserInput | feedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: feedbackScalarWhereInput | feedbackScalarWhereInput[]
  }

  export type levelsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<levelsCreateWithoutUsersInput, levelsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: levelsCreateOrConnectWithoutUsersInput
    upsert?: levelsUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: levelsWhereInput | boolean
    connect?: levelsWhereUniqueInput
    update?: XOR<XOR<levelsUpdateToOneWithWhereWithoutUsersInput, levelsUpdateWithoutUsersInput>, levelsUncheckedUpdateWithoutUsersInput>
  }

  export type brandsUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<brandsCreateWithoutOwnerInput, brandsUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: brandsCreateOrConnectWithoutOwnerInput
    upsert?: brandsUpsertWithoutOwnerInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutOwnerInput, brandsUpdateWithoutOwnerInput>, brandsUncheckedUpdateWithoutOwnerInput>
  }

  export type production_submissionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput> | production_submissionsCreateWithoutUserInput[] | production_submissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutUserInput | production_submissionsCreateOrConnectWithoutUserInput[]
    upsert?: production_submissionsUpsertWithWhereUniqueWithoutUserInput | production_submissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: production_submissionsCreateManyUserInputEnvelope
    set?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    disconnect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    delete?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    update?: production_submissionsUpdateWithWhereUniqueWithoutUserInput | production_submissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: production_submissionsUpdateManyWithWhereWithoutUserInput | production_submissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
  }

  export type foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput = {
    create?: XOR<foundersReachedLeaderboardCreateWithoutUsersInput, foundersReachedLeaderboardUncheckedCreateWithoutUsersInput>
    connectOrCreate?: foundersReachedLeaderboardCreateOrConnectWithoutUsersInput
    upsert?: foundersReachedLeaderboardUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: foundersReachedLeaderboardWhereInput | boolean
    connect?: foundersReachedLeaderboardWhereUniqueInput
    update?: XOR<XOR<foundersReachedLeaderboardUpdateToOneWithWhereWithoutUsersInput, foundersReachedLeaderboardUpdateWithoutUsersInput>, foundersReachedLeaderboardUncheckedUpdateWithoutUsersInput>
  }

  export type deal_codesUpdateManyWithoutUserNestedInput = {
    create?: XOR<deal_codesCreateWithoutUserInput, deal_codesUncheckedCreateWithoutUserInput> | deal_codesCreateWithoutUserInput[] | deal_codesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: deal_codesCreateOrConnectWithoutUserInput | deal_codesCreateOrConnectWithoutUserInput[]
    upsert?: deal_codesUpsertWithWhereUniqueWithoutUserInput | deal_codesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: deal_codesCreateManyUserInputEnvelope
    set?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    disconnect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    delete?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    connect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    update?: deal_codesUpdateWithWhereUniqueWithoutUserInput | deal_codesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: deal_codesUpdateManyWithWhereWithoutUserInput | deal_codesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: deal_codesScalarWhereInput | deal_codesScalarWhereInput[]
  }

  export type unlocked_brands_historyUpdateManyWithoutUserNestedInput = {
    create?: XOR<unlocked_brands_historyCreateWithoutUserInput, unlocked_brands_historyUncheckedCreateWithoutUserInput> | unlocked_brands_historyCreateWithoutUserInput[] | unlocked_brands_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: unlocked_brands_historyCreateOrConnectWithoutUserInput | unlocked_brands_historyCreateOrConnectWithoutUserInput[]
    upsert?: unlocked_brands_historyUpsertWithWhereUniqueWithoutUserInput | unlocked_brands_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: unlocked_brands_historyCreateManyUserInputEnvelope
    set?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    disconnect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    delete?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    connect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    update?: unlocked_brands_historyUpdateWithWhereUniqueWithoutUserInput | unlocked_brands_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: unlocked_brands_historyUpdateManyWithWhereWithoutUserInput | unlocked_brands_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: unlocked_brands_historyScalarWhereInput | unlocked_brands_historyScalarWhereInput[]
  }

  export type category_choicesUpdateManyWithoutUserNestedInput = {
    create?: XOR<category_choicesCreateWithoutUserInput, category_choicesUncheckedCreateWithoutUserInput> | category_choicesCreateWithoutUserInput[] | category_choicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: category_choicesCreateOrConnectWithoutUserInput | category_choicesCreateOrConnectWithoutUserInput[]
    upsert?: category_choicesUpsertWithWhereUniqueWithoutUserInput | category_choicesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: category_choicesCreateManyUserInputEnvelope
    set?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    disconnect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    delete?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    connect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    update?: category_choicesUpdateWithWhereUniqueWithoutUserInput | category_choicesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: category_choicesUpdateManyWithWhereWithoutUserInput | category_choicesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: category_choicesScalarWhereInput | category_choicesScalarWhereInput[]
  }

  export type postsUpdateManyWithoutUserLikesNestedInput = {
    create?: XOR<postsCreateWithoutUserLikesInput, postsUncheckedCreateWithoutUserLikesInput> | postsCreateWithoutUserLikesInput[] | postsUncheckedCreateWithoutUserLikesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUserLikesInput | postsCreateOrConnectWithoutUserLikesInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutUserLikesInput | postsUpsertWithWhereUniqueWithoutUserLikesInput[]
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutUserLikesInput | postsUpdateWithWhereUniqueWithoutUserLikesInput[]
    updateMany?: postsUpdateManyWithWhereWithoutUserLikesInput | postsUpdateManyWithWhereWithoutUserLikesInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type push_notification_historyUpdateManyWithoutUserNestedInput = {
    create?: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput> | push_notification_historyCreateWithoutUserInput[] | push_notification_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: push_notification_historyCreateOrConnectWithoutUserInput | push_notification_historyCreateOrConnectWithoutUserInput[]
    upsert?: push_notification_historyUpsertWithWhereUniqueWithoutUserInput | push_notification_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: push_notification_historyCreateManyUserInputEnvelope
    set?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    disconnect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    delete?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    connect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    update?: push_notification_historyUpdateWithWhereUniqueWithoutUserInput | push_notification_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: push_notification_historyUpdateManyWithWhereWithoutUserInput | push_notification_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: push_notification_historyScalarWhereInput | push_notification_historyScalarWhereInput[]
  }

  export type usersUpdateforYouBrandsIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdateforYouBrandsPoolIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdatenotInterestedBrandsIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdatelikedPostsIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type answersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<answersCreateWithoutUserInput, answersUncheckedCreateWithoutUserInput> | answersCreateWithoutUserInput[] | answersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: answersCreateOrConnectWithoutUserInput | answersCreateOrConnectWithoutUserInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutUserInput | answersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: answersCreateManyUserInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutUserInput | answersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: answersUpdateManyWithWhereWithoutUserInput | answersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type pitch_viewsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<pitch_viewsCreateWithoutUserInput, pitch_viewsUncheckedCreateWithoutUserInput> | pitch_viewsCreateWithoutUserInput[] | pitch_viewsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pitch_viewsCreateOrConnectWithoutUserInput | pitch_viewsCreateOrConnectWithoutUserInput[]
    upsert?: pitch_viewsUpsertWithWhereUniqueWithoutUserInput | pitch_viewsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pitch_viewsCreateManyUserInputEnvelope
    set?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    disconnect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    delete?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    connect?: pitch_viewsWhereUniqueInput | pitch_viewsWhereUniqueInput[]
    update?: pitch_viewsUpdateWithWhereUniqueWithoutUserInput | pitch_viewsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pitch_viewsUpdateManyWithWhereWithoutUserInput | pitch_viewsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pitch_viewsScalarWhereInput | pitch_viewsScalarWhereInput[]
  }

  export type settingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: settingsCreateOrConnectWithoutUserInput
    upsert?: settingsUpsertWithoutUserInput
    disconnect?: settingsWhereInput | boolean
    delete?: settingsWhereInput | boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<XOR<settingsUpdateToOneWithWhereWithoutUserInput, settingsUpdateWithoutUserInput>, settingsUncheckedUpdateWithoutUserInput>
  }

  export type ratingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput> | ratingsCreateWithoutUserInput[] | ratingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ratingsCreateOrConnectWithoutUserInput | ratingsCreateOrConnectWithoutUserInput[]
    upsert?: ratingsUpsertWithWhereUniqueWithoutUserInput | ratingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ratingsCreateManyUserInputEnvelope
    set?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    disconnect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    delete?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    connect?: ratingsWhereUniqueInput | ratingsWhereUniqueInput[]
    update?: ratingsUpdateWithWhereUniqueWithoutUserInput | ratingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ratingsUpdateManyWithWhereWithoutUserInput | ratingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
  }

  export type brandsUncheckedUpdateManyWithoutUsersForYouNestedInput = {
    create?: XOR<brandsCreateWithoutUsersForYouInput, brandsUncheckedCreateWithoutUsersForYouInput> | brandsCreateWithoutUsersForYouInput[] | brandsUncheckedCreateWithoutUsersForYouInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersForYouInput | brandsCreateOrConnectWithoutUsersForYouInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutUsersForYouInput | brandsUpsertWithWhereUniqueWithoutUsersForYouInput[]
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutUsersForYouInput | brandsUpdateWithWhereUniqueWithoutUsersForYouInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutUsersForYouInput | brandsUpdateManyWithWhereWithoutUsersForYouInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput = {
    create?: XOR<brandsCreateWithoutUsersForYouPoolInput, brandsUncheckedCreateWithoutUsersForYouPoolInput> | brandsCreateWithoutUsersForYouPoolInput[] | brandsUncheckedCreateWithoutUsersForYouPoolInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersForYouPoolInput | brandsCreateOrConnectWithoutUsersForYouPoolInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutUsersForYouPoolInput | brandsUpsertWithWhereUniqueWithoutUsersForYouPoolInput[]
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutUsersForYouPoolInput | brandsUpdateWithWhereUniqueWithoutUsersForYouPoolInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutUsersForYouPoolInput | brandsUpdateManyWithWhereWithoutUsersForYouPoolInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput = {
    create?: XOR<brandsCreateWithoutUsersNotInterestedBrandsInput, brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput> | brandsCreateWithoutUsersNotInterestedBrandsInput[] | brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput[]
    connectOrCreate?: brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput | brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput[]
    upsert?: brandsUpsertWithWhereUniqueWithoutUsersNotInterestedBrandsInput | brandsUpsertWithWhereUniqueWithoutUsersNotInterestedBrandsInput[]
    set?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    disconnect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    delete?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    connect?: brandsWhereUniqueInput | brandsWhereUniqueInput[]
    update?: brandsUpdateWithWhereUniqueWithoutUsersNotInterestedBrandsInput | brandsUpdateWithWhereUniqueWithoutUsersNotInterestedBrandsInput[]
    updateMany?: brandsUpdateManyWithWhereWithoutUsersNotInterestedBrandsInput | brandsUpdateManyWithWhereWithoutUsersNotInterestedBrandsInput[]
    deleteMany?: brandsScalarWhereInput | brandsScalarWhereInput[]
  }

  export type link_visitsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<link_visitsCreateWithoutUserInput, link_visitsUncheckedCreateWithoutUserInput> | link_visitsCreateWithoutUserInput[] | link_visitsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: link_visitsCreateOrConnectWithoutUserInput | link_visitsCreateOrConnectWithoutUserInput[]
    upsert?: link_visitsUpsertWithWhereUniqueWithoutUserInput | link_visitsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: link_visitsCreateManyUserInputEnvelope
    set?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    disconnect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    delete?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    connect?: link_visitsWhereUniqueInput | link_visitsWhereUniqueInput[]
    update?: link_visitsUpdateWithWhereUniqueWithoutUserInput | link_visitsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: link_visitsUpdateManyWithWhereWithoutUserInput | link_visitsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
  }

  export type brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<brand_screen_timesCreateWithoutUserInput, brand_screen_timesUncheckedCreateWithoutUserInput> | brand_screen_timesCreateWithoutUserInput[] | brand_screen_timesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: brand_screen_timesCreateOrConnectWithoutUserInput | brand_screen_timesCreateOrConnectWithoutUserInput[]
    upsert?: brand_screen_timesUpsertWithWhereUniqueWithoutUserInput | brand_screen_timesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: brand_screen_timesCreateManyUserInputEnvelope
    set?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    disconnect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    delete?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    connect?: brand_screen_timesWhereUniqueInput | brand_screen_timesWhereUniqueInput[]
    update?: brand_screen_timesUpdateWithWhereUniqueWithoutUserInput | brand_screen_timesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: brand_screen_timesUpdateManyWithWhereWithoutUserInput | brand_screen_timesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: brand_screen_timesScalarWhereInput | brand_screen_timesScalarWhereInput[]
  }

  export type terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<terms_and_conditionsCreateWithoutUserInput, terms_and_conditionsUncheckedCreateWithoutUserInput>
    connectOrCreate?: terms_and_conditionsCreateOrConnectWithoutUserInput
    upsert?: terms_and_conditionsUpsertWithoutUserInput
    disconnect?: terms_and_conditionsWhereInput | boolean
    delete?: terms_and_conditionsWhereInput | boolean
    connect?: terms_and_conditionsWhereUniqueInput
    update?: XOR<XOR<terms_and_conditionsUpdateToOneWithWhereWithoutUserInput, terms_and_conditionsUpdateWithoutUserInput>, terms_and_conditionsUncheckedUpdateWithoutUserInput>
  }

  export type feedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput> | feedbackCreateWithoutUserInput[] | feedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: feedbackCreateOrConnectWithoutUserInput | feedbackCreateOrConnectWithoutUserInput[]
    upsert?: feedbackUpsertWithWhereUniqueWithoutUserInput | feedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: feedbackCreateManyUserInputEnvelope
    set?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    disconnect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    delete?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    connect?: feedbackWhereUniqueInput | feedbackWhereUniqueInput[]
    update?: feedbackUpdateWithWhereUniqueWithoutUserInput | feedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: feedbackUpdateManyWithWhereWithoutUserInput | feedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: feedbackScalarWhereInput | feedbackScalarWhereInput[]
  }

  export type production_submissionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput> | production_submissionsCreateWithoutUserInput[] | production_submissionsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: production_submissionsCreateOrConnectWithoutUserInput | production_submissionsCreateOrConnectWithoutUserInput[]
    upsert?: production_submissionsUpsertWithWhereUniqueWithoutUserInput | production_submissionsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: production_submissionsCreateManyUserInputEnvelope
    set?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    disconnect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    delete?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    connect?: production_submissionsWhereUniqueInput | production_submissionsWhereUniqueInput[]
    update?: production_submissionsUpdateWithWhereUniqueWithoutUserInput | production_submissionsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: production_submissionsUpdateManyWithWhereWithoutUserInput | production_submissionsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
  }

  export type deal_codesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<deal_codesCreateWithoutUserInput, deal_codesUncheckedCreateWithoutUserInput> | deal_codesCreateWithoutUserInput[] | deal_codesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: deal_codesCreateOrConnectWithoutUserInput | deal_codesCreateOrConnectWithoutUserInput[]
    upsert?: deal_codesUpsertWithWhereUniqueWithoutUserInput | deal_codesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: deal_codesCreateManyUserInputEnvelope
    set?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    disconnect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    delete?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    connect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    update?: deal_codesUpdateWithWhereUniqueWithoutUserInput | deal_codesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: deal_codesUpdateManyWithWhereWithoutUserInput | deal_codesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: deal_codesScalarWhereInput | deal_codesScalarWhereInput[]
  }

  export type unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<unlocked_brands_historyCreateWithoutUserInput, unlocked_brands_historyUncheckedCreateWithoutUserInput> | unlocked_brands_historyCreateWithoutUserInput[] | unlocked_brands_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: unlocked_brands_historyCreateOrConnectWithoutUserInput | unlocked_brands_historyCreateOrConnectWithoutUserInput[]
    upsert?: unlocked_brands_historyUpsertWithWhereUniqueWithoutUserInput | unlocked_brands_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: unlocked_brands_historyCreateManyUserInputEnvelope
    set?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    disconnect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    delete?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    connect?: unlocked_brands_historyWhereUniqueInput | unlocked_brands_historyWhereUniqueInput[]
    update?: unlocked_brands_historyUpdateWithWhereUniqueWithoutUserInput | unlocked_brands_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: unlocked_brands_historyUpdateManyWithWhereWithoutUserInput | unlocked_brands_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: unlocked_brands_historyScalarWhereInput | unlocked_brands_historyScalarWhereInput[]
  }

  export type category_choicesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<category_choicesCreateWithoutUserInput, category_choicesUncheckedCreateWithoutUserInput> | category_choicesCreateWithoutUserInput[] | category_choicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: category_choicesCreateOrConnectWithoutUserInput | category_choicesCreateOrConnectWithoutUserInput[]
    upsert?: category_choicesUpsertWithWhereUniqueWithoutUserInput | category_choicesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: category_choicesCreateManyUserInputEnvelope
    set?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    disconnect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    delete?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    connect?: category_choicesWhereUniqueInput | category_choicesWhereUniqueInput[]
    update?: category_choicesUpdateWithWhereUniqueWithoutUserInput | category_choicesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: category_choicesUpdateManyWithWhereWithoutUserInput | category_choicesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: category_choicesScalarWhereInput | category_choicesScalarWhereInput[]
  }

  export type postsUncheckedUpdateManyWithoutUserLikesNestedInput = {
    create?: XOR<postsCreateWithoutUserLikesInput, postsUncheckedCreateWithoutUserLikesInput> | postsCreateWithoutUserLikesInput[] | postsUncheckedCreateWithoutUserLikesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUserLikesInput | postsCreateOrConnectWithoutUserLikesInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutUserLikesInput | postsUpsertWithWhereUniqueWithoutUserLikesInput[]
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutUserLikesInput | postsUpdateWithWhereUniqueWithoutUserLikesInput[]
    updateMany?: postsUpdateManyWithWhereWithoutUserLikesInput | postsUpdateManyWithWhereWithoutUserLikesInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type push_notification_historyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput> | push_notification_historyCreateWithoutUserInput[] | push_notification_historyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: push_notification_historyCreateOrConnectWithoutUserInput | push_notification_historyCreateOrConnectWithoutUserInput[]
    upsert?: push_notification_historyUpsertWithWhereUniqueWithoutUserInput | push_notification_historyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: push_notification_historyCreateManyUserInputEnvelope
    set?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    disconnect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    delete?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    connect?: push_notification_historyWhereUniqueInput | push_notification_historyWhereUniqueInput[]
    update?: push_notification_historyUpdateWithWhereUniqueWithoutUserInput | push_notification_historyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: push_notification_historyUpdateManyWithWhereWithoutUserInput | push_notification_historyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: push_notification_historyScalarWhereInput | push_notification_historyScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutDealCodesInput = {
    create?: XOR<usersCreateWithoutDealCodesInput, usersUncheckedCreateWithoutDealCodesInput>
    connectOrCreate?: usersCreateOrConnectWithoutDealCodesInput
    connect?: usersWhereUniqueInput
  }

  export type deal_code_groupsCreateNestedOneWithoutDealCodesInput = {
    create?: XOR<deal_code_groupsCreateWithoutDealCodesInput, deal_code_groupsUncheckedCreateWithoutDealCodesInput>
    connectOrCreate?: deal_code_groupsCreateOrConnectWithoutDealCodesInput
    connect?: deal_code_groupsWhereUniqueInput
  }

  export type usersUpdateOneWithoutDealCodesNestedInput = {
    create?: XOR<usersCreateWithoutDealCodesInput, usersUncheckedCreateWithoutDealCodesInput>
    connectOrCreate?: usersCreateOrConnectWithoutDealCodesInput
    upsert?: usersUpsertWithoutDealCodesInput
    disconnect?: boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDealCodesInput, usersUpdateWithoutDealCodesInput>, usersUncheckedUpdateWithoutDealCodesInput>
  }

  export type deal_code_groupsUpdateOneRequiredWithoutDealCodesNestedInput = {
    create?: XOR<deal_code_groupsCreateWithoutDealCodesInput, deal_code_groupsUncheckedCreateWithoutDealCodesInput>
    connectOrCreate?: deal_code_groupsCreateOrConnectWithoutDealCodesInput
    upsert?: deal_code_groupsUpsertWithoutDealCodesInput
    connect?: deal_code_groupsWhereUniqueInput
    update?: XOR<XOR<deal_code_groupsUpdateToOneWithWhereWithoutDealCodesInput, deal_code_groupsUpdateWithoutDealCodesInput>, deal_code_groupsUncheckedUpdateWithoutDealCodesInput>
  }

  export type brandsCreateNestedOneWithoutDealCodeGroupsInput = {
    create?: XOR<brandsCreateWithoutDealCodeGroupsInput, brandsUncheckedCreateWithoutDealCodeGroupsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutDealCodeGroupsInput
    connect?: brandsWhereUniqueInput
  }

  export type deal_codesCreateNestedManyWithoutGroupInput = {
    create?: XOR<deal_codesCreateWithoutGroupInput, deal_codesUncheckedCreateWithoutGroupInput> | deal_codesCreateWithoutGroupInput[] | deal_codesUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: deal_codesCreateOrConnectWithoutGroupInput | deal_codesCreateOrConnectWithoutGroupInput[]
    createMany?: deal_codesCreateManyGroupInputEnvelope
    connect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
  }

  export type deal_codesUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<deal_codesCreateWithoutGroupInput, deal_codesUncheckedCreateWithoutGroupInput> | deal_codesCreateWithoutGroupInput[] | deal_codesUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: deal_codesCreateOrConnectWithoutGroupInput | deal_codesCreateOrConnectWithoutGroupInput[]
    createMany?: deal_codesCreateManyGroupInputEnvelope
    connect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
  }

  export type brandsUpdateOneRequiredWithoutDealCodeGroupsNestedInput = {
    create?: XOR<brandsCreateWithoutDealCodeGroupsInput, brandsUncheckedCreateWithoutDealCodeGroupsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutDealCodeGroupsInput
    upsert?: brandsUpsertWithoutDealCodeGroupsInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutDealCodeGroupsInput, brandsUpdateWithoutDealCodeGroupsInput>, brandsUncheckedUpdateWithoutDealCodeGroupsInput>
  }

  export type deal_codesUpdateManyWithoutGroupNestedInput = {
    create?: XOR<deal_codesCreateWithoutGroupInput, deal_codesUncheckedCreateWithoutGroupInput> | deal_codesCreateWithoutGroupInput[] | deal_codesUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: deal_codesCreateOrConnectWithoutGroupInput | deal_codesCreateOrConnectWithoutGroupInput[]
    upsert?: deal_codesUpsertWithWhereUniqueWithoutGroupInput | deal_codesUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: deal_codesCreateManyGroupInputEnvelope
    set?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    disconnect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    delete?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    connect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    update?: deal_codesUpdateWithWhereUniqueWithoutGroupInput | deal_codesUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: deal_codesUpdateManyWithWhereWithoutGroupInput | deal_codesUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: deal_codesScalarWhereInput | deal_codesScalarWhereInput[]
  }

  export type deal_codesUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<deal_codesCreateWithoutGroupInput, deal_codesUncheckedCreateWithoutGroupInput> | deal_codesCreateWithoutGroupInput[] | deal_codesUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: deal_codesCreateOrConnectWithoutGroupInput | deal_codesCreateOrConnectWithoutGroupInput[]
    upsert?: deal_codesUpsertWithWhereUniqueWithoutGroupInput | deal_codesUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: deal_codesCreateManyGroupInputEnvelope
    set?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    disconnect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    delete?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    connect?: deal_codesWhereUniqueInput | deal_codesWhereUniqueInput[]
    update?: deal_codesUpdateWithWhereUniqueWithoutGroupInput | deal_codesUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: deal_codesUpdateManyWithWhereWithoutGroupInput | deal_codesUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: deal_codesScalarWhereInput | deal_codesScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumGenderPreferenceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderPreference | EnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderPreference[] | ListEnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderPreference[] | ListEnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderPreferenceNullableFilter<$PrismaModel> | $Enums.GenderPreference | null
    isSet?: boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedEnumGenderPreferenceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderPreference | EnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderPreference[] | ListEnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderPreference[] | ListEnumGenderPreferenceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderPreferenceNullableWithAggregatesFilter<$PrismaModel> | $Enums.GenderPreference | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderPreferenceNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderPreferenceNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumNotificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableFilter<$PrismaModel> | $Enums.NotificationType | null
    isSet?: boolean
  }

  export type NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumNotificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type usersCreateWithoutAnswersInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAnswersInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAnswersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAnswersInput, usersUncheckedCreateWithoutAnswersInput>
  }

  export type questionsCreateWithoutAnswersInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    questionClass?: question_classesCreateNestedOneWithoutQuestionsInput
    brand?: brandsCreateNestedOneWithoutPitchQuestionsInput
    questionnaire?: questionnairesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutAnswersInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type questionsCreateOrConnectWithoutAnswersInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
  }

  export type brandsCreateWithoutProductFeedbackAnswersInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
  }

  export type brandsUncheckedCreateWithoutProductFeedbackAnswersInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
  }

  export type brandsCreateOrConnectWithoutProductFeedbackAnswersInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutProductFeedbackAnswersInput, brandsUncheckedCreateWithoutProductFeedbackAnswersInput>
  }

  export type brandsCreateWithoutPitchExitBrandAnswersInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutPitchExitBrandAnswersInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutPitchExitBrandAnswersInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutPitchExitBrandAnswersInput, brandsUncheckedCreateWithoutPitchExitBrandAnswersInput>
  }

  export type usersUpsertWithoutAnswersInput = {
    update: XOR<usersUpdateWithoutAnswersInput, usersUncheckedUpdateWithoutAnswersInput>
    create: XOR<usersCreateWithoutAnswersInput, usersUncheckedCreateWithoutAnswersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAnswersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAnswersInput, usersUncheckedUpdateWithoutAnswersInput>
  }

  export type usersUpdateWithoutAnswersInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAnswersInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type questionsUpsertWithoutAnswersInput = {
    update: XOR<questionsUpdateWithoutAnswersInput, questionsUncheckedUpdateWithoutAnswersInput>
    create: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    where?: questionsWhereInput
  }

  export type questionsUpdateToOneWithWhereWithoutAnswersInput = {
    where?: questionsWhereInput
    data: XOR<questionsUpdateWithoutAnswersInput, questionsUncheckedUpdateWithoutAnswersInput>
  }

  export type questionsUpdateWithoutAnswersInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    questionClass?: question_classesUpdateOneWithoutQuestionsNestedInput
    brand?: brandsUpdateOneWithoutPitchQuestionsNestedInput
    questionnaire?: questionnairesUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutAnswersInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type brandsUpsertWithoutProductFeedbackAnswersInput = {
    update: XOR<brandsUpdateWithoutProductFeedbackAnswersInput, brandsUncheckedUpdateWithoutProductFeedbackAnswersInput>
    create: XOR<brandsCreateWithoutProductFeedbackAnswersInput, brandsUncheckedCreateWithoutProductFeedbackAnswersInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutProductFeedbackAnswersInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutProductFeedbackAnswersInput, brandsUncheckedUpdateWithoutProductFeedbackAnswersInput>
  }

  export type brandsUpdateWithoutProductFeedbackAnswersInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutProductFeedbackAnswersInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
  }

  export type brandsUpsertWithoutPitchExitBrandAnswersInput = {
    update: XOR<brandsUpdateWithoutPitchExitBrandAnswersInput, brandsUncheckedUpdateWithoutPitchExitBrandAnswersInput>
    create: XOR<brandsCreateWithoutPitchExitBrandAnswersInput, brandsUncheckedCreateWithoutPitchExitBrandAnswersInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutPitchExitBrandAnswersInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutPitchExitBrandAnswersInput, brandsUncheckedUpdateWithoutPitchExitBrandAnswersInput>
  }

  export type brandsUpdateWithoutPitchExitBrandAnswersInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutPitchExitBrandAnswersInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type levelsCreateWithoutBenefitsInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questionnaire?: questionnairesCreateNestedOneWithoutLevelInput
    users?: usersCreateNestedManyWithoutLevelInput
  }

  export type levelsUncheckedCreateWithoutBenefitsInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    questionnaireId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: usersUncheckedCreateNestedManyWithoutLevelInput
  }

  export type levelsCreateOrConnectWithoutBenefitsInput = {
    where: levelsWhereUniqueInput
    create: XOR<levelsCreateWithoutBenefitsInput, levelsUncheckedCreateWithoutBenefitsInput>
  }

  export type link_visitsCreateWithoutBenefitInput = {
    id?: string
    url: string
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutLinkVisitsInput
    brand?: brandsCreateNestedOneWithoutLinkVisitsInput
    product?: productsCreateNestedOneWithoutLinkVisitsInput
  }

  export type link_visitsUncheckedCreateWithoutBenefitInput = {
    id?: string
    url: string
    userId: string
    brandId?: string | null
    productId?: string | null
    createdAt?: Date | string
  }

  export type link_visitsCreateOrConnectWithoutBenefitInput = {
    where: link_visitsWhereUniqueInput
    create: XOR<link_visitsCreateWithoutBenefitInput, link_visitsUncheckedCreateWithoutBenefitInput>
  }

  export type link_visitsCreateManyBenefitInputEnvelope = {
    data: link_visitsCreateManyBenefitInput | link_visitsCreateManyBenefitInput[]
  }

  export type levelsUpsertWithoutBenefitsInput = {
    update: XOR<levelsUpdateWithoutBenefitsInput, levelsUncheckedUpdateWithoutBenefitsInput>
    create: XOR<levelsCreateWithoutBenefitsInput, levelsUncheckedCreateWithoutBenefitsInput>
    where?: levelsWhereInput
  }

  export type levelsUpdateToOneWithWhereWithoutBenefitsInput = {
    where?: levelsWhereInput
    data: XOR<levelsUpdateWithoutBenefitsInput, levelsUncheckedUpdateWithoutBenefitsInput>
  }

  export type levelsUpdateWithoutBenefitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionnaire?: questionnairesUpdateOneWithoutLevelNestedInput
    users?: usersUpdateManyWithoutLevelNestedInput
  }

  export type levelsUncheckedUpdateWithoutBenefitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type link_visitsUpsertWithWhereUniqueWithoutBenefitInput = {
    where: link_visitsWhereUniqueInput
    update: XOR<link_visitsUpdateWithoutBenefitInput, link_visitsUncheckedUpdateWithoutBenefitInput>
    create: XOR<link_visitsCreateWithoutBenefitInput, link_visitsUncheckedCreateWithoutBenefitInput>
  }

  export type link_visitsUpdateWithWhereUniqueWithoutBenefitInput = {
    where: link_visitsWhereUniqueInput
    data: XOR<link_visitsUpdateWithoutBenefitInput, link_visitsUncheckedUpdateWithoutBenefitInput>
  }

  export type link_visitsUpdateManyWithWhereWithoutBenefitInput = {
    where: link_visitsScalarWhereInput
    data: XOR<link_visitsUpdateManyMutationInput, link_visitsUncheckedUpdateManyWithoutBenefitInput>
  }

  export type link_visitsScalarWhereInput = {
    AND?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
    OR?: link_visitsScalarWhereInput[]
    NOT?: link_visitsScalarWhereInput | link_visitsScalarWhereInput[]
    id?: StringFilter<"link_visits"> | string
    url?: StringFilter<"link_visits"> | string
    userId?: StringFilter<"link_visits"> | string
    brandId?: StringNullableFilter<"link_visits"> | string | null
    productId?: StringNullableFilter<"link_visits"> | string | null
    benefitId?: StringNullableFilter<"link_visits"> | string | null
    createdAt?: DateTimeFilter<"link_visits"> | Date | string
  }

  export type questionsCreateWithoutBrandInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    questionClass?: question_classesCreateNestedOneWithoutQuestionsInput
    answers?: answersCreateNestedManyWithoutQuestionInput
    questionnaire?: questionnairesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutBrandInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsCreateOrConnectWithoutBrandInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput>
  }

  export type questionsCreateManyBrandInputEnvelope = {
    data: questionsCreateManyBrandInput | questionsCreateManyBrandInput[]
  }

  export type pitch_viewsCreateWithoutBrandInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutPitchViewsInput
  }

  export type pitch_viewsUncheckedCreateWithoutBrandInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pitch_viewsCreateOrConnectWithoutBrandInput = {
    where: pitch_viewsWhereUniqueInput
    create: XOR<pitch_viewsCreateWithoutBrandInput, pitch_viewsUncheckedCreateWithoutBrandInput>
  }

  export type pitch_viewsCreateManyBrandInputEnvelope = {
    data: pitch_viewsCreateManyBrandInput | pitch_viewsCreateManyBrandInput[]
  }

  export type productsCreateWithoutBrandInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsCreateNestedManyWithoutProductInput
    ratings?: ratingsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutBrandInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutProductInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutBrandInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput>
  }

  export type productsCreateManyBrandInputEnvelope = {
    data: productsCreateManyBrandInput | productsCreateManyBrandInput[]
  }

  export type categoriesCreateWithoutBrandsInput = {
    id?: string
    name: InputJsonValue
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userChoices?: category_choicesCreateNestedManyWithoutCategoryInput
  }

  export type categoriesUncheckedCreateWithoutBrandsInput = {
    id?: string
    name: InputJsonValue
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userChoices?: category_choicesUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoriesCreateOrConnectWithoutBrandsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput>
  }

  export type ratingsCreateWithoutBrandInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutRatingsInput
    product?: productsCreateNestedOneWithoutRatingsInput
  }

  export type ratingsUncheckedCreateWithoutBrandInput = {
    id?: string
    userId: string
    productId?: string | null
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsCreateOrConnectWithoutBrandInput = {
    where: ratingsWhereUniqueInput
    create: XOR<ratingsCreateWithoutBrandInput, ratingsUncheckedCreateWithoutBrandInput>
  }

  export type ratingsCreateManyBrandInputEnvelope = {
    data: ratingsCreateManyBrandInput | ratingsCreateManyBrandInput[]
  }

  export type usersCreateWithoutForYouBrandsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutForYouBrandsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutForYouBrandsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutForYouBrandsInput, usersUncheckedCreateWithoutForYouBrandsInput>
  }

  export type usersCreateWithoutForYouBrandsPoolInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutForYouBrandsPoolInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutForYouBrandsPoolInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutForYouBrandsPoolInput, usersUncheckedCreateWithoutForYouBrandsPoolInput>
  }

  export type usersCreateWithoutNotInterestedBrandsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutNotInterestedBrandsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutNotInterestedBrandsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotInterestedBrandsInput, usersUncheckedCreateWithoutNotInterestedBrandsInput>
  }

  export type link_visitsCreateWithoutBrandInput = {
    id?: string
    url: string
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutLinkVisitsInput
    product?: productsCreateNestedOneWithoutLinkVisitsInput
    benefit?: benefitsCreateNestedOneWithoutLinkVisitsInput
  }

  export type link_visitsUncheckedCreateWithoutBrandInput = {
    id?: string
    url: string
    userId: string
    productId?: string | null
    benefitId?: string | null
    createdAt?: Date | string
  }

  export type link_visitsCreateOrConnectWithoutBrandInput = {
    where: link_visitsWhereUniqueInput
    create: XOR<link_visitsCreateWithoutBrandInput, link_visitsUncheckedCreateWithoutBrandInput>
  }

  export type link_visitsCreateManyBrandInputEnvelope = {
    data: link_visitsCreateManyBrandInput | link_visitsCreateManyBrandInput[]
  }

  export type brand_screen_timesCreateWithoutBrandInput = {
    id?: string
    time: number
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutBrandScreenTimesInput
  }

  export type brand_screen_timesUncheckedCreateWithoutBrandInput = {
    id?: string
    time: number
    userId: string
    createdAt?: Date | string
  }

  export type brand_screen_timesCreateOrConnectWithoutBrandInput = {
    where: brand_screen_timesWhereUniqueInput
    create: XOR<brand_screen_timesCreateWithoutBrandInput, brand_screen_timesUncheckedCreateWithoutBrandInput>
  }

  export type brand_screen_timesCreateManyBrandInputEnvelope = {
    data: brand_screen_timesCreateManyBrandInput | brand_screen_timesCreateManyBrandInput[]
  }

  export type production_submissionsCreateWithoutBrandInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutProductionSubmissionsInput
  }

  export type production_submissionsUncheckedCreateWithoutBrandInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type production_submissionsCreateOrConnectWithoutBrandInput = {
    where: production_submissionsWhereUniqueInput
    create: XOR<production_submissionsCreateWithoutBrandInput, production_submissionsUncheckedCreateWithoutBrandInput>
  }

  export type production_submissionsCreateManyBrandInputEnvelope = {
    data: production_submissionsCreateManyBrandInput | production_submissionsCreateManyBrandInput[]
  }

  export type usersCreateWithoutOwnedBrandInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutOwnedBrandInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutOwnedBrandInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOwnedBrandInput, usersUncheckedCreateWithoutOwnedBrandInput>
  }

  export type postsCreateWithoutBrandInput = {
    id?: string
    title: string
    author?: string | null
    content?: string | null
    video?: string | null
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userLikes?: usersCreateNestedManyWithoutLikedPostsInput
  }

  export type postsUncheckedCreateWithoutBrandInput = {
    id?: string
    title: string
    author?: string | null
    content?: string | null
    video?: string | null
    image?: InputJsonValue | null
    userLikesIds?: postsCreateuserLikesIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userLikes?: usersUncheckedCreateNestedManyWithoutLikedPostsInput
  }

  export type postsCreateOrConnectWithoutBrandInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutBrandInput, postsUncheckedCreateWithoutBrandInput>
  }

  export type postsCreateManyBrandInputEnvelope = {
    data: postsCreateManyBrandInput | postsCreateManyBrandInput[]
  }

  export type deal_code_groupsCreateWithoutBrandInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    codesState?: string | null
    generalExpireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dealCodes?: deal_codesCreateNestedManyWithoutGroupInput
  }

  export type deal_code_groupsUncheckedCreateWithoutBrandInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    codesState?: string | null
    generalExpireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutGroupInput
  }

  export type deal_code_groupsCreateOrConnectWithoutBrandInput = {
    where: deal_code_groupsWhereUniqueInput
    create: XOR<deal_code_groupsCreateWithoutBrandInput, deal_code_groupsUncheckedCreateWithoutBrandInput>
  }

  export type deal_code_groupsCreateManyBrandInputEnvelope = {
    data: deal_code_groupsCreateManyBrandInput | deal_code_groupsCreateManyBrandInput[]
  }

  export type unlocked_brands_historyCreateWithoutBrandInput = {
    id?: string
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutBrandUnlockHistoryInput
  }

  export type unlocked_brands_historyUncheckedCreateWithoutBrandInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type unlocked_brands_historyCreateOrConnectWithoutBrandInput = {
    where: unlocked_brands_historyWhereUniqueInput
    create: XOR<unlocked_brands_historyCreateWithoutBrandInput, unlocked_brands_historyUncheckedCreateWithoutBrandInput>
  }

  export type unlocked_brands_historyCreateManyBrandInputEnvelope = {
    data: unlocked_brands_historyCreateManyBrandInput | unlocked_brands_historyCreateManyBrandInput[]
  }

  export type answersCreateWithoutPitchExitBrandInput = {
    id?: string
    questionText: InputJsonValue
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutAnswersInput
    question?: questionsCreateNestedOneWithoutAnswersInput
    productFeedbackBrand?: brandsCreateNestedOneWithoutProductFeedbackAnswersInput
  }

  export type answersUncheckedCreateWithoutPitchExitBrandInput = {
    id?: string
    userId: string
    questionId?: string | null
    questionText: InputJsonValue
    answer: InputJsonValue
    productFeedbackBrandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answersCreateOrConnectWithoutPitchExitBrandInput = {
    where: answersWhereUniqueInput
    create: XOR<answersCreateWithoutPitchExitBrandInput, answersUncheckedCreateWithoutPitchExitBrandInput>
  }

  export type answersCreateManyPitchExitBrandInputEnvelope = {
    data: answersCreateManyPitchExitBrandInput | answersCreateManyPitchExitBrandInput[]
  }

  export type answersCreateWithoutProductFeedbackBrandInput = {
    id?: string
    questionText: InputJsonValue
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutAnswersInput
    question?: questionsCreateNestedOneWithoutAnswersInput
    pitchExitBrand?: brandsCreateNestedOneWithoutPitchExitBrandAnswersInput
  }

  export type answersUncheckedCreateWithoutProductFeedbackBrandInput = {
    id?: string
    userId: string
    questionId?: string | null
    questionText: InputJsonValue
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    pitchExitBrandId?: string | null
  }

  export type answersCreateOrConnectWithoutProductFeedbackBrandInput = {
    where: answersWhereUniqueInput
    create: XOR<answersCreateWithoutProductFeedbackBrandInput, answersUncheckedCreateWithoutProductFeedbackBrandInput>
  }

  export type answersCreateManyProductFeedbackBrandInputEnvelope = {
    data: answersCreateManyProductFeedbackBrandInput | answersCreateManyProductFeedbackBrandInput[]
  }

  export type questionsUpsertWithWhereUniqueWithoutBrandInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutBrandInput, questionsUncheckedUpdateWithoutBrandInput>
    create: XOR<questionsCreateWithoutBrandInput, questionsUncheckedCreateWithoutBrandInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutBrandInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutBrandInput, questionsUncheckedUpdateWithoutBrandInput>
  }

  export type questionsUpdateManyWithWhereWithoutBrandInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutBrandInput>
  }

  export type questionsScalarWhereInput = {
    AND?: questionsScalarWhereInput | questionsScalarWhereInput[]
    OR?: questionsScalarWhereInput[]
    NOT?: questionsScalarWhereInput | questionsScalarWhereInput[]
    id?: StringFilter<"questions"> | string
    position?: IntFilter<"questions"> | number
    question?: JsonFilter<"questions">
    type?: StringFilter<"questions"> | string
    options?: JsonNullableListFilter<"questions">
    classId?: StringNullableFilter<"questions"> | string | null
    categoryId?: StringNullableFilter<"questions"> | string | null
    onboarding?: BoolFilter<"questions"> | boolean
    randomizeOptions?: BoolNullableFilter<"questions"> | boolean | null
    fixedOptionSize?: BoolNullableFilter<"questions"> | boolean | null
    hideOptionText?: BoolNullableFilter<"questions"> | boolean | null
    displayImage?: JsonNullableFilter<"questions">
    footnote?: JsonNullableFilter<"questions">
    subtitle?: JsonNullableFilter<"questions">
    products?: JsonNullableFilter<"questions">
    brandId?: StringNullableFilter<"questions"> | string | null
    correctAnswerId?: StringNullableFilter<"questions"> | string | null
    questionnaireId?: StringNullableFilter<"questions"> | string | null
    questionnaireSubCategory?: IntNullableFilter<"questions"> | number | null
    createdAt?: DateTimeFilter<"questions"> | Date | string
    updatedAt?: DateTimeFilter<"questions"> | Date | string
    scaleTopLabel?: JsonNullableFilter<"questions">
    scaleBottomLabel?: JsonNullableFilter<"questions">
    maxOptions?: IntNullableFilter<"questions"> | number | null
  }

  export type pitch_viewsUpsertWithWhereUniqueWithoutBrandInput = {
    where: pitch_viewsWhereUniqueInput
    update: XOR<pitch_viewsUpdateWithoutBrandInput, pitch_viewsUncheckedUpdateWithoutBrandInput>
    create: XOR<pitch_viewsCreateWithoutBrandInput, pitch_viewsUncheckedCreateWithoutBrandInput>
  }

  export type pitch_viewsUpdateWithWhereUniqueWithoutBrandInput = {
    where: pitch_viewsWhereUniqueInput
    data: XOR<pitch_viewsUpdateWithoutBrandInput, pitch_viewsUncheckedUpdateWithoutBrandInput>
  }

  export type pitch_viewsUpdateManyWithWhereWithoutBrandInput = {
    where: pitch_viewsScalarWhereInput
    data: XOR<pitch_viewsUpdateManyMutationInput, pitch_viewsUncheckedUpdateManyWithoutBrandInput>
  }

  export type pitch_viewsScalarWhereInput = {
    AND?: pitch_viewsScalarWhereInput | pitch_viewsScalarWhereInput[]
    OR?: pitch_viewsScalarWhereInput[]
    NOT?: pitch_viewsScalarWhereInput | pitch_viewsScalarWhereInput[]
    id?: StringFilter<"pitch_views"> | string
    userId?: StringFilter<"pitch_views"> | string
    brandId?: StringNullableFilter<"pitch_views"> | string | null
    createdAt?: DateTimeFilter<"pitch_views"> | Date | string
    updatedAt?: DateTimeFilter<"pitch_views"> | Date | string
  }

  export type productsUpsertWithWhereUniqueWithoutBrandInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutBrandInput, productsUncheckedUpdateWithoutBrandInput>
    create: XOR<productsCreateWithoutBrandInput, productsUncheckedCreateWithoutBrandInput>
  }

  export type productsUpdateWithWhereUniqueWithoutBrandInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutBrandInput, productsUncheckedUpdateWithoutBrandInput>
  }

  export type productsUpdateManyWithWhereWithoutBrandInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutBrandInput>
  }

  export type productsScalarWhereInput = {
    AND?: productsScalarWhereInput | productsScalarWhereInput[]
    OR?: productsScalarWhereInput[]
    NOT?: productsScalarWhereInput | productsScalarWhereInput[]
    id?: StringFilter<"products"> | string
    description?: JsonNullableFilter<"products">
    images?: JsonNullableListFilter<"products">
    regularPrice?: StringNullableFilter<"products"> | string | null
    deal?: StringNullableFilter<"products"> | string | null
    dealPrice?: StringNullableFilter<"products"> | string | null
    purchaseUrl?: StringNullableFilter<"products"> | string | null
    brandId?: StringFilter<"products"> | string
    name?: StringFilter<"products"> | string
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
    uniqueDeal?: BoolNullableFilter<"products"> | boolean | null
  }

  export type categoriesUpsertWithoutBrandsInput = {
    update: XOR<categoriesUpdateWithoutBrandsInput, categoriesUncheckedUpdateWithoutBrandsInput>
    create: XOR<categoriesCreateWithoutBrandsInput, categoriesUncheckedCreateWithoutBrandsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutBrandsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutBrandsInput, categoriesUncheckedUpdateWithoutBrandsInput>
  }

  export type categoriesUpdateWithoutBrandsInput = {
    name?: InputJsonValue | InputJsonValue
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userChoices?: category_choicesUpdateManyWithoutCategoryNestedInput
  }

  export type categoriesUncheckedUpdateWithoutBrandsInput = {
    name?: InputJsonValue | InputJsonValue
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userChoices?: category_choicesUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ratingsUpsertWithWhereUniqueWithoutBrandInput = {
    where: ratingsWhereUniqueInput
    update: XOR<ratingsUpdateWithoutBrandInput, ratingsUncheckedUpdateWithoutBrandInput>
    create: XOR<ratingsCreateWithoutBrandInput, ratingsUncheckedCreateWithoutBrandInput>
  }

  export type ratingsUpdateWithWhereUniqueWithoutBrandInput = {
    where: ratingsWhereUniqueInput
    data: XOR<ratingsUpdateWithoutBrandInput, ratingsUncheckedUpdateWithoutBrandInput>
  }

  export type ratingsUpdateManyWithWhereWithoutBrandInput = {
    where: ratingsScalarWhereInput
    data: XOR<ratingsUpdateManyMutationInput, ratingsUncheckedUpdateManyWithoutBrandInput>
  }

  export type ratingsScalarWhereInput = {
    AND?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
    OR?: ratingsScalarWhereInput[]
    NOT?: ratingsScalarWhereInput | ratingsScalarWhereInput[]
    id?: StringFilter<"ratings"> | string
    userId?: StringFilter<"ratings"> | string
    productId?: StringNullableFilter<"ratings"> | string | null
    brandId?: StringFilter<"ratings"> | string
    rating?: FloatFilter<"ratings"> | number
    createdAt?: DateTimeFilter<"ratings"> | Date | string
    updatedAt?: DateTimeFilter<"ratings"> | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutForYouBrandsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutForYouBrandsInput, usersUncheckedUpdateWithoutForYouBrandsInput>
    create: XOR<usersCreateWithoutForYouBrandsInput, usersUncheckedCreateWithoutForYouBrandsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutForYouBrandsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutForYouBrandsInput, usersUncheckedUpdateWithoutForYouBrandsInput>
  }

  export type usersUpdateManyWithWhereWithoutForYouBrandsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutForYouBrandsInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    myFavourites?: JsonNullableListFilter<"users">
    hasAcceptedTermsAndConditions?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    name?: StringNullableFilter<"users"> | string | null
    notificationsToken?: StringNullableFilter<"users"> | string | null
    forYouBrandsIds?: StringNullableListFilter<"users">
    forYouBrandsPoolIds?: StringNullableListFilter<"users">
    notInterestedBrandsIds?: StringNullableListFilter<"users">
    levelId?: StringNullableFilter<"users"> | string | null
    brandsExplored?: IntFilter<"users"> | number
    ownedBrandId?: StringNullableFilter<"users"> | string | null
    foundersReachedLeaderboardId?: StringNullableFilter<"users"> | string | null
    viewedPitches?: StringNullableListFilter<"users">
    targetGender?: EnumGenderPreferenceNullableFilter<"users"> | $Enums.GenderPreference | null
    budgetInterval?: IntNullableFilter<"users"> | number | null
    deletedBrands?: StringNullableListFilter<"users">
    superUser?: BoolNullableFilter<"users"> | boolean | null
    hasNewForYouBrands?: BoolFilter<"users"> | boolean
    likedPostsIds?: StringNullableListFilter<"users">
    lastOpened?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type usersUpsertWithWhereUniqueWithoutForYouBrandsPoolInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutForYouBrandsPoolInput, usersUncheckedUpdateWithoutForYouBrandsPoolInput>
    create: XOR<usersCreateWithoutForYouBrandsPoolInput, usersUncheckedCreateWithoutForYouBrandsPoolInput>
  }

  export type usersUpdateWithWhereUniqueWithoutForYouBrandsPoolInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutForYouBrandsPoolInput, usersUncheckedUpdateWithoutForYouBrandsPoolInput>
  }

  export type usersUpdateManyWithWhereWithoutForYouBrandsPoolInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutForYouBrandsPoolInput>
  }

  export type usersUpsertWithWhereUniqueWithoutNotInterestedBrandsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutNotInterestedBrandsInput, usersUncheckedUpdateWithoutNotInterestedBrandsInput>
    create: XOR<usersCreateWithoutNotInterestedBrandsInput, usersUncheckedCreateWithoutNotInterestedBrandsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutNotInterestedBrandsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutNotInterestedBrandsInput, usersUncheckedUpdateWithoutNotInterestedBrandsInput>
  }

  export type usersUpdateManyWithWhereWithoutNotInterestedBrandsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutNotInterestedBrandsInput>
  }

  export type link_visitsUpsertWithWhereUniqueWithoutBrandInput = {
    where: link_visitsWhereUniqueInput
    update: XOR<link_visitsUpdateWithoutBrandInput, link_visitsUncheckedUpdateWithoutBrandInput>
    create: XOR<link_visitsCreateWithoutBrandInput, link_visitsUncheckedCreateWithoutBrandInput>
  }

  export type link_visitsUpdateWithWhereUniqueWithoutBrandInput = {
    where: link_visitsWhereUniqueInput
    data: XOR<link_visitsUpdateWithoutBrandInput, link_visitsUncheckedUpdateWithoutBrandInput>
  }

  export type link_visitsUpdateManyWithWhereWithoutBrandInput = {
    where: link_visitsScalarWhereInput
    data: XOR<link_visitsUpdateManyMutationInput, link_visitsUncheckedUpdateManyWithoutBrandInput>
  }

  export type brand_screen_timesUpsertWithWhereUniqueWithoutBrandInput = {
    where: brand_screen_timesWhereUniqueInput
    update: XOR<brand_screen_timesUpdateWithoutBrandInput, brand_screen_timesUncheckedUpdateWithoutBrandInput>
    create: XOR<brand_screen_timesCreateWithoutBrandInput, brand_screen_timesUncheckedCreateWithoutBrandInput>
  }

  export type brand_screen_timesUpdateWithWhereUniqueWithoutBrandInput = {
    where: brand_screen_timesWhereUniqueInput
    data: XOR<brand_screen_timesUpdateWithoutBrandInput, brand_screen_timesUncheckedUpdateWithoutBrandInput>
  }

  export type brand_screen_timesUpdateManyWithWhereWithoutBrandInput = {
    where: brand_screen_timesScalarWhereInput
    data: XOR<brand_screen_timesUpdateManyMutationInput, brand_screen_timesUncheckedUpdateManyWithoutBrandInput>
  }

  export type brand_screen_timesScalarWhereInput = {
    AND?: brand_screen_timesScalarWhereInput | brand_screen_timesScalarWhereInput[]
    OR?: brand_screen_timesScalarWhereInput[]
    NOT?: brand_screen_timesScalarWhereInput | brand_screen_timesScalarWhereInput[]
    id?: StringFilter<"brand_screen_times"> | string
    time?: IntFilter<"brand_screen_times"> | number
    userId?: StringFilter<"brand_screen_times"> | string
    brandId?: StringNullableFilter<"brand_screen_times"> | string | null
    createdAt?: DateTimeFilter<"brand_screen_times"> | Date | string
  }

  export type production_submissionsUpsertWithWhereUniqueWithoutBrandInput = {
    where: production_submissionsWhereUniqueInput
    update: XOR<production_submissionsUpdateWithoutBrandInput, production_submissionsUncheckedUpdateWithoutBrandInput>
    create: XOR<production_submissionsCreateWithoutBrandInput, production_submissionsUncheckedCreateWithoutBrandInput>
  }

  export type production_submissionsUpdateWithWhereUniqueWithoutBrandInput = {
    where: production_submissionsWhereUniqueInput
    data: XOR<production_submissionsUpdateWithoutBrandInput, production_submissionsUncheckedUpdateWithoutBrandInput>
  }

  export type production_submissionsUpdateManyWithWhereWithoutBrandInput = {
    where: production_submissionsScalarWhereInput
    data: XOR<production_submissionsUpdateManyMutationInput, production_submissionsUncheckedUpdateManyWithoutBrandInput>
  }

  export type production_submissionsScalarWhereInput = {
    AND?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
    OR?: production_submissionsScalarWhereInput[]
    NOT?: production_submissionsScalarWhereInput | production_submissionsScalarWhereInput[]
    id?: StringFilter<"production_submissions"> | string
    overlays?: JsonNullableListFilter<"production_submissions">
    videos?: JsonNullableListFilter<"production_submissions">
    status?: StringFilter<"production_submissions"> | string
    createdAt?: DateTimeFilter<"production_submissions"> | Date | string
    updatedAt?: DateTimeFilter<"production_submissions"> | Date | string
    brandId?: StringFilter<"production_submissions"> | string
    userId?: StringFilter<"production_submissions"> | string
  }

  export type usersUpsertWithoutOwnedBrandInput = {
    update: XOR<usersUpdateWithoutOwnedBrandInput, usersUncheckedUpdateWithoutOwnedBrandInput>
    create: XOR<usersCreateWithoutOwnedBrandInput, usersUncheckedCreateWithoutOwnedBrandInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOwnedBrandInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOwnedBrandInput, usersUncheckedUpdateWithoutOwnedBrandInput>
  }

  export type usersUpdateWithoutOwnedBrandInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutOwnedBrandInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type postsUpsertWithWhereUniqueWithoutBrandInput = {
    where: postsWhereUniqueInput
    update: XOR<postsUpdateWithoutBrandInput, postsUncheckedUpdateWithoutBrandInput>
    create: XOR<postsCreateWithoutBrandInput, postsUncheckedCreateWithoutBrandInput>
  }

  export type postsUpdateWithWhereUniqueWithoutBrandInput = {
    where: postsWhereUniqueInput
    data: XOR<postsUpdateWithoutBrandInput, postsUncheckedUpdateWithoutBrandInput>
  }

  export type postsUpdateManyWithWhereWithoutBrandInput = {
    where: postsScalarWhereInput
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutBrandInput>
  }

  export type postsScalarWhereInput = {
    AND?: postsScalarWhereInput | postsScalarWhereInput[]
    OR?: postsScalarWhereInput[]
    NOT?: postsScalarWhereInput | postsScalarWhereInput[]
    id?: StringFilter<"posts"> | string
    title?: StringFilter<"posts"> | string
    author?: StringNullableFilter<"posts"> | string | null
    content?: StringNullableFilter<"posts"> | string | null
    video?: StringNullableFilter<"posts"> | string | null
    image?: JsonNullableFilter<"posts">
    brandId?: StringNullableFilter<"posts"> | string | null
    userLikesIds?: StringNullableListFilter<"posts">
    createdAt?: DateTimeFilter<"posts"> | Date | string
    updatedAt?: DateTimeFilter<"posts"> | Date | string
  }

  export type deal_code_groupsUpsertWithWhereUniqueWithoutBrandInput = {
    where: deal_code_groupsWhereUniqueInput
    update: XOR<deal_code_groupsUpdateWithoutBrandInput, deal_code_groupsUncheckedUpdateWithoutBrandInput>
    create: XOR<deal_code_groupsCreateWithoutBrandInput, deal_code_groupsUncheckedCreateWithoutBrandInput>
  }

  export type deal_code_groupsUpdateWithWhereUniqueWithoutBrandInput = {
    where: deal_code_groupsWhereUniqueInput
    data: XOR<deal_code_groupsUpdateWithoutBrandInput, deal_code_groupsUncheckedUpdateWithoutBrandInput>
  }

  export type deal_code_groupsUpdateManyWithWhereWithoutBrandInput = {
    where: deal_code_groupsScalarWhereInput
    data: XOR<deal_code_groupsUpdateManyMutationInput, deal_code_groupsUncheckedUpdateManyWithoutBrandInput>
  }

  export type deal_code_groupsScalarWhereInput = {
    AND?: deal_code_groupsScalarWhereInput | deal_code_groupsScalarWhereInput[]
    OR?: deal_code_groupsScalarWhereInput[]
    NOT?: deal_code_groupsScalarWhereInput | deal_code_groupsScalarWhereInput[]
    id?: StringFilter<"deal_code_groups"> | string
    description?: JsonFilter<"deal_code_groups">
    shortDescription?: JsonNullableFilter<"deal_code_groups">
    codesState?: StringNullableFilter<"deal_code_groups"> | string | null
    brandId?: StringFilter<"deal_code_groups"> | string
    generalExpireDate?: DateTimeNullableFilter<"deal_code_groups"> | Date | string | null
    createdAt?: DateTimeFilter<"deal_code_groups"> | Date | string
    updatedAt?: DateTimeFilter<"deal_code_groups"> | Date | string
  }

  export type unlocked_brands_historyUpsertWithWhereUniqueWithoutBrandInput = {
    where: unlocked_brands_historyWhereUniqueInput
    update: XOR<unlocked_brands_historyUpdateWithoutBrandInput, unlocked_brands_historyUncheckedUpdateWithoutBrandInput>
    create: XOR<unlocked_brands_historyCreateWithoutBrandInput, unlocked_brands_historyUncheckedCreateWithoutBrandInput>
  }

  export type unlocked_brands_historyUpdateWithWhereUniqueWithoutBrandInput = {
    where: unlocked_brands_historyWhereUniqueInput
    data: XOR<unlocked_brands_historyUpdateWithoutBrandInput, unlocked_brands_historyUncheckedUpdateWithoutBrandInput>
  }

  export type unlocked_brands_historyUpdateManyWithWhereWithoutBrandInput = {
    where: unlocked_brands_historyScalarWhereInput
    data: XOR<unlocked_brands_historyUpdateManyMutationInput, unlocked_brands_historyUncheckedUpdateManyWithoutBrandInput>
  }

  export type unlocked_brands_historyScalarWhereInput = {
    AND?: unlocked_brands_historyScalarWhereInput | unlocked_brands_historyScalarWhereInput[]
    OR?: unlocked_brands_historyScalarWhereInput[]
    NOT?: unlocked_brands_historyScalarWhereInput | unlocked_brands_historyScalarWhereInput[]
    id?: StringFilter<"unlocked_brands_history"> | string
    userId?: StringFilter<"unlocked_brands_history"> | string
    brandId?: StringNullableFilter<"unlocked_brands_history"> | string | null
    createdAt?: DateTimeFilter<"unlocked_brands_history"> | Date | string
  }

  export type answersUpsertWithWhereUniqueWithoutPitchExitBrandInput = {
    where: answersWhereUniqueInput
    update: XOR<answersUpdateWithoutPitchExitBrandInput, answersUncheckedUpdateWithoutPitchExitBrandInput>
    create: XOR<answersCreateWithoutPitchExitBrandInput, answersUncheckedCreateWithoutPitchExitBrandInput>
  }

  export type answersUpdateWithWhereUniqueWithoutPitchExitBrandInput = {
    where: answersWhereUniqueInput
    data: XOR<answersUpdateWithoutPitchExitBrandInput, answersUncheckedUpdateWithoutPitchExitBrandInput>
  }

  export type answersUpdateManyWithWhereWithoutPitchExitBrandInput = {
    where: answersScalarWhereInput
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyWithoutPitchExitBrandInput>
  }

  export type answersScalarWhereInput = {
    AND?: answersScalarWhereInput | answersScalarWhereInput[]
    OR?: answersScalarWhereInput[]
    NOT?: answersScalarWhereInput | answersScalarWhereInput[]
    id?: StringFilter<"answers"> | string
    userId?: StringFilter<"answers"> | string
    questionId?: StringNullableFilter<"answers"> | string | null
    questionText?: JsonFilter<"answers">
    answer?: JsonFilter<"answers">
    productFeedbackBrandId?: StringNullableFilter<"answers"> | string | null
    createdAt?: DateTimeFilter<"answers"> | Date | string
    updatedAt?: DateTimeFilter<"answers"> | Date | string
    pitchExitBrandId?: StringNullableFilter<"answers"> | string | null
  }

  export type answersUpsertWithWhereUniqueWithoutProductFeedbackBrandInput = {
    where: answersWhereUniqueInput
    update: XOR<answersUpdateWithoutProductFeedbackBrandInput, answersUncheckedUpdateWithoutProductFeedbackBrandInput>
    create: XOR<answersCreateWithoutProductFeedbackBrandInput, answersUncheckedCreateWithoutProductFeedbackBrandInput>
  }

  export type answersUpdateWithWhereUniqueWithoutProductFeedbackBrandInput = {
    where: answersWhereUniqueInput
    data: XOR<answersUpdateWithoutProductFeedbackBrandInput, answersUncheckedUpdateWithoutProductFeedbackBrandInput>
  }

  export type answersUpdateManyWithWhereWithoutProductFeedbackBrandInput = {
    where: answersScalarWhereInput
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyWithoutProductFeedbackBrandInput>
  }

  export type usersCreateWithoutBrandUnlockHistoryInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutBrandUnlockHistoryInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutBrandUnlockHistoryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBrandUnlockHistoryInput, usersUncheckedCreateWithoutBrandUnlockHistoryInput>
  }

  export type brandsCreateWithoutUnlockHistoryInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutUnlockHistoryInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutUnlockHistoryInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutUnlockHistoryInput, brandsUncheckedCreateWithoutUnlockHistoryInput>
  }

  export type usersUpsertWithoutBrandUnlockHistoryInput = {
    update: XOR<usersUpdateWithoutBrandUnlockHistoryInput, usersUncheckedUpdateWithoutBrandUnlockHistoryInput>
    create: XOR<usersCreateWithoutBrandUnlockHistoryInput, usersUncheckedCreateWithoutBrandUnlockHistoryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBrandUnlockHistoryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBrandUnlockHistoryInput, usersUncheckedUpdateWithoutBrandUnlockHistoryInput>
  }

  export type usersUpdateWithoutBrandUnlockHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutBrandUnlockHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type brandsUpsertWithoutUnlockHistoryInput = {
    update: XOR<brandsUpdateWithoutUnlockHistoryInput, brandsUncheckedUpdateWithoutUnlockHistoryInput>
    create: XOR<brandsCreateWithoutUnlockHistoryInput, brandsUncheckedCreateWithoutUnlockHistoryInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutUnlockHistoryInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutUnlockHistoryInput, brandsUncheckedUpdateWithoutUnlockHistoryInput>
  }

  export type brandsUpdateWithoutUnlockHistoryInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutUnlockHistoryInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type usersCreateWithoutBrandScreenTimesInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutBrandScreenTimesInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutBrandScreenTimesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBrandScreenTimesInput, usersUncheckedCreateWithoutBrandScreenTimesInput>
  }

  export type brandsCreateWithoutBrandScreenTimesInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutBrandScreenTimesInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutBrandScreenTimesInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutBrandScreenTimesInput, brandsUncheckedCreateWithoutBrandScreenTimesInput>
  }

  export type usersUpsertWithoutBrandScreenTimesInput = {
    update: XOR<usersUpdateWithoutBrandScreenTimesInput, usersUncheckedUpdateWithoutBrandScreenTimesInput>
    create: XOR<usersCreateWithoutBrandScreenTimesInput, usersUncheckedCreateWithoutBrandScreenTimesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBrandScreenTimesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBrandScreenTimesInput, usersUncheckedUpdateWithoutBrandScreenTimesInput>
  }

  export type usersUpdateWithoutBrandScreenTimesInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutBrandScreenTimesInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type brandsUpsertWithoutBrandScreenTimesInput = {
    update: XOR<brandsUpdateWithoutBrandScreenTimesInput, brandsUncheckedUpdateWithoutBrandScreenTimesInput>
    create: XOR<brandsCreateWithoutBrandScreenTimesInput, brandsUncheckedCreateWithoutBrandScreenTimesInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutBrandScreenTimesInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutBrandScreenTimesInput, brandsUncheckedUpdateWithoutBrandScreenTimesInput>
  }

  export type brandsUpdateWithoutBrandScreenTimesInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutBrandScreenTimesInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsCreateWithoutCategoryInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutCategoryInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutCategoryInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutCategoryInput, brandsUncheckedCreateWithoutCategoryInput>
  }

  export type brandsCreateManyCategoryInputEnvelope = {
    data: brandsCreateManyCategoryInput | brandsCreateManyCategoryInput[]
  }

  export type category_choicesCreateWithoutCategoryInput = {
    id?: string
    like: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutCategoryChoicesInput
  }

  export type category_choicesUncheckedCreateWithoutCategoryInput = {
    id?: string
    like: boolean
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type category_choicesCreateOrConnectWithoutCategoryInput = {
    where: category_choicesWhereUniqueInput
    create: XOR<category_choicesCreateWithoutCategoryInput, category_choicesUncheckedCreateWithoutCategoryInput>
  }

  export type category_choicesCreateManyCategoryInputEnvelope = {
    data: category_choicesCreateManyCategoryInput | category_choicesCreateManyCategoryInput[]
  }

  export type brandsUpsertWithWhereUniqueWithoutCategoryInput = {
    where: brandsWhereUniqueInput
    update: XOR<brandsUpdateWithoutCategoryInput, brandsUncheckedUpdateWithoutCategoryInput>
    create: XOR<brandsCreateWithoutCategoryInput, brandsUncheckedCreateWithoutCategoryInput>
  }

  export type brandsUpdateWithWhereUniqueWithoutCategoryInput = {
    where: brandsWhereUniqueInput
    data: XOR<brandsUpdateWithoutCategoryInput, brandsUncheckedUpdateWithoutCategoryInput>
  }

  export type brandsUpdateManyWithWhereWithoutCategoryInput = {
    where: brandsScalarWhereInput
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyWithoutCategoryInput>
  }

  export type brandsScalarWhereInput = {
    AND?: brandsScalarWhereInput | brandsScalarWhereInput[]
    OR?: brandsScalarWhereInput[]
    NOT?: brandsScalarWhereInput | brandsScalarWhereInput[]
    id?: StringFilter<"brands"> | string
    description?: JsonFilter<"brands">
    shortDescription?: JsonNullableFilter<"brands">
    name?: StringFilter<"brands"> | string
    pitchVideo?: StringNullableFilter<"brands"> | string | null
    pitchCaptions?: JsonNullableFilter<"brands">
    pitchSections?: JsonNullableFilter<"brands">
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    brandLogo?: JsonNullableFilter<"brands">
    email?: StringNullableFilter<"brands"> | string | null
    managerEmail?: StringNullableFilter<"brands"> | string | null
    managerName?: StringNullableFilter<"brands"> | string | null
    managerPhone?: StringNullableFilter<"brands"> | string | null
    labels?: JsonNullableListFilter<"brands">
    teamPicture?: JsonNullableFilter<"brands">
    website?: StringNullableFilter<"brands"> | string | null
    categoryId?: StringNullableFilter<"brands"> | string | null
    teaser?: StringNullableFilter<"brands"> | string | null
    mainPhrase?: StringNullableFilter<"brands"> | string | null
    founders?: JsonNullableListFilter<"brands">
    image?: JsonNullableFilter<"brands">
    usersForYouIds?: StringNullableListFilter<"brands">
    usersForYouPoolIds?: StringNullableListFilter<"brands">
    usersNotInterestedBrandsIds?: StringNullableListFilter<"brands">
    images?: JsonNullableListFilter<"brands">
    usersFeedback?: JsonNullableFilter<"brands">
    selectedFeedback?: JsonFilter<"brands">
    targetGender?: EnumGenderPreferenceNullableFilter<"brands"> | $Enums.GenderPreference | null
    budgetInterval?: IntNullableFilter<"brands"> | number | null
    shopifyDomain?: StringNullableFilter<"brands"> | string | null
    shopifyKeyName?: StringNullableFilter<"brands"> | string | null
    ledgeRating?: IntFilter<"brands"> | number
    showTeamPictureInRating?: BoolNullableFilter<"brands"> | boolean | null
  }

  export type category_choicesUpsertWithWhereUniqueWithoutCategoryInput = {
    where: category_choicesWhereUniqueInput
    update: XOR<category_choicesUpdateWithoutCategoryInput, category_choicesUncheckedUpdateWithoutCategoryInput>
    create: XOR<category_choicesCreateWithoutCategoryInput, category_choicesUncheckedCreateWithoutCategoryInput>
  }

  export type category_choicesUpdateWithWhereUniqueWithoutCategoryInput = {
    where: category_choicesWhereUniqueInput
    data: XOR<category_choicesUpdateWithoutCategoryInput, category_choicesUncheckedUpdateWithoutCategoryInput>
  }

  export type category_choicesUpdateManyWithWhereWithoutCategoryInput = {
    where: category_choicesScalarWhereInput
    data: XOR<category_choicesUpdateManyMutationInput, category_choicesUncheckedUpdateManyWithoutCategoryInput>
  }

  export type category_choicesScalarWhereInput = {
    AND?: category_choicesScalarWhereInput | category_choicesScalarWhereInput[]
    OR?: category_choicesScalarWhereInput[]
    NOT?: category_choicesScalarWhereInput | category_choicesScalarWhereInput[]
    id?: StringFilter<"category_choices"> | string
    like?: BoolFilter<"category_choices"> | boolean
    categoryId?: StringFilter<"category_choices"> | string
    userId?: StringFilter<"category_choices"> | string
    createdAt?: DateTimeFilter<"category_choices"> | Date | string
    updatedAt?: DateTimeFilter<"category_choices"> | Date | string
  }

  export type categoriesCreateWithoutUserChoicesInput = {
    id?: string
    name: InputJsonValue
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brands?: brandsCreateNestedManyWithoutCategoryInput
  }

  export type categoriesUncheckedCreateWithoutUserChoicesInput = {
    id?: string
    name: InputJsonValue
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brands?: brandsUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoriesCreateOrConnectWithoutUserChoicesInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutUserChoicesInput, categoriesUncheckedCreateWithoutUserChoicesInput>
  }

  export type usersCreateWithoutCategoryChoicesInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutCategoryChoicesInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutCategoryChoicesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCategoryChoicesInput, usersUncheckedCreateWithoutCategoryChoicesInput>
  }

  export type categoriesUpsertWithoutUserChoicesInput = {
    update: XOR<categoriesUpdateWithoutUserChoicesInput, categoriesUncheckedUpdateWithoutUserChoicesInput>
    create: XOR<categoriesCreateWithoutUserChoicesInput, categoriesUncheckedCreateWithoutUserChoicesInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutUserChoicesInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutUserChoicesInput, categoriesUncheckedUpdateWithoutUserChoicesInput>
  }

  export type categoriesUpdateWithoutUserChoicesInput = {
    name?: InputJsonValue | InputJsonValue
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brands?: brandsUpdateManyWithoutCategoryNestedInput
  }

  export type categoriesUncheckedUpdateWithoutUserChoicesInput = {
    name?: InputJsonValue | InputJsonValue
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brands?: brandsUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type usersUpsertWithoutCategoryChoicesInput = {
    update: XOR<usersUpdateWithoutCategoryChoicesInput, usersUncheckedUpdateWithoutCategoryChoicesInput>
    create: XOR<usersCreateWithoutCategoryChoicesInput, usersUncheckedCreateWithoutCategoryChoicesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCategoryChoicesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCategoryChoicesInput, usersUncheckedUpdateWithoutCategoryChoicesInput>
  }

  export type usersUpdateWithoutCategoryChoicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutCategoryChoicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutFoundersReachedLeaderboardInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutFoundersReachedLeaderboardInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutFoundersReachedLeaderboardInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFoundersReachedLeaderboardInput, usersUncheckedCreateWithoutFoundersReachedLeaderboardInput>
  }

  export type usersCreateManyFoundersReachedLeaderboardInputEnvelope = {
    data: usersCreateManyFoundersReachedLeaderboardInput | usersCreateManyFoundersReachedLeaderboardInput[]
  }

  export type usersUpsertWithWhereUniqueWithoutFoundersReachedLeaderboardInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutFoundersReachedLeaderboardInput, usersUncheckedUpdateWithoutFoundersReachedLeaderboardInput>
    create: XOR<usersCreateWithoutFoundersReachedLeaderboardInput, usersUncheckedCreateWithoutFoundersReachedLeaderboardInput>
  }

  export type usersUpdateWithWhereUniqueWithoutFoundersReachedLeaderboardInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutFoundersReachedLeaderboardInput, usersUncheckedUpdateWithoutFoundersReachedLeaderboardInput>
  }

  export type usersUpdateManyWithWhereWithoutFoundersReachedLeaderboardInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutFoundersReachedLeaderboardInput>
  }

  export type usersCreateWithoutLinkVisitsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutLinkVisitsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutLinkVisitsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLinkVisitsInput, usersUncheckedCreateWithoutLinkVisitsInput>
  }

  export type brandsCreateWithoutLinkVisitsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutLinkVisitsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutLinkVisitsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutLinkVisitsInput, brandsUncheckedCreateWithoutLinkVisitsInput>
  }

  export type productsCreateWithoutLinkVisitsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    brand: brandsCreateNestedOneWithoutProductsInput
    ratings?: ratingsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutLinkVisitsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    ratings?: ratingsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutLinkVisitsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutLinkVisitsInput, productsUncheckedCreateWithoutLinkVisitsInput>
  }

  export type benefitsCreateWithoutLinkVisitsInput = {
    id?: string
    title: string
    subtitle: InputJsonValue
    description: InputJsonValue
    logo?: InputJsonValue | null
    image?: InputJsonValue | null
    redeemLink: string
    tags?: benefitsCreatetagsInput | InputJsonValue[]
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: levelsCreateNestedOneWithoutBenefitsInput
  }

  export type benefitsUncheckedCreateWithoutLinkVisitsInput = {
    id?: string
    title: string
    subtitle: InputJsonValue
    description: InputJsonValue
    logo?: InputJsonValue | null
    image?: InputJsonValue | null
    redeemLink: string
    levelId?: string | null
    tags?: benefitsCreatetagsInput | InputJsonValue[]
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type benefitsCreateOrConnectWithoutLinkVisitsInput = {
    where: benefitsWhereUniqueInput
    create: XOR<benefitsCreateWithoutLinkVisitsInput, benefitsUncheckedCreateWithoutLinkVisitsInput>
  }

  export type usersUpsertWithoutLinkVisitsInput = {
    update: XOR<usersUpdateWithoutLinkVisitsInput, usersUncheckedUpdateWithoutLinkVisitsInput>
    create: XOR<usersCreateWithoutLinkVisitsInput, usersUncheckedCreateWithoutLinkVisitsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLinkVisitsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLinkVisitsInput, usersUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type usersUpdateWithoutLinkVisitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutLinkVisitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type brandsUpsertWithoutLinkVisitsInput = {
    update: XOR<brandsUpdateWithoutLinkVisitsInput, brandsUncheckedUpdateWithoutLinkVisitsInput>
    create: XOR<brandsCreateWithoutLinkVisitsInput, brandsUncheckedCreateWithoutLinkVisitsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutLinkVisitsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutLinkVisitsInput, brandsUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type brandsUpdateWithoutLinkVisitsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutLinkVisitsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type productsUpsertWithoutLinkVisitsInput = {
    update: XOR<productsUpdateWithoutLinkVisitsInput, productsUncheckedUpdateWithoutLinkVisitsInput>
    create: XOR<productsCreateWithoutLinkVisitsInput, productsUncheckedCreateWithoutLinkVisitsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutLinkVisitsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutLinkVisitsInput, productsUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type productsUpdateWithoutLinkVisitsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: brandsUpdateOneRequiredWithoutProductsNestedInput
    ratings?: ratingsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutLinkVisitsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ratings?: ratingsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type benefitsUpsertWithoutLinkVisitsInput = {
    update: XOR<benefitsUpdateWithoutLinkVisitsInput, benefitsUncheckedUpdateWithoutLinkVisitsInput>
    create: XOR<benefitsCreateWithoutLinkVisitsInput, benefitsUncheckedCreateWithoutLinkVisitsInput>
    where?: benefitsWhereInput
  }

  export type benefitsUpdateToOneWithWhereWithoutLinkVisitsInput = {
    where?: benefitsWhereInput
    data: XOR<benefitsUpdateWithoutLinkVisitsInput, benefitsUncheckedUpdateWithoutLinkVisitsInput>
  }

  export type benefitsUpdateWithoutLinkVisitsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: levelsUpdateOneWithoutBenefitsNestedInput
  }

  export type benefitsUncheckedUpdateWithoutLinkVisitsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateWithoutPitchViewsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutPitchViewsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutPitchViewsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPitchViewsInput, usersUncheckedCreateWithoutPitchViewsInput>
  }

  export type brandsCreateWithoutPitchViewsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutPitchViewsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutPitchViewsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutPitchViewsInput, brandsUncheckedCreateWithoutPitchViewsInput>
  }

  export type usersUpsertWithoutPitchViewsInput = {
    update: XOR<usersUpdateWithoutPitchViewsInput, usersUncheckedUpdateWithoutPitchViewsInput>
    create: XOR<usersCreateWithoutPitchViewsInput, usersUncheckedCreateWithoutPitchViewsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPitchViewsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPitchViewsInput, usersUncheckedUpdateWithoutPitchViewsInput>
  }

  export type usersUpdateWithoutPitchViewsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutPitchViewsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type brandsUpsertWithoutPitchViewsInput = {
    update: XOR<brandsUpdateWithoutPitchViewsInput, brandsUncheckedUpdateWithoutPitchViewsInput>
    create: XOR<brandsCreateWithoutPitchViewsInput, brandsUncheckedCreateWithoutPitchViewsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutPitchViewsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutPitchViewsInput, brandsUncheckedUpdateWithoutPitchViewsInput>
  }

  export type brandsUpdateWithoutPitchViewsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutPitchViewsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsCreateWithoutPostsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutPostsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutPostsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutPostsInput, brandsUncheckedCreateWithoutPostsInput>
  }

  export type usersCreateWithoutLikedPostsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutLikedPostsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutLikedPostsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLikedPostsInput, usersUncheckedCreateWithoutLikedPostsInput>
  }

  export type brandsUpsertWithoutPostsInput = {
    update: XOR<brandsUpdateWithoutPostsInput, brandsUncheckedUpdateWithoutPostsInput>
    create: XOR<brandsCreateWithoutPostsInput, brandsUncheckedCreateWithoutPostsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutPostsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutPostsInput, brandsUncheckedUpdateWithoutPostsInput>
  }

  export type brandsUpdateWithoutPostsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutPostsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type usersUpsertWithWhereUniqueWithoutLikedPostsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutLikedPostsInput, usersUncheckedUpdateWithoutLikedPostsInput>
    create: XOR<usersCreateWithoutLikedPostsInput, usersUncheckedCreateWithoutLikedPostsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutLikedPostsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutLikedPostsInput, usersUncheckedUpdateWithoutLikedPostsInput>
  }

  export type usersUpdateManyWithWhereWithoutLikedPostsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutLikedPostsInput>
  }

  export type brandsCreateWithoutProductionSubmissionsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutProductionSubmissionsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutProductionSubmissionsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutProductionSubmissionsInput, brandsUncheckedCreateWithoutProductionSubmissionsInput>
  }

  export type usersCreateWithoutProductionSubmissionsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutProductionSubmissionsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutProductionSubmissionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProductionSubmissionsInput, usersUncheckedCreateWithoutProductionSubmissionsInput>
  }

  export type brandsUpsertWithoutProductionSubmissionsInput = {
    update: XOR<brandsUpdateWithoutProductionSubmissionsInput, brandsUncheckedUpdateWithoutProductionSubmissionsInput>
    create: XOR<brandsCreateWithoutProductionSubmissionsInput, brandsUncheckedCreateWithoutProductionSubmissionsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutProductionSubmissionsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutProductionSubmissionsInput, brandsUncheckedUpdateWithoutProductionSubmissionsInput>
  }

  export type brandsUpdateWithoutProductionSubmissionsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutProductionSubmissionsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type usersUpsertWithoutProductionSubmissionsInput = {
    update: XOR<usersUpdateWithoutProductionSubmissionsInput, usersUncheckedUpdateWithoutProductionSubmissionsInput>
    create: XOR<usersCreateWithoutProductionSubmissionsInput, usersUncheckedCreateWithoutProductionSubmissionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProductionSubmissionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProductionSubmissionsInput, usersUncheckedUpdateWithoutProductionSubmissionsInput>
  }

  export type usersUpdateWithoutProductionSubmissionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutProductionSubmissionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type brandsCreateWithoutProductsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutProductsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutProductsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
  }

  export type link_visitsCreateWithoutProductInput = {
    id?: string
    url: string
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutLinkVisitsInput
    brand?: brandsCreateNestedOneWithoutLinkVisitsInput
    benefit?: benefitsCreateNestedOneWithoutLinkVisitsInput
  }

  export type link_visitsUncheckedCreateWithoutProductInput = {
    id?: string
    url: string
    userId: string
    brandId?: string | null
    benefitId?: string | null
    createdAt?: Date | string
  }

  export type link_visitsCreateOrConnectWithoutProductInput = {
    where: link_visitsWhereUniqueInput
    create: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput>
  }

  export type link_visitsCreateManyProductInputEnvelope = {
    data: link_visitsCreateManyProductInput | link_visitsCreateManyProductInput[]
  }

  export type ratingsCreateWithoutProductInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutRatingsInput
    brand: brandsCreateNestedOneWithoutRatingsInput
  }

  export type ratingsUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    brandId: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsCreateOrConnectWithoutProductInput = {
    where: ratingsWhereUniqueInput
    create: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput>
  }

  export type ratingsCreateManyProductInputEnvelope = {
    data: ratingsCreateManyProductInput | ratingsCreateManyProductInput[]
  }

  export type brandsUpsertWithoutProductsInput = {
    update: XOR<brandsUpdateWithoutProductsInput, brandsUncheckedUpdateWithoutProductsInput>
    create: XOR<brandsCreateWithoutProductsInput, brandsUncheckedCreateWithoutProductsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutProductsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutProductsInput, brandsUncheckedUpdateWithoutProductsInput>
  }

  export type brandsUpdateWithoutProductsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutProductsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type link_visitsUpsertWithWhereUniqueWithoutProductInput = {
    where: link_visitsWhereUniqueInput
    update: XOR<link_visitsUpdateWithoutProductInput, link_visitsUncheckedUpdateWithoutProductInput>
    create: XOR<link_visitsCreateWithoutProductInput, link_visitsUncheckedCreateWithoutProductInput>
  }

  export type link_visitsUpdateWithWhereUniqueWithoutProductInput = {
    where: link_visitsWhereUniqueInput
    data: XOR<link_visitsUpdateWithoutProductInput, link_visitsUncheckedUpdateWithoutProductInput>
  }

  export type link_visitsUpdateManyWithWhereWithoutProductInput = {
    where: link_visitsScalarWhereInput
    data: XOR<link_visitsUpdateManyMutationInput, link_visitsUncheckedUpdateManyWithoutProductInput>
  }

  export type ratingsUpsertWithWhereUniqueWithoutProductInput = {
    where: ratingsWhereUniqueInput
    update: XOR<ratingsUpdateWithoutProductInput, ratingsUncheckedUpdateWithoutProductInput>
    create: XOR<ratingsCreateWithoutProductInput, ratingsUncheckedCreateWithoutProductInput>
  }

  export type ratingsUpdateWithWhereUniqueWithoutProductInput = {
    where: ratingsWhereUniqueInput
    data: XOR<ratingsUpdateWithoutProductInput, ratingsUncheckedUpdateWithoutProductInput>
  }

  export type ratingsUpdateManyWithWhereWithoutProductInput = {
    where: ratingsScalarWhereInput
    data: XOR<ratingsUpdateManyMutationInput, ratingsUncheckedUpdateManyWithoutProductInput>
  }

  export type usersCreateWithoutPushNotificationHistoryInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
  }

  export type usersUncheckedCreateWithoutPushNotificationHistoryInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
  }

  export type usersCreateOrConnectWithoutPushNotificationHistoryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPushNotificationHistoryInput, usersUncheckedCreateWithoutPushNotificationHistoryInput>
  }

  export type usersUpsertWithoutPushNotificationHistoryInput = {
    update: XOR<usersUpdateWithoutPushNotificationHistoryInput, usersUncheckedUpdateWithoutPushNotificationHistoryInput>
    create: XOR<usersCreateWithoutPushNotificationHistoryInput, usersUncheckedCreateWithoutPushNotificationHistoryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPushNotificationHistoryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPushNotificationHistoryInput, usersUncheckedUpdateWithoutPushNotificationHistoryInput>
  }

  export type usersUpdateWithoutPushNotificationHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
  }

  export type usersUncheckedUpdateWithoutPushNotificationHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
  }

  export type questionsCreateWithoutQuestionnaireInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    questionClass?: question_classesCreateNestedOneWithoutQuestionsInput
    answers?: answersCreateNestedManyWithoutQuestionInput
    brand?: brandsCreateNestedOneWithoutPitchQuestionsInput
  }

  export type questionsUncheckedCreateWithoutQuestionnaireInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsCreateOrConnectWithoutQuestionnaireInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput>
  }

  export type questionsCreateManyQuestionnaireInputEnvelope = {
    data: questionsCreateManyQuestionnaireInput | questionsCreateManyQuestionnaireInput[]
  }

  export type levelsCreateWithoutQuestionnaireInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    createdAt?: Date | string
    updatedAt?: Date | string
    benefits?: benefitsCreateNestedManyWithoutLevelInput
    users?: usersCreateNestedManyWithoutLevelInput
  }

  export type levelsUncheckedCreateWithoutQuestionnaireInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    createdAt?: Date | string
    updatedAt?: Date | string
    benefits?: benefitsUncheckedCreateNestedManyWithoutLevelInput
    users?: usersUncheckedCreateNestedManyWithoutLevelInput
  }

  export type levelsCreateOrConnectWithoutQuestionnaireInput = {
    where: levelsWhereUniqueInput
    create: XOR<levelsCreateWithoutQuestionnaireInput, levelsUncheckedCreateWithoutQuestionnaireInput>
  }

  export type questionsUpsertWithWhereUniqueWithoutQuestionnaireInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutQuestionnaireInput, questionsUncheckedUpdateWithoutQuestionnaireInput>
    create: XOR<questionsCreateWithoutQuestionnaireInput, questionsUncheckedCreateWithoutQuestionnaireInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutQuestionnaireInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutQuestionnaireInput, questionsUncheckedUpdateWithoutQuestionnaireInput>
  }

  export type questionsUpdateManyWithWhereWithoutQuestionnaireInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutQuestionnaireInput>
  }

  export type levelsUpsertWithoutQuestionnaireInput = {
    update: XOR<levelsUpdateWithoutQuestionnaireInput, levelsUncheckedUpdateWithoutQuestionnaireInput>
    create: XOR<levelsCreateWithoutQuestionnaireInput, levelsUncheckedCreateWithoutQuestionnaireInput>
    where?: levelsWhereInput
  }

  export type levelsUpdateToOneWithWhereWithoutQuestionnaireInput = {
    where?: levelsWhereInput
    data: XOR<levelsUpdateWithoutQuestionnaireInput, levelsUncheckedUpdateWithoutQuestionnaireInput>
  }

  export type levelsUpdateWithoutQuestionnaireInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: benefitsUpdateManyWithoutLevelNestedInput
    users?: usersUpdateManyWithoutLevelNestedInput
  }

  export type levelsUncheckedUpdateWithoutQuestionnaireInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: benefitsUncheckedUpdateManyWithoutLevelNestedInput
    users?: usersUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type questionsCreateWithoutQuestionClassInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersCreateNestedManyWithoutQuestionInput
    brand?: brandsCreateNestedOneWithoutPitchQuestionsInput
    questionnaire?: questionnairesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutQuestionClassInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
    answers?: answersUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionsCreateOrConnectWithoutQuestionClassInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput>
  }

  export type questionsCreateManyQuestionClassInputEnvelope = {
    data: questionsCreateManyQuestionClassInput | questionsCreateManyQuestionClassInput[]
  }

  export type questionsUpsertWithWhereUniqueWithoutQuestionClassInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutQuestionClassInput, questionsUncheckedUpdateWithoutQuestionClassInput>
    create: XOR<questionsCreateWithoutQuestionClassInput, questionsUncheckedCreateWithoutQuestionClassInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutQuestionClassInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutQuestionClassInput, questionsUncheckedUpdateWithoutQuestionClassInput>
  }

  export type questionsUpdateManyWithWhereWithoutQuestionClassInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutQuestionClassInput>
  }

  export type question_classesCreateWithoutQuestionsInput = {
    id?: string
    name: string
    editable: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type question_classesUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    editable: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type question_classesCreateOrConnectWithoutQuestionsInput = {
    where: question_classesWhereUniqueInput
    create: XOR<question_classesCreateWithoutQuestionsInput, question_classesUncheckedCreateWithoutQuestionsInput>
  }

  export type answersCreateWithoutQuestionInput = {
    id?: string
    questionText: InputJsonValue
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutAnswersInput
    productFeedbackBrand?: brandsCreateNestedOneWithoutProductFeedbackAnswersInput
    pitchExitBrand?: brandsCreateNestedOneWithoutPitchExitBrandAnswersInput
  }

  export type answersUncheckedCreateWithoutQuestionInput = {
    id?: string
    userId: string
    questionText: InputJsonValue
    answer: InputJsonValue
    productFeedbackBrandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pitchExitBrandId?: string | null
  }

  export type answersCreateOrConnectWithoutQuestionInput = {
    where: answersWhereUniqueInput
    create: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput>
  }

  export type answersCreateManyQuestionInputEnvelope = {
    data: answersCreateManyQuestionInput | answersCreateManyQuestionInput[]
  }

  export type brandsCreateWithoutPitchQuestionsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutPitchQuestionsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutPitchQuestionsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutPitchQuestionsInput, brandsUncheckedCreateWithoutPitchQuestionsInput>
  }

  export type questionnairesCreateWithoutQuestionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: levelsCreateNestedOneWithoutQuestionnaireInput
  }

  export type questionnairesUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: levelsUncheckedCreateNestedOneWithoutQuestionnaireInput
  }

  export type questionnairesCreateOrConnectWithoutQuestionsInput = {
    where: questionnairesWhereUniqueInput
    create: XOR<questionnairesCreateWithoutQuestionsInput, questionnairesUncheckedCreateWithoutQuestionsInput>
  }

  export type question_classesUpsertWithoutQuestionsInput = {
    update: XOR<question_classesUpdateWithoutQuestionsInput, question_classesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<question_classesCreateWithoutQuestionsInput, question_classesUncheckedCreateWithoutQuestionsInput>
    where?: question_classesWhereInput
  }

  export type question_classesUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: question_classesWhereInput
    data: XOR<question_classesUpdateWithoutQuestionsInput, question_classesUncheckedUpdateWithoutQuestionsInput>
  }

  export type question_classesUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    editable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_classesUncheckedUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    editable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUpsertWithWhereUniqueWithoutQuestionInput = {
    where: answersWhereUniqueInput
    update: XOR<answersUpdateWithoutQuestionInput, answersUncheckedUpdateWithoutQuestionInput>
    create: XOR<answersCreateWithoutQuestionInput, answersUncheckedCreateWithoutQuestionInput>
  }

  export type answersUpdateWithWhereUniqueWithoutQuestionInput = {
    where: answersWhereUniqueInput
    data: XOR<answersUpdateWithoutQuestionInput, answersUncheckedUpdateWithoutQuestionInput>
  }

  export type answersUpdateManyWithWhereWithoutQuestionInput = {
    where: answersScalarWhereInput
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyWithoutQuestionInput>
  }

  export type brandsUpsertWithoutPitchQuestionsInput = {
    update: XOR<brandsUpdateWithoutPitchQuestionsInput, brandsUncheckedUpdateWithoutPitchQuestionsInput>
    create: XOR<brandsCreateWithoutPitchQuestionsInput, brandsUncheckedCreateWithoutPitchQuestionsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutPitchQuestionsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutPitchQuestionsInput, brandsUncheckedUpdateWithoutPitchQuestionsInput>
  }

  export type brandsUpdateWithoutPitchQuestionsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutPitchQuestionsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type questionnairesUpsertWithoutQuestionsInput = {
    update: XOR<questionnairesUpdateWithoutQuestionsInput, questionnairesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<questionnairesCreateWithoutQuestionsInput, questionnairesUncheckedCreateWithoutQuestionsInput>
    where?: questionnairesWhereInput
  }

  export type questionnairesUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: questionnairesWhereInput
    data: XOR<questionnairesUpdateWithoutQuestionsInput, questionnairesUncheckedUpdateWithoutQuestionsInput>
  }

  export type questionnairesUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: levelsUpdateOneWithoutQuestionnaireNestedInput
  }

  export type questionnairesUncheckedUpdateWithoutQuestionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: levelsUncheckedUpdateOneWithoutQuestionnaireNestedInput
  }

  export type usersCreateWithoutRatingsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutRatingsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutRatingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRatingsInput, usersUncheckedCreateWithoutRatingsInput>
  }

  export type productsCreateWithoutRatingsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    brand: brandsCreateNestedOneWithoutProductsInput
    linkVisits?: link_visitsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutRatingsInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    brandId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutRatingsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutRatingsInput, productsUncheckedCreateWithoutRatingsInput>
  }

  export type brandsCreateWithoutRatingsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutRatingsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutRatingsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutRatingsInput, brandsUncheckedCreateWithoutRatingsInput>
  }

  export type usersUpsertWithoutRatingsInput = {
    update: XOR<usersUpdateWithoutRatingsInput, usersUncheckedUpdateWithoutRatingsInput>
    create: XOR<usersCreateWithoutRatingsInput, usersUncheckedCreateWithoutRatingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRatingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRatingsInput, usersUncheckedUpdateWithoutRatingsInput>
  }

  export type usersUpdateWithoutRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type productsUpsertWithoutRatingsInput = {
    update: XOR<productsUpdateWithoutRatingsInput, productsUncheckedUpdateWithoutRatingsInput>
    create: XOR<productsCreateWithoutRatingsInput, productsUncheckedCreateWithoutRatingsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutRatingsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutRatingsInput, productsUncheckedUpdateWithoutRatingsInput>
  }

  export type productsUpdateWithoutRatingsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: brandsUpdateOneRequiredWithoutProductsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutRatingsInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type brandsUpsertWithoutRatingsInput = {
    update: XOR<brandsUpdateWithoutRatingsInput, brandsUncheckedUpdateWithoutRatingsInput>
    create: XOR<brandsCreateWithoutRatingsInput, brandsUncheckedCreateWithoutRatingsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutRatingsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutRatingsInput, brandsUncheckedUpdateWithoutRatingsInput>
  }

  export type brandsUpdateWithoutRatingsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutRatingsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type usersCreateWithoutSettingsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutSettingsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutSettingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSettingsInput, usersUncheckedCreateWithoutSettingsInput>
  }

  export type usersUpsertWithoutSettingsInput = {
    update: XOR<usersUpdateWithoutSettingsInput, usersUncheckedUpdateWithoutSettingsInput>
    create: XOR<usersCreateWithoutSettingsInput, usersUncheckedCreateWithoutSettingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSettingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSettingsInput, usersUncheckedUpdateWithoutSettingsInput>
  }

  export type usersUpdateWithoutSettingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutSettingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutTermsAndConditionsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutTermsAndConditionsInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutTermsAndConditionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTermsAndConditionsInput, usersUncheckedCreateWithoutTermsAndConditionsInput>
  }

  export type usersUpsertWithoutTermsAndConditionsInput = {
    update: XOR<usersUpdateWithoutTermsAndConditionsInput, usersUncheckedUpdateWithoutTermsAndConditionsInput>
    create: XOR<usersCreateWithoutTermsAndConditionsInput, usersUncheckedCreateWithoutTermsAndConditionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTermsAndConditionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTermsAndConditionsInput, usersUncheckedUpdateWithoutTermsAndConditionsInput>
  }

  export type usersUpdateWithoutTermsAndConditionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutTermsAndConditionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutFeedbacksInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutFeedbacksInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutFeedbacksInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFeedbacksInput, usersUncheckedCreateWithoutFeedbacksInput>
  }

  export type usersUpsertWithoutFeedbacksInput = {
    update: XOR<usersUpdateWithoutFeedbacksInput, usersUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<usersCreateWithoutFeedbacksInput, usersUncheckedCreateWithoutFeedbacksInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFeedbacksInput, usersUncheckedUpdateWithoutFeedbacksInput>
  }

  export type usersUpdateWithoutFeedbacksInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutFeedbacksInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type questionnairesCreateWithoutLevelInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsCreateNestedManyWithoutQuestionnaireInput
  }

  export type questionnairesUncheckedCreateWithoutLevelInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: questionsUncheckedCreateNestedManyWithoutQuestionnaireInput
  }

  export type questionnairesCreateOrConnectWithoutLevelInput = {
    where: questionnairesWhereUniqueInput
    create: XOR<questionnairesCreateWithoutLevelInput, questionnairesUncheckedCreateWithoutLevelInput>
  }

  export type benefitsCreateWithoutLevelInput = {
    id?: string
    title: string
    subtitle: InputJsonValue
    description: InputJsonValue
    logo?: InputJsonValue | null
    image?: InputJsonValue | null
    redeemLink: string
    tags?: benefitsCreatetagsInput | InputJsonValue[]
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkVisits?: link_visitsCreateNestedManyWithoutBenefitInput
  }

  export type benefitsUncheckedCreateWithoutLevelInput = {
    id?: string
    title: string
    subtitle: InputJsonValue
    description: InputJsonValue
    logo?: InputJsonValue | null
    image?: InputJsonValue | null
    redeemLink: string
    tags?: benefitsCreatetagsInput | InputJsonValue[]
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBenefitInput
  }

  export type benefitsCreateOrConnectWithoutLevelInput = {
    where: benefitsWhereUniqueInput
    create: XOR<benefitsCreateWithoutLevelInput, benefitsUncheckedCreateWithoutLevelInput>
  }

  export type benefitsCreateManyLevelInputEnvelope = {
    data: benefitsCreateManyLevelInput | benefitsCreateManyLevelInput[]
  }

  export type usersCreateWithoutLevelInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    dealCodes?: deal_codesCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutLevelInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    dealCodes?: deal_codesUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutLevelInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLevelInput, usersUncheckedCreateWithoutLevelInput>
  }

  export type usersCreateManyLevelInputEnvelope = {
    data: usersCreateManyLevelInput | usersCreateManyLevelInput[]
  }

  export type questionnairesUpsertWithoutLevelInput = {
    update: XOR<questionnairesUpdateWithoutLevelInput, questionnairesUncheckedUpdateWithoutLevelInput>
    create: XOR<questionnairesCreateWithoutLevelInput, questionnairesUncheckedCreateWithoutLevelInput>
    where?: questionnairesWhereInput
  }

  export type questionnairesUpdateToOneWithWhereWithoutLevelInput = {
    where?: questionnairesWhereInput
    data: XOR<questionnairesUpdateWithoutLevelInput, questionnairesUncheckedUpdateWithoutLevelInput>
  }

  export type questionnairesUpdateWithoutLevelInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUpdateManyWithoutQuestionnaireNestedInput
  }

  export type questionnairesUncheckedUpdateWithoutLevelInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutQuestionnaireNestedInput
  }

  export type benefitsUpsertWithWhereUniqueWithoutLevelInput = {
    where: benefitsWhereUniqueInput
    update: XOR<benefitsUpdateWithoutLevelInput, benefitsUncheckedUpdateWithoutLevelInput>
    create: XOR<benefitsCreateWithoutLevelInput, benefitsUncheckedCreateWithoutLevelInput>
  }

  export type benefitsUpdateWithWhereUniqueWithoutLevelInput = {
    where: benefitsWhereUniqueInput
    data: XOR<benefitsUpdateWithoutLevelInput, benefitsUncheckedUpdateWithoutLevelInput>
  }

  export type benefitsUpdateManyWithWhereWithoutLevelInput = {
    where: benefitsScalarWhereInput
    data: XOR<benefitsUpdateManyMutationInput, benefitsUncheckedUpdateManyWithoutLevelInput>
  }

  export type benefitsScalarWhereInput = {
    AND?: benefitsScalarWhereInput | benefitsScalarWhereInput[]
    OR?: benefitsScalarWhereInput[]
    NOT?: benefitsScalarWhereInput | benefitsScalarWhereInput[]
    id?: StringFilter<"benefits"> | string
    title?: StringFilter<"benefits"> | string
    subtitle?: JsonFilter<"benefits">
    description?: JsonFilter<"benefits">
    logo?: JsonNullableFilter<"benefits">
    image?: JsonNullableFilter<"benefits">
    redeemLink?: StringFilter<"benefits"> | string
    levelId?: StringNullableFilter<"benefits"> | string | null
    tags?: JsonNullableListFilter<"benefits">
    code?: StringNullableFilter<"benefits"> | string | null
    createdAt?: DateTimeFilter<"benefits"> | Date | string
    updatedAt?: DateTimeFilter<"benefits"> | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutLevelInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutLevelInput, usersUncheckedUpdateWithoutLevelInput>
    create: XOR<usersCreateWithoutLevelInput, usersUncheckedCreateWithoutLevelInput>
  }

  export type usersUpdateWithWhereUniqueWithoutLevelInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutLevelInput, usersUncheckedUpdateWithoutLevelInput>
  }

  export type usersUpdateManyWithWhereWithoutLevelInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutLevelInput>
  }

  export type answersCreateWithoutUserInput = {
    id?: string
    questionText: InputJsonValue
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    question?: questionsCreateNestedOneWithoutAnswersInput
    productFeedbackBrand?: brandsCreateNestedOneWithoutProductFeedbackAnswersInput
    pitchExitBrand?: brandsCreateNestedOneWithoutPitchExitBrandAnswersInput
  }

  export type answersUncheckedCreateWithoutUserInput = {
    id?: string
    questionId?: string | null
    questionText: InputJsonValue
    answer: InputJsonValue
    productFeedbackBrandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pitchExitBrandId?: string | null
  }

  export type answersCreateOrConnectWithoutUserInput = {
    where: answersWhereUniqueInput
    create: XOR<answersCreateWithoutUserInput, answersUncheckedCreateWithoutUserInput>
  }

  export type answersCreateManyUserInputEnvelope = {
    data: answersCreateManyUserInput | answersCreateManyUserInput[]
  }

  export type pitch_viewsCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brand?: brandsCreateNestedOneWithoutPitchViewsInput
  }

  export type pitch_viewsUncheckedCreateWithoutUserInput = {
    id?: string
    brandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pitch_viewsCreateOrConnectWithoutUserInput = {
    where: pitch_viewsWhereUniqueInput
    create: XOR<pitch_viewsCreateWithoutUserInput, pitch_viewsUncheckedCreateWithoutUserInput>
  }

  export type pitch_viewsCreateManyUserInputEnvelope = {
    data: pitch_viewsCreateManyUserInput | pitch_viewsCreateManyUserInput[]
  }

  export type settingsCreateWithoutUserInput = {
    id?: string
    receiveNotifications: boolean
    newBrands: boolean
    personalizedOffers: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type settingsUncheckedCreateWithoutUserInput = {
    id?: string
    receiveNotifications: boolean
    newBrands: boolean
    personalizedOffers: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type settingsCreateOrConnectWithoutUserInput = {
    where: settingsWhereUniqueInput
    create: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
  }

  export type ratingsCreateWithoutUserInput = {
    id?: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: productsCreateNestedOneWithoutRatingsInput
    brand: brandsCreateNestedOneWithoutRatingsInput
  }

  export type ratingsUncheckedCreateWithoutUserInput = {
    id?: string
    productId?: string | null
    brandId: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsCreateOrConnectWithoutUserInput = {
    where: ratingsWhereUniqueInput
    create: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput>
  }

  export type ratingsCreateManyUserInputEnvelope = {
    data: ratingsCreateManyUserInput | ratingsCreateManyUserInput[]
  }

  export type brandsCreateWithoutUsersForYouInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutUsersForYouInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutUsersForYouInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutUsersForYouInput, brandsUncheckedCreateWithoutUsersForYouInput>
  }

  export type brandsCreateWithoutUsersForYouPoolInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutUsersForYouPoolInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutUsersForYouPoolInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutUsersForYouPoolInput, brandsUncheckedCreateWithoutUsersForYouPoolInput>
  }

  export type brandsCreateWithoutUsersNotInterestedBrandsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutUsersNotInterestedBrandsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutUsersNotInterestedBrandsInput, brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput>
  }

  export type link_visitsCreateWithoutUserInput = {
    id?: string
    url: string
    createdAt?: Date | string
    brand?: brandsCreateNestedOneWithoutLinkVisitsInput
    product?: productsCreateNestedOneWithoutLinkVisitsInput
    benefit?: benefitsCreateNestedOneWithoutLinkVisitsInput
  }

  export type link_visitsUncheckedCreateWithoutUserInput = {
    id?: string
    url: string
    brandId?: string | null
    productId?: string | null
    benefitId?: string | null
    createdAt?: Date | string
  }

  export type link_visitsCreateOrConnectWithoutUserInput = {
    where: link_visitsWhereUniqueInput
    create: XOR<link_visitsCreateWithoutUserInput, link_visitsUncheckedCreateWithoutUserInput>
  }

  export type link_visitsCreateManyUserInputEnvelope = {
    data: link_visitsCreateManyUserInput | link_visitsCreateManyUserInput[]
  }

  export type brand_screen_timesCreateWithoutUserInput = {
    id?: string
    time: number
    createdAt?: Date | string
    brand?: brandsCreateNestedOneWithoutBrandScreenTimesInput
  }

  export type brand_screen_timesUncheckedCreateWithoutUserInput = {
    id?: string
    time: number
    brandId?: string | null
    createdAt?: Date | string
  }

  export type brand_screen_timesCreateOrConnectWithoutUserInput = {
    where: brand_screen_timesWhereUniqueInput
    create: XOR<brand_screen_timesCreateWithoutUserInput, brand_screen_timesUncheckedCreateWithoutUserInput>
  }

  export type brand_screen_timesCreateManyUserInputEnvelope = {
    data: brand_screen_timesCreateManyUserInput | brand_screen_timesCreateManyUserInput[]
  }

  export type terms_and_conditionsCreateWithoutUserInput = {
    id?: string
    userEmailAddress: string
    acceptanceDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type terms_and_conditionsUncheckedCreateWithoutUserInput = {
    id?: string
    userEmailAddress: string
    acceptanceDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type terms_and_conditionsCreateOrConnectWithoutUserInput = {
    where: terms_and_conditionsWhereUniqueInput
    create: XOR<terms_and_conditionsCreateWithoutUserInput, terms_and_conditionsUncheckedCreateWithoutUserInput>
  }

  export type feedbackCreateWithoutUserInput = {
    id?: string
    text: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbackUncheckedCreateWithoutUserInput = {
    id?: string
    text: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbackCreateOrConnectWithoutUserInput = {
    where: feedbackWhereUniqueInput
    create: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput>
  }

  export type feedbackCreateManyUserInputEnvelope = {
    data: feedbackCreateManyUserInput | feedbackCreateManyUserInput[]
  }

  export type levelsCreateWithoutUsersInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questionnaire?: questionnairesCreateNestedOneWithoutLevelInput
    benefits?: benefitsCreateNestedManyWithoutLevelInput
  }

  export type levelsUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    order: number
    requiredBrandsExplored: number
    requiredAnswers: number
    questionnaireId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    benefits?: benefitsUncheckedCreateNestedManyWithoutLevelInput
  }

  export type levelsCreateOrConnectWithoutUsersInput = {
    where: levelsWhereUniqueInput
    create: XOR<levelsCreateWithoutUsersInput, levelsUncheckedCreateWithoutUsersInput>
  }

  export type brandsCreateWithoutOwnerInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutOwnerInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    dealCodeGroups?: deal_code_groupsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutOwnerInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutOwnerInput, brandsUncheckedCreateWithoutOwnerInput>
  }

  export type production_submissionsCreateWithoutUserInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutProductionSubmissionsInput
  }

  export type production_submissionsUncheckedCreateWithoutUserInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brandId: string
  }

  export type production_submissionsCreateOrConnectWithoutUserInput = {
    where: production_submissionsWhereUniqueInput
    create: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput>
  }

  export type production_submissionsCreateManyUserInputEnvelope = {
    data: production_submissionsCreateManyUserInput | production_submissionsCreateManyUserInput[]
  }

  export type foundersReachedLeaderboardCreateWithoutUsersInput = {
    id?: string
    amount: number
  }

  export type foundersReachedLeaderboardUncheckedCreateWithoutUsersInput = {
    id?: string
    amount: number
  }

  export type foundersReachedLeaderboardCreateOrConnectWithoutUsersInput = {
    where: foundersReachedLeaderboardWhereUniqueInput
    create: XOR<foundersReachedLeaderboardCreateWithoutUsersInput, foundersReachedLeaderboardUncheckedCreateWithoutUsersInput>
  }

  export type deal_codesCreateWithoutUserInput = {
    id?: string
    code: string
    isUsed?: boolean
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    group: deal_code_groupsCreateNestedOneWithoutDealCodesInput
  }

  export type deal_codesUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    isUsed?: boolean
    groupId: string
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deal_codesCreateOrConnectWithoutUserInput = {
    where: deal_codesWhereUniqueInput
    create: XOR<deal_codesCreateWithoutUserInput, deal_codesUncheckedCreateWithoutUserInput>
  }

  export type deal_codesCreateManyUserInputEnvelope = {
    data: deal_codesCreateManyUserInput | deal_codesCreateManyUserInput[]
  }

  export type unlocked_brands_historyCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    brand?: brandsCreateNestedOneWithoutUnlockHistoryInput
  }

  export type unlocked_brands_historyUncheckedCreateWithoutUserInput = {
    id?: string
    brandId?: string | null
    createdAt?: Date | string
  }

  export type unlocked_brands_historyCreateOrConnectWithoutUserInput = {
    where: unlocked_brands_historyWhereUniqueInput
    create: XOR<unlocked_brands_historyCreateWithoutUserInput, unlocked_brands_historyUncheckedCreateWithoutUserInput>
  }

  export type unlocked_brands_historyCreateManyUserInputEnvelope = {
    data: unlocked_brands_historyCreateManyUserInput | unlocked_brands_historyCreateManyUserInput[]
  }

  export type category_choicesCreateWithoutUserInput = {
    id?: string
    like: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: categoriesCreateNestedOneWithoutUserChoicesInput
  }

  export type category_choicesUncheckedCreateWithoutUserInput = {
    id?: string
    like: boolean
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type category_choicesCreateOrConnectWithoutUserInput = {
    where: category_choicesWhereUniqueInput
    create: XOR<category_choicesCreateWithoutUserInput, category_choicesUncheckedCreateWithoutUserInput>
  }

  export type category_choicesCreateManyUserInputEnvelope = {
    data: category_choicesCreateManyUserInput | category_choicesCreateManyUserInput[]
  }

  export type postsCreateWithoutUserLikesInput = {
    id?: string
    title: string
    author?: string | null
    content?: string | null
    video?: string | null
    image?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brand?: brandsCreateNestedOneWithoutPostsInput
  }

  export type postsUncheckedCreateWithoutUserLikesInput = {
    id?: string
    title: string
    author?: string | null
    content?: string | null
    video?: string | null
    image?: InputJsonValue | null
    brandId?: string | null
    userLikesIds?: postsCreateuserLikesIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type postsCreateOrConnectWithoutUserLikesInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutUserLikesInput, postsUncheckedCreateWithoutUserLikesInput>
  }

  export type push_notification_historyCreateWithoutUserInput = {
    id?: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type push_notification_historyUncheckedCreateWithoutUserInput = {
    id?: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type push_notification_historyCreateOrConnectWithoutUserInput = {
    where: push_notification_historyWhereUniqueInput
    create: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput>
  }

  export type push_notification_historyCreateManyUserInputEnvelope = {
    data: push_notification_historyCreateManyUserInput | push_notification_historyCreateManyUserInput[]
  }

  export type answersUpsertWithWhereUniqueWithoutUserInput = {
    where: answersWhereUniqueInput
    update: XOR<answersUpdateWithoutUserInput, answersUncheckedUpdateWithoutUserInput>
    create: XOR<answersCreateWithoutUserInput, answersUncheckedCreateWithoutUserInput>
  }

  export type answersUpdateWithWhereUniqueWithoutUserInput = {
    where: answersWhereUniqueInput
    data: XOR<answersUpdateWithoutUserInput, answersUncheckedUpdateWithoutUserInput>
  }

  export type answersUpdateManyWithWhereWithoutUserInput = {
    where: answersScalarWhereInput
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyWithoutUserInput>
  }

  export type pitch_viewsUpsertWithWhereUniqueWithoutUserInput = {
    where: pitch_viewsWhereUniqueInput
    update: XOR<pitch_viewsUpdateWithoutUserInput, pitch_viewsUncheckedUpdateWithoutUserInput>
    create: XOR<pitch_viewsCreateWithoutUserInput, pitch_viewsUncheckedCreateWithoutUserInput>
  }

  export type pitch_viewsUpdateWithWhereUniqueWithoutUserInput = {
    where: pitch_viewsWhereUniqueInput
    data: XOR<pitch_viewsUpdateWithoutUserInput, pitch_viewsUncheckedUpdateWithoutUserInput>
  }

  export type pitch_viewsUpdateManyWithWhereWithoutUserInput = {
    where: pitch_viewsScalarWhereInput
    data: XOR<pitch_viewsUpdateManyMutationInput, pitch_viewsUncheckedUpdateManyWithoutUserInput>
  }

  export type settingsUpsertWithoutUserInput = {
    update: XOR<settingsUpdateWithoutUserInput, settingsUncheckedUpdateWithoutUserInput>
    create: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    where?: settingsWhereInput
  }

  export type settingsUpdateToOneWithWhereWithoutUserInput = {
    where?: settingsWhereInput
    data: XOR<settingsUpdateWithoutUserInput, settingsUncheckedUpdateWithoutUserInput>
  }

  export type settingsUpdateWithoutUserInput = {
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    newBrands?: BoolFieldUpdateOperationsInput | boolean
    personalizedOffers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsUncheckedUpdateWithoutUserInput = {
    receiveNotifications?: BoolFieldUpdateOperationsInput | boolean
    newBrands?: BoolFieldUpdateOperationsInput | boolean
    personalizedOffers?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUpsertWithWhereUniqueWithoutUserInput = {
    where: ratingsWhereUniqueInput
    update: XOR<ratingsUpdateWithoutUserInput, ratingsUncheckedUpdateWithoutUserInput>
    create: XOR<ratingsCreateWithoutUserInput, ratingsUncheckedCreateWithoutUserInput>
  }

  export type ratingsUpdateWithWhereUniqueWithoutUserInput = {
    where: ratingsWhereUniqueInput
    data: XOR<ratingsUpdateWithoutUserInput, ratingsUncheckedUpdateWithoutUserInput>
  }

  export type ratingsUpdateManyWithWhereWithoutUserInput = {
    where: ratingsScalarWhereInput
    data: XOR<ratingsUpdateManyMutationInput, ratingsUncheckedUpdateManyWithoutUserInput>
  }

  export type brandsUpsertWithWhereUniqueWithoutUsersForYouInput = {
    where: brandsWhereUniqueInput
    update: XOR<brandsUpdateWithoutUsersForYouInput, brandsUncheckedUpdateWithoutUsersForYouInput>
    create: XOR<brandsCreateWithoutUsersForYouInput, brandsUncheckedCreateWithoutUsersForYouInput>
  }

  export type brandsUpdateWithWhereUniqueWithoutUsersForYouInput = {
    where: brandsWhereUniqueInput
    data: XOR<brandsUpdateWithoutUsersForYouInput, brandsUncheckedUpdateWithoutUsersForYouInput>
  }

  export type brandsUpdateManyWithWhereWithoutUsersForYouInput = {
    where: brandsScalarWhereInput
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyWithoutUsersForYouInput>
  }

  export type brandsUpsertWithWhereUniqueWithoutUsersForYouPoolInput = {
    where: brandsWhereUniqueInput
    update: XOR<brandsUpdateWithoutUsersForYouPoolInput, brandsUncheckedUpdateWithoutUsersForYouPoolInput>
    create: XOR<brandsCreateWithoutUsersForYouPoolInput, brandsUncheckedCreateWithoutUsersForYouPoolInput>
  }

  export type brandsUpdateWithWhereUniqueWithoutUsersForYouPoolInput = {
    where: brandsWhereUniqueInput
    data: XOR<brandsUpdateWithoutUsersForYouPoolInput, brandsUncheckedUpdateWithoutUsersForYouPoolInput>
  }

  export type brandsUpdateManyWithWhereWithoutUsersForYouPoolInput = {
    where: brandsScalarWhereInput
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyWithoutUsersForYouPoolInput>
  }

  export type brandsUpsertWithWhereUniqueWithoutUsersNotInterestedBrandsInput = {
    where: brandsWhereUniqueInput
    update: XOR<brandsUpdateWithoutUsersNotInterestedBrandsInput, brandsUncheckedUpdateWithoutUsersNotInterestedBrandsInput>
    create: XOR<brandsCreateWithoutUsersNotInterestedBrandsInput, brandsUncheckedCreateWithoutUsersNotInterestedBrandsInput>
  }

  export type brandsUpdateWithWhereUniqueWithoutUsersNotInterestedBrandsInput = {
    where: brandsWhereUniqueInput
    data: XOR<brandsUpdateWithoutUsersNotInterestedBrandsInput, brandsUncheckedUpdateWithoutUsersNotInterestedBrandsInput>
  }

  export type brandsUpdateManyWithWhereWithoutUsersNotInterestedBrandsInput = {
    where: brandsScalarWhereInput
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsInput>
  }

  export type link_visitsUpsertWithWhereUniqueWithoutUserInput = {
    where: link_visitsWhereUniqueInput
    update: XOR<link_visitsUpdateWithoutUserInput, link_visitsUncheckedUpdateWithoutUserInput>
    create: XOR<link_visitsCreateWithoutUserInput, link_visitsUncheckedCreateWithoutUserInput>
  }

  export type link_visitsUpdateWithWhereUniqueWithoutUserInput = {
    where: link_visitsWhereUniqueInput
    data: XOR<link_visitsUpdateWithoutUserInput, link_visitsUncheckedUpdateWithoutUserInput>
  }

  export type link_visitsUpdateManyWithWhereWithoutUserInput = {
    where: link_visitsScalarWhereInput
    data: XOR<link_visitsUpdateManyMutationInput, link_visitsUncheckedUpdateManyWithoutUserInput>
  }

  export type brand_screen_timesUpsertWithWhereUniqueWithoutUserInput = {
    where: brand_screen_timesWhereUniqueInput
    update: XOR<brand_screen_timesUpdateWithoutUserInput, brand_screen_timesUncheckedUpdateWithoutUserInput>
    create: XOR<brand_screen_timesCreateWithoutUserInput, brand_screen_timesUncheckedCreateWithoutUserInput>
  }

  export type brand_screen_timesUpdateWithWhereUniqueWithoutUserInput = {
    where: brand_screen_timesWhereUniqueInput
    data: XOR<brand_screen_timesUpdateWithoutUserInput, brand_screen_timesUncheckedUpdateWithoutUserInput>
  }

  export type brand_screen_timesUpdateManyWithWhereWithoutUserInput = {
    where: brand_screen_timesScalarWhereInput
    data: XOR<brand_screen_timesUpdateManyMutationInput, brand_screen_timesUncheckedUpdateManyWithoutUserInput>
  }

  export type terms_and_conditionsUpsertWithoutUserInput = {
    update: XOR<terms_and_conditionsUpdateWithoutUserInput, terms_and_conditionsUncheckedUpdateWithoutUserInput>
    create: XOR<terms_and_conditionsCreateWithoutUserInput, terms_and_conditionsUncheckedCreateWithoutUserInput>
    where?: terms_and_conditionsWhereInput
  }

  export type terms_and_conditionsUpdateToOneWithWhereWithoutUserInput = {
    where?: terms_and_conditionsWhereInput
    data: XOR<terms_and_conditionsUpdateWithoutUserInput, terms_and_conditionsUncheckedUpdateWithoutUserInput>
  }

  export type terms_and_conditionsUpdateWithoutUserInput = {
    userEmailAddress?: StringFieldUpdateOperationsInput | string
    acceptanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type terms_and_conditionsUncheckedUpdateWithoutUserInput = {
    userEmailAddress?: StringFieldUpdateOperationsInput | string
    acceptanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: feedbackWhereUniqueInput
    update: XOR<feedbackUpdateWithoutUserInput, feedbackUncheckedUpdateWithoutUserInput>
    create: XOR<feedbackCreateWithoutUserInput, feedbackUncheckedCreateWithoutUserInput>
  }

  export type feedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: feedbackWhereUniqueInput
    data: XOR<feedbackUpdateWithoutUserInput, feedbackUncheckedUpdateWithoutUserInput>
  }

  export type feedbackUpdateManyWithWhereWithoutUserInput = {
    where: feedbackScalarWhereInput
    data: XOR<feedbackUpdateManyMutationInput, feedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type feedbackScalarWhereInput = {
    AND?: feedbackScalarWhereInput | feedbackScalarWhereInput[]
    OR?: feedbackScalarWhereInput[]
    NOT?: feedbackScalarWhereInput | feedbackScalarWhereInput[]
    id?: StringFilter<"feedback"> | string
    userId?: StringFilter<"feedback"> | string
    text?: StringFilter<"feedback"> | string
    email?: StringNullableFilter<"feedback"> | string | null
    createdAt?: DateTimeFilter<"feedback"> | Date | string
    updatedAt?: DateTimeFilter<"feedback"> | Date | string
  }

  export type levelsUpsertWithoutUsersInput = {
    update: XOR<levelsUpdateWithoutUsersInput, levelsUncheckedUpdateWithoutUsersInput>
    create: XOR<levelsCreateWithoutUsersInput, levelsUncheckedCreateWithoutUsersInput>
    where?: levelsWhereInput
  }

  export type levelsUpdateToOneWithWhereWithoutUsersInput = {
    where?: levelsWhereInput
    data: XOR<levelsUpdateWithoutUsersInput, levelsUncheckedUpdateWithoutUsersInput>
  }

  export type levelsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionnaire?: questionnairesUpdateOneWithoutLevelNestedInput
    benefits?: benefitsUpdateManyWithoutLevelNestedInput
  }

  export type levelsUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    requiredBrandsExplored?: IntFieldUpdateOperationsInput | number
    requiredAnswers?: IntFieldUpdateOperationsInput | number
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: benefitsUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type brandsUpsertWithoutOwnerInput = {
    update: XOR<brandsUpdateWithoutOwnerInput, brandsUncheckedUpdateWithoutOwnerInput>
    create: XOR<brandsCreateWithoutOwnerInput, brandsUncheckedCreateWithoutOwnerInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutOwnerInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutOwnerInput, brandsUncheckedUpdateWithoutOwnerInput>
  }

  export type brandsUpdateWithoutOwnerInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutOwnerInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type production_submissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: production_submissionsWhereUniqueInput
    update: XOR<production_submissionsUpdateWithoutUserInput, production_submissionsUncheckedUpdateWithoutUserInput>
    create: XOR<production_submissionsCreateWithoutUserInput, production_submissionsUncheckedCreateWithoutUserInput>
  }

  export type production_submissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: production_submissionsWhereUniqueInput
    data: XOR<production_submissionsUpdateWithoutUserInput, production_submissionsUncheckedUpdateWithoutUserInput>
  }

  export type production_submissionsUpdateManyWithWhereWithoutUserInput = {
    where: production_submissionsScalarWhereInput
    data: XOR<production_submissionsUpdateManyMutationInput, production_submissionsUncheckedUpdateManyWithoutUserInput>
  }

  export type foundersReachedLeaderboardUpsertWithoutUsersInput = {
    update: XOR<foundersReachedLeaderboardUpdateWithoutUsersInput, foundersReachedLeaderboardUncheckedUpdateWithoutUsersInput>
    create: XOR<foundersReachedLeaderboardCreateWithoutUsersInput, foundersReachedLeaderboardUncheckedCreateWithoutUsersInput>
    where?: foundersReachedLeaderboardWhereInput
  }

  export type foundersReachedLeaderboardUpdateToOneWithWhereWithoutUsersInput = {
    where?: foundersReachedLeaderboardWhereInput
    data: XOR<foundersReachedLeaderboardUpdateWithoutUsersInput, foundersReachedLeaderboardUncheckedUpdateWithoutUsersInput>
  }

  export type foundersReachedLeaderboardUpdateWithoutUsersInput = {
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type foundersReachedLeaderboardUncheckedUpdateWithoutUsersInput = {
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type deal_codesUpsertWithWhereUniqueWithoutUserInput = {
    where: deal_codesWhereUniqueInput
    update: XOR<deal_codesUpdateWithoutUserInput, deal_codesUncheckedUpdateWithoutUserInput>
    create: XOR<deal_codesCreateWithoutUserInput, deal_codesUncheckedCreateWithoutUserInput>
  }

  export type deal_codesUpdateWithWhereUniqueWithoutUserInput = {
    where: deal_codesWhereUniqueInput
    data: XOR<deal_codesUpdateWithoutUserInput, deal_codesUncheckedUpdateWithoutUserInput>
  }

  export type deal_codesUpdateManyWithWhereWithoutUserInput = {
    where: deal_codesScalarWhereInput
    data: XOR<deal_codesUpdateManyMutationInput, deal_codesUncheckedUpdateManyWithoutUserInput>
  }

  export type deal_codesScalarWhereInput = {
    AND?: deal_codesScalarWhereInput | deal_codesScalarWhereInput[]
    OR?: deal_codesScalarWhereInput[]
    NOT?: deal_codesScalarWhereInput | deal_codesScalarWhereInput[]
    id?: StringFilter<"deal_codes"> | string
    code?: StringFilter<"deal_codes"> | string
    isUsed?: BoolFilter<"deal_codes"> | boolean
    userId?: StringNullableFilter<"deal_codes"> | string | null
    groupId?: StringFilter<"deal_codes"> | string
    userExpireDate?: DateTimeNullableFilter<"deal_codes"> | Date | string | null
    unlockedAt?: DateTimeNullableFilter<"deal_codes"> | Date | string | null
    createdAt?: DateTimeFilter<"deal_codes"> | Date | string
    updatedAt?: DateTimeFilter<"deal_codes"> | Date | string
  }

  export type unlocked_brands_historyUpsertWithWhereUniqueWithoutUserInput = {
    where: unlocked_brands_historyWhereUniqueInput
    update: XOR<unlocked_brands_historyUpdateWithoutUserInput, unlocked_brands_historyUncheckedUpdateWithoutUserInput>
    create: XOR<unlocked_brands_historyCreateWithoutUserInput, unlocked_brands_historyUncheckedCreateWithoutUserInput>
  }

  export type unlocked_brands_historyUpdateWithWhereUniqueWithoutUserInput = {
    where: unlocked_brands_historyWhereUniqueInput
    data: XOR<unlocked_brands_historyUpdateWithoutUserInput, unlocked_brands_historyUncheckedUpdateWithoutUserInput>
  }

  export type unlocked_brands_historyUpdateManyWithWhereWithoutUserInput = {
    where: unlocked_brands_historyScalarWhereInput
    data: XOR<unlocked_brands_historyUpdateManyMutationInput, unlocked_brands_historyUncheckedUpdateManyWithoutUserInput>
  }

  export type category_choicesUpsertWithWhereUniqueWithoutUserInput = {
    where: category_choicesWhereUniqueInput
    update: XOR<category_choicesUpdateWithoutUserInput, category_choicesUncheckedUpdateWithoutUserInput>
    create: XOR<category_choicesCreateWithoutUserInput, category_choicesUncheckedCreateWithoutUserInput>
  }

  export type category_choicesUpdateWithWhereUniqueWithoutUserInput = {
    where: category_choicesWhereUniqueInput
    data: XOR<category_choicesUpdateWithoutUserInput, category_choicesUncheckedUpdateWithoutUserInput>
  }

  export type category_choicesUpdateManyWithWhereWithoutUserInput = {
    where: category_choicesScalarWhereInput
    data: XOR<category_choicesUpdateManyMutationInput, category_choicesUncheckedUpdateManyWithoutUserInput>
  }

  export type postsUpsertWithWhereUniqueWithoutUserLikesInput = {
    where: postsWhereUniqueInput
    update: XOR<postsUpdateWithoutUserLikesInput, postsUncheckedUpdateWithoutUserLikesInput>
    create: XOR<postsCreateWithoutUserLikesInput, postsUncheckedCreateWithoutUserLikesInput>
  }

  export type postsUpdateWithWhereUniqueWithoutUserLikesInput = {
    where: postsWhereUniqueInput
    data: XOR<postsUpdateWithoutUserLikesInput, postsUncheckedUpdateWithoutUserLikesInput>
  }

  export type postsUpdateManyWithWhereWithoutUserLikesInput = {
    where: postsScalarWhereInput
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutUserLikesInput>
  }

  export type push_notification_historyUpsertWithWhereUniqueWithoutUserInput = {
    where: push_notification_historyWhereUniqueInput
    update: XOR<push_notification_historyUpdateWithoutUserInput, push_notification_historyUncheckedUpdateWithoutUserInput>
    create: XOR<push_notification_historyCreateWithoutUserInput, push_notification_historyUncheckedCreateWithoutUserInput>
  }

  export type push_notification_historyUpdateWithWhereUniqueWithoutUserInput = {
    where: push_notification_historyWhereUniqueInput
    data: XOR<push_notification_historyUpdateWithoutUserInput, push_notification_historyUncheckedUpdateWithoutUserInput>
  }

  export type push_notification_historyUpdateManyWithWhereWithoutUserInput = {
    where: push_notification_historyScalarWhereInput
    data: XOR<push_notification_historyUpdateManyMutationInput, push_notification_historyUncheckedUpdateManyWithoutUserInput>
  }

  export type push_notification_historyScalarWhereInput = {
    AND?: push_notification_historyScalarWhereInput | push_notification_historyScalarWhereInput[]
    OR?: push_notification_historyScalarWhereInput[]
    NOT?: push_notification_historyScalarWhereInput | push_notification_historyScalarWhereInput[]
    id?: StringFilter<"push_notification_history"> | string
    userId?: StringFilter<"push_notification_history"> | string
    type?: EnumNotificationTypeNullableFilter<"push_notification_history"> | $Enums.NotificationType | null
    entityId?: StringNullableFilter<"push_notification_history"> | string | null
    content?: StringFilter<"push_notification_history"> | string
    title?: StringFilter<"push_notification_history"> | string
    sentAt?: DateTimeFilter<"push_notification_history"> | Date | string
  }

  export type usersCreateWithoutDealCodesInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    brandsExplored: number
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    lastOpened?: Date | string | null
    answers?: answersCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    ratings?: ratingsCreateNestedManyWithoutUserInput
    forYouBrands?: brandsCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsCreateNestedOneWithoutUserInput
    feedbacks?: feedbackCreateNestedManyWithoutUserInput
    level?: levelsCreateNestedOneWithoutUsersInput
    ownedBrand?: brandsCreateNestedOneWithoutOwnerInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutUserInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardCreateNestedOneWithoutUsersInput
    brandUnlockHistory?: unlocked_brands_historyCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesCreateNestedManyWithoutUserInput
    likedPosts?: postsCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutDealCodesInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
    answers?: answersUncheckedCreateNestedManyWithoutUserInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutUserInput
    forYouBrands?: brandsUncheckedCreateNestedManyWithoutUsersForYouInput
    forYouBrandsPool?: brandsUncheckedCreateNestedManyWithoutUsersForYouPoolInput
    notInterestedBrands?: brandsUncheckedCreateNestedManyWithoutUsersNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutUserInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutUserInput
    termsAndConditions?: terms_and_conditionsUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: feedbackUncheckedCreateNestedManyWithoutUserInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutUserInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutUserInput
    categoryChoices?: category_choicesUncheckedCreateNestedManyWithoutUserInput
    likedPosts?: postsUncheckedCreateNestedManyWithoutUserLikesInput
    pushNotificationHistory?: push_notification_historyUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutDealCodesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDealCodesInput, usersUncheckedCreateWithoutDealCodesInput>
  }

  export type deal_code_groupsCreateWithoutDealCodesInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    codesState?: string | null
    generalExpireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutDealCodeGroupsInput
  }

  export type deal_code_groupsUncheckedCreateWithoutDealCodesInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    codesState?: string | null
    brandId: string
    generalExpireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deal_code_groupsCreateOrConnectWithoutDealCodesInput = {
    where: deal_code_groupsWhereUniqueInput
    create: XOR<deal_code_groupsCreateWithoutDealCodesInput, deal_code_groupsUncheckedCreateWithoutDealCodesInput>
  }

  export type usersUpsertWithoutDealCodesInput = {
    update: XOR<usersUpdateWithoutDealCodesInput, usersUncheckedUpdateWithoutDealCodesInput>
    create: XOR<usersCreateWithoutDealCodesInput, usersUncheckedCreateWithoutDealCodesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDealCodesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDealCodesInput, usersUncheckedUpdateWithoutDealCodesInput>
  }

  export type usersUpdateWithoutDealCodesInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutDealCodesInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type deal_code_groupsUpsertWithoutDealCodesInput = {
    update: XOR<deal_code_groupsUpdateWithoutDealCodesInput, deal_code_groupsUncheckedUpdateWithoutDealCodesInput>
    create: XOR<deal_code_groupsCreateWithoutDealCodesInput, deal_code_groupsUncheckedCreateWithoutDealCodesInput>
    where?: deal_code_groupsWhereInput
  }

  export type deal_code_groupsUpdateToOneWithWhereWithoutDealCodesInput = {
    where?: deal_code_groupsWhereInput
    data: XOR<deal_code_groupsUpdateWithoutDealCodesInput, deal_code_groupsUncheckedUpdateWithoutDealCodesInput>
  }

  export type deal_code_groupsUpdateWithoutDealCodesInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutDealCodeGroupsNestedInput
  }

  export type deal_code_groupsUncheckedUpdateWithoutDealCodesInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsCreateWithoutDealCodeGroupsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsCreateNestedManyWithoutBrandInput
    products?: productsCreateNestedManyWithoutBrandInput
    category?: categoriesCreateNestedOneWithoutBrandsInput
    ratings?: ratingsCreateNestedManyWithoutBrandInput
    usersForYou?: usersCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsCreateNestedManyWithoutBrandInput
    owner?: usersCreateNestedOneWithoutOwnedBrandInput
    posts?: postsCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsUncheckedCreateWithoutDealCodeGroupsInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    categoryId?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
    pitchQuestions?: questionsUncheckedCreateNestedManyWithoutBrandInput
    pitchViews?: pitch_viewsUncheckedCreateNestedManyWithoutBrandInput
    products?: productsUncheckedCreateNestedManyWithoutBrandInput
    ratings?: ratingsUncheckedCreateNestedManyWithoutBrandInput
    usersForYou?: usersUncheckedCreateNestedManyWithoutForYouBrandsInput
    usersForYouPool?: usersUncheckedCreateNestedManyWithoutForYouBrandsPoolInput
    usersNotInterestedBrands?: usersUncheckedCreateNestedManyWithoutNotInterestedBrandsInput
    linkVisits?: link_visitsUncheckedCreateNestedManyWithoutBrandInput
    brandScreenTimes?: brand_screen_timesUncheckedCreateNestedManyWithoutBrandInput
    productionSubmissions?: production_submissionsUncheckedCreateNestedManyWithoutBrandInput
    owner?: usersUncheckedCreateNestedOneWithoutOwnedBrandInput
    posts?: postsUncheckedCreateNestedManyWithoutBrandInput
    unlockHistory?: unlocked_brands_historyUncheckedCreateNestedManyWithoutBrandInput
    pitchExitBrandAnswers?: answersUncheckedCreateNestedManyWithoutPitchExitBrandInput
    productFeedbackAnswers?: answersUncheckedCreateNestedManyWithoutProductFeedbackBrandInput
  }

  export type brandsCreateOrConnectWithoutDealCodeGroupsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutDealCodeGroupsInput, brandsUncheckedCreateWithoutDealCodeGroupsInput>
  }

  export type deal_codesCreateWithoutGroupInput = {
    id?: string
    code: string
    isUsed?: boolean
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: usersCreateNestedOneWithoutDealCodesInput
  }

  export type deal_codesUncheckedCreateWithoutGroupInput = {
    id?: string
    code: string
    isUsed?: boolean
    userId?: string | null
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deal_codesCreateOrConnectWithoutGroupInput = {
    where: deal_codesWhereUniqueInput
    create: XOR<deal_codesCreateWithoutGroupInput, deal_codesUncheckedCreateWithoutGroupInput>
  }

  export type deal_codesCreateManyGroupInputEnvelope = {
    data: deal_codesCreateManyGroupInput | deal_codesCreateManyGroupInput[]
  }

  export type brandsUpsertWithoutDealCodeGroupsInput = {
    update: XOR<brandsUpdateWithoutDealCodeGroupsInput, brandsUncheckedUpdateWithoutDealCodeGroupsInput>
    create: XOR<brandsCreateWithoutDealCodeGroupsInput, brandsUncheckedCreateWithoutDealCodeGroupsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutDealCodeGroupsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutDealCodeGroupsInput, brandsUncheckedUpdateWithoutDealCodeGroupsInput>
  }

  export type brandsUpdateWithoutDealCodeGroupsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutDealCodeGroupsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type deal_codesUpsertWithWhereUniqueWithoutGroupInput = {
    where: deal_codesWhereUniqueInput
    update: XOR<deal_codesUpdateWithoutGroupInput, deal_codesUncheckedUpdateWithoutGroupInput>
    create: XOR<deal_codesCreateWithoutGroupInput, deal_codesUncheckedCreateWithoutGroupInput>
  }

  export type deal_codesUpdateWithWhereUniqueWithoutGroupInput = {
    where: deal_codesWhereUniqueInput
    data: XOR<deal_codesUpdateWithoutGroupInput, deal_codesUncheckedUpdateWithoutGroupInput>
  }

  export type deal_codesUpdateManyWithWhereWithoutGroupInput = {
    where: deal_codesScalarWhereInput
    data: XOR<deal_codesUpdateManyMutationInput, deal_codesUncheckedUpdateManyWithoutGroupInput>
  }

  export type link_visitsCreateManyBenefitInput = {
    id?: string
    url: string
    userId: string
    brandId?: string | null
    productId?: string | null
    createdAt?: Date | string
  }

  export type link_visitsUpdateWithoutBenefitInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutLinkVisitsNestedInput
    brand?: brandsUpdateOneWithoutLinkVisitsNestedInput
    product?: productsUpdateOneWithoutLinkVisitsNestedInput
  }

  export type link_visitsUncheckedUpdateWithoutBenefitInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsUncheckedUpdateManyWithoutBenefitInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionsCreateManyBrandInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type pitch_viewsCreateManyBrandInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type productsCreateManyBrandInput = {
    id?: string
    description?: InputJsonValue | null
    images?: productsCreateimagesInput | InputJsonValue[]
    regularPrice?: string | null
    deal?: string | null
    dealPrice?: string | null
    purchaseUrl?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueDeal?: boolean | null
  }

  export type ratingsCreateManyBrandInput = {
    id?: string
    userId: string
    productId?: string | null
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type link_visitsCreateManyBrandInput = {
    id?: string
    url: string
    userId: string
    productId?: string | null
    benefitId?: string | null
    createdAt?: Date | string
  }

  export type brand_screen_timesCreateManyBrandInput = {
    id?: string
    time: number
    userId: string
    createdAt?: Date | string
  }

  export type production_submissionsCreateManyBrandInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type postsCreateManyBrandInput = {
    id?: string
    title: string
    author?: string | null
    content?: string | null
    video?: string | null
    image?: InputJsonValue | null
    userLikesIds?: postsCreateuserLikesIdsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deal_code_groupsCreateManyBrandInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    codesState?: string | null
    generalExpireDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type unlocked_brands_historyCreateManyBrandInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type answersCreateManyPitchExitBrandInput = {
    id?: string
    userId: string
    questionId?: string | null
    questionText: InputJsonValue
    answer: InputJsonValue
    productFeedbackBrandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answersCreateManyProductFeedbackBrandInput = {
    id?: string
    userId: string
    questionId?: string | null
    questionText: InputJsonValue
    answer: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    pitchExitBrandId?: string | null
  }

  export type questionsUpdateWithoutBrandInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    questionClass?: question_classesUpdateOneWithoutQuestionsNestedInput
    answers?: answersUpdateManyWithoutQuestionNestedInput
    questionnaire?: questionnairesUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutBrandInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutBrandInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pitch_viewsUpdateWithoutBrandInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutPitchViewsNestedInput
  }

  export type pitch_viewsUncheckedUpdateWithoutBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pitch_viewsUncheckedUpdateManyWithoutBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsUpdateWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUpdateManyWithoutProductNestedInput
    ratings?: ratingsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    linkVisits?: link_visitsUncheckedUpdateManyWithoutProductNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateManyWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue | null
    images?: productsUpdateimagesInput | InputJsonValue[]
    regularPrice?: NullableStringFieldUpdateOperationsInput | string | null
    deal?: NullableStringFieldUpdateOperationsInput | string | null
    dealPrice?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueDeal?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ratingsUpdateWithoutBrandInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutRatingsNestedInput
    product?: productsUpdateOneWithoutRatingsNestedInput
  }

  export type ratingsUncheckedUpdateWithoutBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateManyWithoutBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutForYouBrandsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutForYouBrandsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutForYouBrandsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpdateWithoutForYouBrandsPoolInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutForYouBrandsPoolInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutForYouBrandsPoolInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpdateWithoutNotInterestedBrandsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutNotInterestedBrandsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutNotInterestedBrandsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type link_visitsUpdateWithoutBrandInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutLinkVisitsNestedInput
    product?: productsUpdateOneWithoutLinkVisitsNestedInput
    benefit?: benefitsUpdateOneWithoutLinkVisitsNestedInput
  }

  export type link_visitsUncheckedUpdateWithoutBrandInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    benefitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsUncheckedUpdateManyWithoutBrandInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    benefitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brand_screen_timesUpdateWithoutBrandInput = {
    time?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutBrandScreenTimesNestedInput
  }

  export type brand_screen_timesUncheckedUpdateWithoutBrandInput = {
    time?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brand_screen_timesUncheckedUpdateManyWithoutBrandInput = {
    time?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsUpdateWithoutBrandInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutProductionSubmissionsNestedInput
  }

  export type production_submissionsUncheckedUpdateWithoutBrandInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type production_submissionsUncheckedUpdateManyWithoutBrandInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type postsUpdateWithoutBrandInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userLikes?: usersUpdateManyWithoutLikedPostsNestedInput
  }

  export type postsUncheckedUpdateWithoutBrandInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    userLikesIds?: postsUpdateuserLikesIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userLikes?: usersUncheckedUpdateManyWithoutLikedPostsNestedInput
  }

  export type postsUncheckedUpdateManyWithoutBrandInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    userLikesIds?: postsUpdateuserLikesIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deal_code_groupsUpdateWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealCodes?: deal_codesUpdateManyWithoutGroupNestedInput
  }

  export type deal_code_groupsUncheckedUpdateWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealCodes?: deal_codesUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type deal_code_groupsUncheckedUpdateManyWithoutBrandInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    codesState?: NullableStringFieldUpdateOperationsInput | string | null
    generalExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unlocked_brands_historyUpdateWithoutBrandInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutBrandUnlockHistoryNestedInput
  }

  export type unlocked_brands_historyUncheckedUpdateWithoutBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unlocked_brands_historyUncheckedUpdateManyWithoutBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUpdateWithoutPitchExitBrandInput = {
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAnswersNestedInput
    question?: questionsUpdateOneWithoutAnswersNestedInput
    productFeedbackBrand?: brandsUpdateOneWithoutProductFeedbackAnswersNestedInput
  }

  export type answersUncheckedUpdateWithoutPitchExitBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    productFeedbackBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUncheckedUpdateManyWithoutPitchExitBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    productFeedbackBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUpdateWithoutProductFeedbackBrandInput = {
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAnswersNestedInput
    question?: questionsUpdateOneWithoutAnswersNestedInput
    pitchExitBrand?: brandsUpdateOneWithoutPitchExitBrandAnswersNestedInput
  }

  export type answersUncheckedUpdateWithoutProductFeedbackBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pitchExitBrandId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type answersUncheckedUpdateManyWithoutProductFeedbackBrandInput = {
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pitchExitBrandId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type brandsCreateManyCategoryInput = {
    id?: string
    description: InputJsonValue
    shortDescription?: InputJsonValue | null
    name: string
    pitchVideo?: string | null
    pitchCaptions?: InputJsonValue | null
    pitchSections?: InputJsonValue | null
    updatedAt?: Date | string
    brandLogo?: InputJsonValue | null
    email?: string | null
    managerEmail?: string | null
    managerName?: string | null
    managerPhone?: string | null
    labels?: brandsCreatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | null
    website?: string | null
    teaser?: string | null
    mainPhrase?: string | null
    founders?: brandsCreatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | null
    usersForYouIds?: brandsCreateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsCreateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsCreateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsCreateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | null
    selectedFeedback: InputJsonValue
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    shopifyDomain?: string | null
    shopifyKeyName?: string | null
    ledgeRating?: number
    showTeamPictureInRating?: boolean | null
  }

  export type category_choicesCreateManyCategoryInput = {
    id?: string
    like: boolean
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandsUpdateWithoutCategoryInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutCategoryInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateManyWithoutCategoryInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type category_choicesUpdateWithoutCategoryInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutCategoryChoicesNestedInput
  }

  export type category_choicesUncheckedUpdateWithoutCategoryInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_choicesUncheckedUpdateManyWithoutCategoryInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateManyFoundersReachedLeaderboardInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    levelId?: string | null
    brandsExplored: number
    ownedBrandId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
  }

  export type usersUpdateWithoutFoundersReachedLeaderboardInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutFoundersReachedLeaderboardInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutFoundersReachedLeaderboardInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpdateWithoutLikedPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    level?: levelsUpdateOneWithoutUsersNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutLikedPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutLikedPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    levelId?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type link_visitsCreateManyProductInput = {
    id?: string
    url: string
    userId: string
    brandId?: string | null
    benefitId?: string | null
    createdAt?: Date | string
  }

  export type ratingsCreateManyProductInput = {
    id?: string
    userId: string
    brandId: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type link_visitsUpdateWithoutProductInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutLinkVisitsNestedInput
    brand?: brandsUpdateOneWithoutLinkVisitsNestedInput
    benefit?: benefitsUpdateOneWithoutLinkVisitsNestedInput
  }

  export type link_visitsUncheckedUpdateWithoutProductInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    benefitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsUncheckedUpdateManyWithoutProductInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    benefitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUpdateWithoutProductInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutRatingsNestedInput
    brand?: brandsUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ratingsUncheckedUpdateWithoutProductInput = {
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateManyWithoutProductInput = {
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionsCreateManyQuestionnaireInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    classId?: string | null
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type questionsUpdateWithoutQuestionnaireInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    questionClass?: question_classesUpdateOneWithoutQuestionsNestedInput
    answers?: answersUpdateManyWithoutQuestionNestedInput
    brand?: brandsUpdateOneWithoutPitchQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutQuestionnaireInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutQuestionnaireInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questionsCreateManyQuestionClassInput = {
    id?: string
    position: number
    question: InputJsonValue
    type: string
    options?: questionsCreateoptionsInput | InputJsonValue[]
    categoryId?: string | null
    onboarding?: boolean
    randomizeOptions?: boolean | null
    fixedOptionSize?: boolean | null
    hideOptionText?: boolean | null
    displayImage?: InputJsonValue | null
    footnote?: InputJsonValue | null
    subtitle?: InputJsonValue | null
    products?: InputJsonValue | null
    brandId?: string | null
    correctAnswerId?: string | null
    questionnaireId?: string | null
    questionnaireSubCategory?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scaleTopLabel?: InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | null
    maxOptions?: number | null
  }

  export type questionsUpdateWithoutQuestionClassInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUpdateManyWithoutQuestionNestedInput
    brand?: brandsUpdateOneWithoutPitchQuestionsNestedInput
    questionnaire?: questionnairesUpdateOneWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutQuestionClassInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: answersUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionsUncheckedUpdateManyWithoutQuestionClassInput = {
    position?: IntFieldUpdateOperationsInput | number
    question?: InputJsonValue | InputJsonValue
    type?: StringFieldUpdateOperationsInput | string
    options?: questionsUpdateoptionsInput | InputJsonValue[]
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fixedOptionSize?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideOptionText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayImage?: InputJsonValue | InputJsonValue | null
    footnote?: InputJsonValue | InputJsonValue | null
    subtitle?: InputJsonValue | InputJsonValue | null
    products?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireSubCategory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scaleTopLabel?: InputJsonValue | InputJsonValue | null
    scaleBottomLabel?: InputJsonValue | InputJsonValue | null
    maxOptions?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type answersCreateManyQuestionInput = {
    id?: string
    userId: string
    questionText: InputJsonValue
    answer: InputJsonValue
    productFeedbackBrandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pitchExitBrandId?: string | null
  }

  export type answersUpdateWithoutQuestionInput = {
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAnswersNestedInput
    productFeedbackBrand?: brandsUpdateOneWithoutProductFeedbackAnswersNestedInput
    pitchExitBrand?: brandsUpdateOneWithoutPitchExitBrandAnswersNestedInput
  }

  export type answersUncheckedUpdateWithoutQuestionInput = {
    userId?: StringFieldUpdateOperationsInput | string
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    productFeedbackBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pitchExitBrandId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type answersUncheckedUpdateManyWithoutQuestionInput = {
    userId?: StringFieldUpdateOperationsInput | string
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    productFeedbackBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pitchExitBrandId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type benefitsCreateManyLevelInput = {
    id?: string
    title: string
    subtitle: InputJsonValue
    description: InputJsonValue
    logo?: InputJsonValue | null
    image?: InputJsonValue | null
    redeemLink: string
    tags?: benefitsCreatetagsInput | InputJsonValue[]
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersCreateManyLevelInput = {
    id: string
    email: string
    myFavourites?: usersCreatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    notificationsToken?: string | null
    forYouBrandsIds?: usersCreateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersCreateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersCreatenotInterestedBrandsIdsInput | string[]
    brandsExplored: number
    ownedBrandId?: string | null
    foundersReachedLeaderboardId?: string | null
    viewedPitches?: usersCreateviewedPitchesInput | string[]
    targetGender?: $Enums.GenderPreference | null
    budgetInterval?: number | null
    deletedBrands?: usersCreatedeletedBrandsInput | string[]
    superUser?: boolean | null
    hasNewForYouBrands?: boolean
    likedPostsIds?: usersCreatelikedPostsIdsInput | string[]
    lastOpened?: Date | string | null
  }

  export type benefitsUpdateWithoutLevelInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkVisits?: link_visitsUpdateManyWithoutBenefitNestedInput
  }

  export type benefitsUncheckedUpdateWithoutLevelInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBenefitNestedInput
  }

  export type benefitsUncheckedUpdateManyWithoutLevelInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: InputJsonValue | InputJsonValue
    description?: InputJsonValue | InputJsonValue
    logo?: InputJsonValue | InputJsonValue | null
    image?: InputJsonValue | InputJsonValue | null
    redeemLink?: StringFieldUpdateOperationsInput | string
    tags?: benefitsUpdatetagsInput | InputJsonValue[]
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutLevelInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    brandsExplored?: IntFieldUpdateOperationsInput | number
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    ratings?: ratingsUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUpdateManyWithoutUserNestedInput
    ownedBrand?: brandsUpdateOneWithoutOwnerNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutUserNestedInput
    foundersReachedLeaderboard?: foundersReachedLeaderboardUpdateOneWithoutUsersNestedInput
    dealCodes?: deal_codesUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUpdateManyWithoutUserNestedInput
    likedPosts?: postsUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutLevelInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: answersUncheckedUpdateManyWithoutUserNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutUserNestedInput
    forYouBrands?: brandsUncheckedUpdateManyWithoutUsersForYouNestedInput
    forYouBrandsPool?: brandsUncheckedUpdateManyWithoutUsersForYouPoolNestedInput
    notInterestedBrands?: brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutUserNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutUserNestedInput
    termsAndConditions?: terms_and_conditionsUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: feedbackUncheckedUpdateManyWithoutUserNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutUserNestedInput
    dealCodes?: deal_codesUncheckedUpdateManyWithoutUserNestedInput
    brandUnlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutUserNestedInput
    categoryChoices?: category_choicesUncheckedUpdateManyWithoutUserNestedInput
    likedPosts?: postsUncheckedUpdateManyWithoutUserLikesNestedInput
    pushNotificationHistory?: push_notification_historyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutLevelInput = {
    email?: StringFieldUpdateOperationsInput | string
    myFavourites?: usersUpdatemyFavouritesInput | InputJsonValue[]
    hasAcceptedTermsAndConditions?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsToken?: NullableStringFieldUpdateOperationsInput | string | null
    forYouBrandsIds?: usersUpdateforYouBrandsIdsInput | string[]
    forYouBrandsPoolIds?: usersUpdateforYouBrandsPoolIdsInput | string[]
    notInterestedBrandsIds?: usersUpdatenotInterestedBrandsIdsInput | string[]
    brandsExplored?: IntFieldUpdateOperationsInput | number
    ownedBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    foundersReachedLeaderboardId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedPitches?: usersUpdateviewedPitchesInput | string[]
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    deletedBrands?: usersUpdatedeletedBrandsInput | string[]
    superUser?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hasNewForYouBrands?: BoolFieldUpdateOperationsInput | boolean
    likedPostsIds?: usersUpdatelikedPostsIdsInput | string[]
    lastOpened?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type answersCreateManyUserInput = {
    id?: string
    questionId?: string | null
    questionText: InputJsonValue
    answer: InputJsonValue
    productFeedbackBrandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pitchExitBrandId?: string | null
  }

  export type pitch_viewsCreateManyUserInput = {
    id?: string
    brandId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ratingsCreateManyUserInput = {
    id?: string
    productId?: string | null
    brandId: string
    rating: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type link_visitsCreateManyUserInput = {
    id?: string
    url: string
    brandId?: string | null
    productId?: string | null
    benefitId?: string | null
    createdAt?: Date | string
  }

  export type brand_screen_timesCreateManyUserInput = {
    id?: string
    time: number
    brandId?: string | null
    createdAt?: Date | string
  }

  export type feedbackCreateManyUserInput = {
    id?: string
    text: string
    email?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type production_submissionsCreateManyUserInput = {
    id?: string
    overlays?: production_submissionsCreateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsCreatevideosInput | InputJsonValue[]
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brandId: string
  }

  export type deal_codesCreateManyUserInput = {
    id?: string
    code: string
    isUsed?: boolean
    groupId: string
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type unlocked_brands_historyCreateManyUserInput = {
    id?: string
    brandId?: string | null
    createdAt?: Date | string
  }

  export type category_choicesCreateManyUserInput = {
    id?: string
    like: boolean
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type push_notification_historyCreateManyUserInput = {
    id?: string
    type?: $Enums.NotificationType | null
    entityId?: string | null
    content: string
    title: string
    sentAt?: Date | string
  }

  export type answersUpdateWithoutUserInput = {
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: questionsUpdateOneWithoutAnswersNestedInput
    productFeedbackBrand?: brandsUpdateOneWithoutProductFeedbackAnswersNestedInput
    pitchExitBrand?: brandsUpdateOneWithoutPitchExitBrandAnswersNestedInput
  }

  export type answersUncheckedUpdateWithoutUserInput = {
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    productFeedbackBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pitchExitBrandId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type answersUncheckedUpdateManyWithoutUserInput = {
    questionId?: NullableStringFieldUpdateOperationsInput | string | null
    questionText?: InputJsonValue | InputJsonValue
    answer?: InputJsonValue | InputJsonValue
    productFeedbackBrandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pitchExitBrandId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pitch_viewsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneWithoutPitchViewsNestedInput
  }

  export type pitch_viewsUncheckedUpdateWithoutUserInput = {
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pitch_viewsUncheckedUpdateManyWithoutUserInput = {
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUpdateWithoutUserInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productsUpdateOneWithoutRatingsNestedInput
    brand?: brandsUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ratingsUncheckedUpdateWithoutUserInput = {
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ratingsUncheckedUpdateManyWithoutUserInput = {
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsUpdateWithoutUsersForYouInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutUsersForYouInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateManyWithoutUsersForYouInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type brandsUpdateWithoutUsersForYouPoolInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersNotInterestedBrands?: usersUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutUsersForYouPoolInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersNotInterestedBrands?: usersUncheckedUpdateManyWithoutNotInterestedBrandsNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateManyWithoutUsersForYouPoolInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type brandsUpdateWithoutUsersNotInterestedBrandsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUpdateManyWithoutBrandNestedInput
    products?: productsUpdateManyWithoutBrandNestedInput
    category?: categoriesUpdateOneWithoutBrandsNestedInput
    ratings?: ratingsUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUpdateManyWithoutForYouBrandsPoolNestedInput
    linkVisits?: link_visitsUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUpdateManyWithoutBrandNestedInput
    owner?: usersUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutUsersNotInterestedBrandsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pitchQuestions?: questionsUncheckedUpdateManyWithoutBrandNestedInput
    pitchViews?: pitch_viewsUncheckedUpdateManyWithoutBrandNestedInput
    products?: productsUncheckedUpdateManyWithoutBrandNestedInput
    ratings?: ratingsUncheckedUpdateManyWithoutBrandNestedInput
    usersForYou?: usersUncheckedUpdateManyWithoutForYouBrandsNestedInput
    usersForYouPool?: usersUncheckedUpdateManyWithoutForYouBrandsPoolNestedInput
    linkVisits?: link_visitsUncheckedUpdateManyWithoutBrandNestedInput
    brandScreenTimes?: brand_screen_timesUncheckedUpdateManyWithoutBrandNestedInput
    productionSubmissions?: production_submissionsUncheckedUpdateManyWithoutBrandNestedInput
    owner?: usersUncheckedUpdateOneWithoutOwnedBrandNestedInput
    posts?: postsUncheckedUpdateManyWithoutBrandNestedInput
    dealCodeGroups?: deal_code_groupsUncheckedUpdateManyWithoutBrandNestedInput
    unlockHistory?: unlocked_brands_historyUncheckedUpdateManyWithoutBrandNestedInput
    pitchExitBrandAnswers?: answersUncheckedUpdateManyWithoutPitchExitBrandNestedInput
    productFeedbackAnswers?: answersUncheckedUpdateManyWithoutProductFeedbackBrandNestedInput
  }

  export type brandsUncheckedUpdateManyWithoutUsersNotInterestedBrandsInput = {
    description?: InputJsonValue | InputJsonValue
    shortDescription?: InputJsonValue | InputJsonValue | null
    name?: StringFieldUpdateOperationsInput | string
    pitchVideo?: NullableStringFieldUpdateOperationsInput | string | null
    pitchCaptions?: InputJsonValue | InputJsonValue | null
    pitchSections?: InputJsonValue | InputJsonValue | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandLogo?: InputJsonValue | InputJsonValue | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    managerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    managerName?: NullableStringFieldUpdateOperationsInput | string | null
    managerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: brandsUpdatelabelsInput | InputJsonValue[]
    teamPicture?: InputJsonValue | InputJsonValue | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    teaser?: NullableStringFieldUpdateOperationsInput | string | null
    mainPhrase?: NullableStringFieldUpdateOperationsInput | string | null
    founders?: brandsUpdatefoundersInput | InputJsonValue[]
    image?: InputJsonValue | InputJsonValue | null
    usersForYouIds?: brandsUpdateusersForYouIdsInput | string[]
    usersForYouPoolIds?: brandsUpdateusersForYouPoolIdsInput | string[]
    usersNotInterestedBrandsIds?: brandsUpdateusersNotInterestedBrandsIdsInput | string[]
    images?: brandsUpdateimagesInput | InputJsonValue[]
    usersFeedback?: InputJsonValue | InputJsonValue | null
    selectedFeedback?: InputJsonValue | InputJsonValue
    targetGender?: NullableEnumGenderPreferenceFieldUpdateOperationsInput | $Enums.GenderPreference | null
    budgetInterval?: NullableIntFieldUpdateOperationsInput | number | null
    shopifyDomain?: NullableStringFieldUpdateOperationsInput | string | null
    shopifyKeyName?: NullableStringFieldUpdateOperationsInput | string | null
    ledgeRating?: IntFieldUpdateOperationsInput | number
    showTeamPictureInRating?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type link_visitsUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneWithoutLinkVisitsNestedInput
    product?: productsUpdateOneWithoutLinkVisitsNestedInput
    benefit?: benefitsUpdateOneWithoutLinkVisitsNestedInput
  }

  export type link_visitsUncheckedUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    benefitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type link_visitsUncheckedUpdateManyWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    benefitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brand_screen_timesUpdateWithoutUserInput = {
    time?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneWithoutBrandScreenTimesNestedInput
  }

  export type brand_screen_timesUncheckedUpdateWithoutUserInput = {
    time?: IntFieldUpdateOperationsInput | number
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brand_screen_timesUncheckedUpdateManyWithoutUserInput = {
    time?: IntFieldUpdateOperationsInput | number
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackUpdateWithoutUserInput = {
    text?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackUncheckedUpdateWithoutUserInput = {
    text?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbackUncheckedUpdateManyWithoutUserInput = {
    text?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type production_submissionsUpdateWithoutUserInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutProductionSubmissionsNestedInput
  }

  export type production_submissionsUncheckedUpdateWithoutUserInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandId?: StringFieldUpdateOperationsInput | string
  }

  export type production_submissionsUncheckedUpdateManyWithoutUserInput = {
    overlays?: production_submissionsUpdateoverlaysInput | InputJsonValue[]
    videos?: production_submissionsUpdatevideosInput | InputJsonValue[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandId?: StringFieldUpdateOperationsInput | string
  }

  export type deal_codesUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: deal_code_groupsUpdateOneRequiredWithoutDealCodesNestedInput
  }

  export type deal_codesUncheckedUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    groupId?: StringFieldUpdateOperationsInput | string
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deal_codesUncheckedUpdateManyWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    groupId?: StringFieldUpdateOperationsInput | string
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unlocked_brands_historyUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneWithoutUnlockHistoryNestedInput
  }

  export type unlocked_brands_historyUncheckedUpdateWithoutUserInput = {
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type unlocked_brands_historyUncheckedUpdateManyWithoutUserInput = {
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_choicesUpdateWithoutUserInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: categoriesUpdateOneRequiredWithoutUserChoicesNestedInput
  }

  export type category_choicesUncheckedUpdateWithoutUserInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_choicesUncheckedUpdateManyWithoutUserInput = {
    like?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type postsUpdateWithoutUserLikesInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateWithoutUserLikesInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    userLikesIds?: postsUpdateuserLikesIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type postsUncheckedUpdateManyWithoutUserLikesInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    video?: NullableStringFieldUpdateOperationsInput | string | null
    image?: InputJsonValue | InputJsonValue | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    userLikesIds?: postsUpdateuserLikesIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyUpdateWithoutUserInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyUncheckedUpdateWithoutUserInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type push_notification_historyUncheckedUpdateManyWithoutUserInput = {
    type?: NullableEnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deal_codesCreateManyGroupInput = {
    id?: string
    code: string
    isUsed?: boolean
    userId?: string | null
    userExpireDate?: Date | string | null
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type deal_codesUpdateWithoutGroupInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneWithoutDealCodesNestedInput
  }

  export type deal_codesUncheckedUpdateWithoutGroupInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deal_codesUncheckedUpdateManyWithoutGroupInput = {
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BenefitsCountOutputTypeDefaultArgs instead
     */
    export type BenefitsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BenefitsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandsCountOutputTypeDefaultArgs instead
     */
    export type BrandsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriesCountOutputTypeDefaultArgs instead
     */
    export type CategoriesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoundersReachedLeaderboardCountOutputTypeDefaultArgs instead
     */
    export type FoundersReachedLeaderboardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoundersReachedLeaderboardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostsCountOutputTypeDefaultArgs instead
     */
    export type PostsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductsCountOutputTypeDefaultArgs instead
     */
    export type ProductsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionnairesCountOutputTypeDefaultArgs instead
     */
    export type QuestionnairesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionnairesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Question_classesCountOutputTypeDefaultArgs instead
     */
    export type Question_classesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Question_classesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionsCountOutputTypeDefaultArgs instead
     */
    export type QuestionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LevelsCountOutputTypeDefaultArgs instead
     */
    export type LevelsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LevelsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Deal_code_groupsCountOutputTypeDefaultArgs instead
     */
    export type Deal_code_groupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Deal_code_groupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use order_historyDefaultArgs instead
     */
    export type order_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = order_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use answersDefaultArgs instead
     */
    export type answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = answersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_versionsDefaultArgs instead
     */
    export type app_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_versionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use benefitsDefaultArgs instead
     */
    export type benefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = benefitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use brandsDefaultArgs instead
     */
    export type brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = brandsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use unlocked_brands_historyDefaultArgs instead
     */
    export type unlocked_brands_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = unlocked_brands_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use brand_screen_timesDefaultArgs instead
     */
    export type brand_screen_timesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = brand_screen_timesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use categoriesDefaultArgs instead
     */
    export type categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = categoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use category_choicesDefaultArgs instead
     */
    export type category_choicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = category_choicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use foundersReachedLeaderboardDefaultArgs instead
     */
    export type foundersReachedLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = foundersReachedLeaderboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use link_visitsDefaultArgs instead
     */
    export type link_visitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = link_visitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pitch_viewsDefaultArgs instead
     */
    export type pitch_viewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pitch_viewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use postsDefaultArgs instead
     */
    export type postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = postsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use production_submissionsDefaultArgs instead
     */
    export type production_submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = production_submissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productsDefaultArgs instead
     */
    export type productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use push_notificationsDefaultArgs instead
     */
    export type push_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = push_notificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use push_notification_historyDefaultArgs instead
     */
    export type push_notification_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = push_notification_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questionnairesDefaultArgs instead
     */
    export type questionnairesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questionnairesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use question_classesDefaultArgs instead
     */
    export type question_classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = question_classesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use questionsDefaultArgs instead
     */
    export type questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = questionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ratingsDefaultArgs instead
     */
    export type ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ratingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use settingsDefaultArgs instead
     */
    export type settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = settingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use terms_and_conditionsDefaultArgs instead
     */
    export type terms_and_conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = terms_and_conditionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use feedbackDefaultArgs instead
     */
    export type feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = feedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use levelsDefaultArgs instead
     */
    export type levelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = levelsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use deal_codesDefaultArgs instead
     */
    export type deal_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = deal_codesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use deal_code_groupsDefaultArgs instead
     */
    export type deal_code_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = deal_code_groupsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}